<html>
<head>
    <title>Googly Quest: Portal Panic!</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        canvas {
            border: 1px solid #4B0082;
            background: linear-gradient(#000033, #4B0082);
            width: 100%;
            height: 100vh;
            object-fit: contain;
        }
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #000;
            font-family: 'Orbitron', sans-serif;
        }
        #debugControl {
            color: white;
            margin-bottom: 10px;
        }
        #titleScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(#000033, #4B0082);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            transition: opacity 1s;
        }
        #titleScreen h1 {
            font-size: 48px;
            text-align: center;
            margin-bottom: 20px;
            animation: glow 2s ease-in-out infinite alternate;
        }
        #titleScreen p {
            font-size: 24px;
            margin-bottom: 40px;
        }
        #startButton {
            padding: 15px 30px;
            font-size: 20px;
            background: transparent;
            border: 2px solid white;
            color: white;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            transition: all 0.3s;
        }
        #startButton:hover {
            background: white;
            color: #4B0082;
        }
        @keyframes glow {
            from {
                text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #8A2BE2, 0 0 20px #8A2BE2;
            }
            to {
                text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #8A2BE2, 0 0 40px #8A2BE2;
            }
        }
    </style>
</head>
<body>
    <div id="titleScreen">
        <h1>Googly Quest</h1>
        <p>Portal Panic!</p>
        <button id="startButton">START BOUNCING!</button>
    </div>
    <div id="debugControl">
        <input type="checkbox" id="debugMode">
        <label for="debugMode">Show Debug Boxes</label>
    </div>
    <canvas id="gameCanvas" width="1600" height="800"></canvas>
    <script>
        const titleScreen = document.getElementById('titleScreen');
        const startButton = document.getElementById('startButton');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.scale(2, 2); // Scale everything up by 2x
        const debugCheckbox = document.getElementById('debugMode');

        startButton.addEventListener('click', () => {
            titleScreen.style.opacity = '0';
            setTimeout(() => {
                titleScreen.style.display = 'none';
                sounds.backgroundMusic.play();
            }, 1000);
        });

        // Sound Effects
        const sounds = {
            jump: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=cartoon_jump_boing&duration=0.5&ext=.mp3'),
            boomerangThrow: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=whoosh_throw_effect&duration=0.5&ext=.mp3'),
            boomerangReturn: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=whoosh_catch_effect&duration=0.5&ext=.mp3'),
            enemyHit: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=enemy_hurt_impact&duration=0.5&ext=.mp3'),
            playerHurt: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=character_hurt_groan&duration=0.5&ext=.mp3'),
            gameOver: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=sad_game_over_tune&duration=1&ext=.mp3'),
            levelComplete: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=victory_fanfare_happy&duration=1&ext=.mp3'),
            backgroundMusic: new Audio('https://sounds.fuzzycode.dev/music?prompt=playful_bouncy_cartoon_game_music_with_silly_melodies&duration=30&ext=.mp3')
        };

        // Set background music to loop
        sounds.backgroundMusic.loop = true;
        sounds.backgroundMusic.volume = 0.3;

        // Handle window resizing
        window.addEventListener('resize', function() {
            const aspectRatio = canvas.width / canvas.height;
            const windowRatio = window.innerWidth / window.innerHeight;

            if (windowRatio < aspectRatio) {
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
            } else {
                canvas.style.width = 'auto';
                canvas.style.height = '100vh';
            }
        });

        // Initial resize
        window.dispatchEvent(new Event('resize'));

        class BoundingBox {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }

            intersects(other) {
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }

            draw(color = 'rgba(255, 0, 0, 0.5)') {
                if (debugCheckbox.checked) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                }
            }
        }

        const camera = {
            x: 0,
            y: 0
        };

        let currentLevel = 1;
        let gameOver = false;
        const player = {
            x: 100,
            y: 300,
            width: 30,
            height: 50,
            speed: 5,
            jumpForce: -12,
            velY: 0,
            isJumping: false,
            health: 3,
            maxHealth: 3,
            getBoundingBox() {
                return new BoundingBox(this.x, this.y, this.width, this.height);
            }
        };

        const boomerang = {
            x: player.x,
            y: player.y,
            size: 20,
            speed: 8,
            angle: 0,
            isThrown: false,
            returning: false,
            getBoundingBox() {
                return new BoundingBox(this.x, this.y, this.size, this.size);
            }
        };

        const portal = {
            x: 2300,
            y: 250,
            width: 60,
            height: 100,
            particleTime: 0,
            particles: [],
            getBoundingBox() {
                return new BoundingBox(this.x, this.y, this.width, this.height);
            }
        };

        const platforms = [
            { x: 0, y: 350, width: 2400, height: 50 },
            { x: 300, y: 250, width: 200, height: 20 },
            { x: 500, y: 150, width: 200, height: 20 },
            { x: 800, y: 250, width: 200, height: 20 },
            { x: 1100, y: 150, width: 200, height: 20 },
            { x: 1400, y: 250, width: 200, height: 20 },
            { x: 1700, y: 150, width: 200, height: 20 },
            { x: 2000, y: 250, width: 200, height: 20 }
        ].map(p => ({...p, getBoundingBox() { return new BoundingBox(this.x, this.y, this.width, this.height); }}));

        // We'll store the default enemy configurations for level 1.
        const defaultEnemies = [
            { x: 400, y: 200, width: 30, height: 30, alive: true, health: 2, maxHealth: 2, speed: 2, type: 'flying' },
            { x: 600, y: 100, width: 30, height: 30, alive: true, health: 2, maxHealth: 2, speed: 2, type: 'flying' },
            { x: 900, y: 150, width: 30, height: 30, alive: true, health: 2, maxHealth: 2, speed: 2, type: 'flying' },
            { x: 1200, y: 200, width: 30, height: 30, alive: true, health: 2, maxHealth: 2, speed: 2, type: 'flying' },
            { x: 1500, y: 100, width: 30, height: 30, alive: true, health: 2, maxHealth: 2, speed: 2, type: 'flying' },
            { x: 1800, y: 150, width: 30, height: 30, alive: true, health: 2, maxHealth: 2, speed: 2, type: 'flying' },
            { x: 2100, y: 200, width: 30, height: 30, alive: true, health: 2, maxHealth: 2, speed: 2, type: 'flying' },
            { x: 300, y: 320, width: 40, height: 30, alive: true, health: 3, maxHealth: 3, speed: 3, type: 'ground', direction: 1, patrolStart: 300, patrolEnd: 700 },
            { x: 1200, y: 320, width: 40, height: 30, alive: true, health: 3, maxHealth: 3, speed: 3, type: 'ground', direction: 1, patrolStart: 1200, patrolEnd: 1600 }
        ];
        // Initialize enemies array for the current level.
        let enemies = defaultEnemies.map(e => ({...e, getBoundingBox() { return new BoundingBox(this.x, this.y, this.width, this.height); }}));

        const gravity = 0.5;
        const keys = {};
        let lastHitTime = 0;
        const invincibilityTime = 1000;

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            // If game over and player presses "r", restart the game.
            if (gameOver && e.key.toLowerCase() === 'r') {
                restartGame();
            }
            if (titleScreen.style.display === 'none' && !gameOver && e.key === ' ' && !boomerang.isThrown) {
                throwBoomerang();
            }
        });
        document.addEventListener('keyup', (e) => keys[e.key] = false);
        document.addEventListener('keypress', (e) => {});

        function throwBoomerang() {
            boomerang.isThrown = true;
            boomerang.x = player.x;
            boomerang.y = player.y + player.height/2;
            boomerang.returning = false;
            sounds.boomerangThrow.currentTime = 0;
            sounds.boomerangThrow.play();
        }

        function updateBoomerang() {
            if (!boomerang.isThrown || gameOver) return;

            boomerang.angle += 0.2;

            if (!boomerang.returning) {
                boomerang.x += boomerang.speed;
                if (boomerang.x > player.x + 300) {
                    boomerang.returning = true;
                }
            } else {
                let dx = player.x - boomerang.x;
                let dy = (player.y + player.height/2) - boomerang.y;
                let angle = Math.atan2(dy, dx);
                boomerang.x += Math.cos(angle) * boomerang.speed;
                boomerang.y += Math.sin(angle) * boomerang.speed;

                if (Math.abs(player.x - boomerang.x) < 10 && 
                    Math.abs((player.y + player.height/2) - boomerang.y) < 10) {
                    boomerang.isThrown = false;
                    sounds.boomerangReturn.currentTime = 0;
                    sounds.boomerangReturn.play();
                }
            }

            const boomerangBox = boomerang.getBoundingBox();
            enemies.forEach(enemy => {
                if (enemy.alive && boomerangBox.intersects(enemy.getBoundingBox())) {
                    enemy.health--;
                    if (enemy.health <= 0) {
                        enemy.alive = false;
                    }
                    sounds.enemyHit.currentTime = 0;
                    sounds.enemyHit.play();
                }
            });
        }

        function updateEnemies() {
            if (gameOver) return;
            const playerBox = player.getBoundingBox();
            enemies.forEach(enemy => {
                if (enemy.alive) {
                    if (enemy.type === 'flying') {
                        let dx = player.x - enemy.x;
                        let dy = player.y - enemy.y;
                        let distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 0) {
                            enemy.x += (dx / distance) * enemy.speed;
                            enemy.y += (dy / distance) * enemy.speed;
                        }
                    } else if (enemy.type === 'ground') {
                        enemy.x += enemy.speed * enemy.direction;
                        if (enemy.x >= enemy.patrolEnd) {
                            enemy.direction = -1;
                        } else if (enemy.x <= enemy.patrolStart) {
                            enemy.direction = 1;
                        }
                    }

                    if (enemy.getBoundingBox().intersects(playerBox)) {
                        if (Date.now() - lastHitTime > invincibilityTime) {
                            player.health--;
                            lastHitTime = Date.now();
                            sounds.playerHurt.currentTime = 0;
                            sounds.playerHurt.play();
                        }
                    }
                }
            });
            // Check if player is dead.
            if (player.health <= 0 && !gameOver) {
                gameOver = true;
                sounds.gameOver.play();
                sounds.backgroundMusic.pause();
            }
        }

        function updatePlayer() {
            if (gameOver) return;
            if (keys['ArrowLeft']) player.x -= player.speed;
            if (keys['ArrowRight']) player.x += player.speed;

            if (keys['ArrowUp'] && !player.isJumping) {
                player.velY = player.jumpForce;
                player.isJumping = true;
                sounds.jump.currentTime = 0;
                sounds.jump.play();
            }

            player.velY += gravity;
            player.y += player.velY;

            const playerBox = player.getBoundingBox();
            player.isJumping = true;
            platforms.forEach(platform => {
                if (playerBox.intersects(platform.getBoundingBox())) {
                    if (player.velY > 0) {
                        player.isJumping = false;
                        player.velY = 0;
                        player.y = platform.y - player.height;
                    }
                }
            });

            const levelWidth = 2400; // Match the width of our last platform
            player.x = Math.max(0, Math.min(levelWidth - player.width, player.x));
            player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
        }

        function drawHealthBar(x, y, health, maxHealth, width = 30) {
            const height = 5;
            const healthPercent = health / maxHealth;

            ctx.fillStyle = 'red';
            ctx.fillRect(x, y - 10, width, height);

            ctx.fillStyle = 'green';
            ctx.fillRect(x, y - 10, width * healthPercent, height);
        }

        // Function to load enemies and other level-specific settings.
        function loadLevel(level) {
            currentLevel = level;
            // Reset player and camera positions.
            player.x = 100;
            player.y = 300;
            camera.x = 0;
            boomerang.isThrown = false;
            // For simplicity, we define two levels. Level 1 uses defaultEnemies.
            if (level === 1) {
                enemies = defaultEnemies.map(e => ({...e, getBoundingBox() { return new BoundingBox(this.x, this.y, this.width, this.height); }}));
                player.health = player.maxHealth;
            }
            else if (level === 2) {
                // Create a new set of enemies for level 2 with adjusted positions.
                const level2Enemies = [
                    { x: 500, y: 180, width: 30, height: 30, alive: true, health: 3, maxHealth: 3, speed: 2, type: 'flying' },
                    { x: 750, y: 120, width: 30, height: 30, alive: true, health: 3, maxHealth: 3, speed: 2, type: 'flying' },
                    { x: 1000, y: 170, width: 30, height: 30, alive: true, health: 3, maxHealth: 3, speed: 2, type: 'flying' },
                    { x: 1250, y: 220, width: 30, height: 30, alive: true, health: 3, maxHealth: 3, speed: 2, type: 'flying' },
                    { x: 1500, y: 120, width: 30, height: 30, alive: true, health: 3, maxHealth: 3, speed: 2, type: 'flying' },
                    { x: 600, y: 320, width: 40, height: 30, alive: true, health: 3, maxHealth: 3, speed: 3, type: 'ground', direction: 1, patrolStart: 600, patrolEnd: 1000 },
                    { x: 1400, y: 320, width: 40, height: 30, alive: true, health: 3, maxHealth: 3, speed: 3, type: 'ground', direction: 1, patrolStart: 1400, patrolEnd: 1800 }
                ];
                enemies = level2Enemies.map(e => ({...e, getBoundingBox() { return new BoundingBox(this.x, this.y, this.width, this.height); }}));
                // Optionally reset player health or increase difficulty.
                player.health = player.maxHealth;
            }
        }

        // Function to restart the game after game over.
        function restartGame() {
            gameOver = false;
            sounds.backgroundMusic.currentTime = 0;
            sounds.backgroundMusic.play();
            currentLevel = 1;
            player.x = 100;
            player.y = 300;
            player.health = player.maxHealth;
            player.velY = 0;
            boomerang.isThrown = false;
            camera.x = 0;
            loadLevel(1);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update camera to follow player
            camera.x = Math.max(0, player.x - canvas.width/4);

            ctx.save();
            ctx.translate(-camera.x, 0);

            platforms.forEach(platform => {
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                platform.getBoundingBox().draw('rgba(0, 255, 0, 0.5)');
            });

            // Draw player body (jetpack-like shape)
            ctx.fillStyle = '#4169E1';
            ctx.beginPath();
            ctx.roundRect(player.x, player.y, player.width, player.height, 10);
            ctx.fill();

            // Draw jetpack
            ctx.fillStyle = '#1E90FF';
            ctx.fillRect(player.x - 5, player.y + 15, 10, 25);

            // Draw googly eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(player.x + 10, player.y + 15, 8, 0, Math.PI * 2);
            ctx.arc(player.x + 20, player.y + 15, 8, 0, Math.PI * 2);
            ctx.fill();

            // Draw pupils (slightly bouncing)
            ctx.fillStyle = 'black';
            const eyeBounce = Math.sin(Date.now() / 200) * 2;
            ctx.beginPath();
            ctx.arc(player.x + 10, player.y + 15 + eyeBounce, 4, 0, Math.PI * 2);
            ctx.arc(player.x + 20, player.y + 15 + eyeBounce, 4, 0, Math.PI * 2);
            ctx.fill();

            player.getBoundingBox().draw('rgba(0, 0, 255, 0.5)');
            drawHealthBar(player.x, player.y, player.health, player.maxHealth);

            enemies.forEach(enemy => {
                if (enemy.alive) {
                    if (enemy.type === 'flying') {
                        // Draw flying enemy (spiky blob)
                        ctx.fillStyle = '#FF4444';
                        ctx.beginPath();
                        ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width/2, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw spikes
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 3;
                        for(let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            ctx.beginPath();
                            ctx.moveTo(
                                enemy.x + enemy.width/2 + Math.cos(angle) * (enemy.width/2),
                                enemy.y + enemy.height/2 + Math.sin(angle) * (enemy.height/2)
                            );
                            ctx.lineTo(
                                enemy.x + enemy.width/2 + Math.cos(angle) * (enemy.width/2 + 8),
                                enemy.y + enemy.height/2 + Math.sin(angle) * (enemy.height/2 + 8)
                            );
                            ctx.stroke();
                        }
                    } else if (enemy.type === 'ground') {
                        // Draw ground enemy (tank-like shape)
                        ctx.fillStyle = '#8B0000';
                        
                        // Draw tank body
                        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                        
                        // Draw tank treads
                        ctx.fillStyle = '#4A0000';
                        ctx.fillRect(enemy.x, enemy.y + enemy.height - 8, enemy.width, 8);
                        
                        // Draw cannon (pointing in movement direction)
                        ctx.fillStyle = '#8B0000';
                        const cannonWidth = 20;
                        const cannonHeight = 8;
                        if (enemy.direction > 0) {
                            ctx.fillRect(enemy.x + enemy.width - 5, enemy.y + 5, cannonWidth, cannonHeight);
                        } else {
                            ctx.fillRect(enemy.x - cannonWidth + 5, enemy.y + 5, cannonWidth, cannonHeight);
                        }
                    }

                    // Draw googly eyes
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(enemy.x + 10, enemy.y + 15, 6, 0, Math.PI * 2);
                    ctx.arc(enemy.x + 20, enemy.y + 15, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw pupils (wobbling)
                    ctx.fillStyle = 'black';
                    const enemyEyeWobble = Math.sin(Date.now() / 150 + enemy.x) * 2;
                    ctx.beginPath();
                    ctx.arc(enemy.x + 10 + enemyEyeWobble, enemy.y + 15, 3, 0, Math.PI * 2);
                    ctx.arc(enemy.x + 20 + enemyEyeWobble, enemy.y + 15, 3, 0, Math.PI * 2);
                    ctx.fill();

                    enemy.getBoundingBox().draw('rgba(255, 0, 0, 0.5)');
                    drawHealthBar(enemy.x, enemy.y, enemy.health, enemy.maxHealth);
                }
            });

            if (boomerang.isThrown) {
                ctx.save();
                ctx.translate(boomerang.x + boomerang.size/2, boomerang.y + boomerang.size/2);
                ctx.rotate(boomerang.angle);
                
                // Draw boomerang shape
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.moveTo(-boomerang.size/2, -boomerang.size/2);
                ctx.quadraticCurveTo(0, -boomerang.size/2, boomerang.size/2, 0);
                ctx.quadraticCurveTo(boomerang.size/2, boomerang.size/2, 0, boomerang.size/2);
                ctx.quadraticCurveTo(-boomerang.size/2, boomerang.size/2, -boomerang.size/2, -boomerang.size/2);
                ctx.fill();
                
                // Add googly eye
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(0, 0, boomerang.size/4, 0, Math.PI * 2);
                ctx.fill();
                
                // Add pupil (wobbling)
                ctx.fillStyle = 'black';
                const eyeWobble = Math.sin(Date.now() / 150) * 2;
                ctx.beginPath();
                ctx.arc(eyeWobble, 0, boomerang.size/8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                boomerang.getBoundingBox().draw('rgba(255, 255, 0, 0.5)');
            }

            // Draw portal
            const portalGradient = ctx.createLinearGradient(portal.x, portal.y, portal.x + portal.width, portal.y);
            portalGradient.addColorStop(0, '#4B0082');
            portalGradient.addColorStop(0.5, '#8A2BE2');
            portalGradient.addColorStop(1, '#4B0082');

            ctx.fillStyle = portalGradient;
            ctx.beginPath();
            ctx.ellipse(
                portal.x + portal.width/2,
                portal.y + portal.height/2,
                portal.width/2,
                portal.height/2,
                0, 0, Math.PI * 2
            );
            ctx.fill();

            // Portal particles
            if (Date.now() - portal.particleTime > 100) {
                portal.particleTime = Date.now();
                portal.particles.push({
                    x: portal.x + portal.width/2,
                    y: portal.y + Math.random() * portal.height,
                    size: Math.random() * 5 + 2,
                    speed: Math.random() * 2 + 1,
                    life: 1
                });
            }

            portal.particles = portal.particles.filter(p => {
                p.x += p.speed;
                p.life -= 0.02;
                ctx.fillStyle = `rgba(147, 112, 219, ${p.life})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                return p.life > 0;
            });

            portal.getBoundingBox().draw('rgba(147, 112, 219, 0.5)');

            // Check if player reaches portal and is not in gameOver state.
            if (!gameOver && player.getBoundingBox().intersects(portal.getBoundingBox())) {
                // Only trigger level completion once
                if (!this.levelCompleting) {
                    this.levelCompleting = true;
                    this.transitionStart = Date.now();
                    sounds.levelComplete.play();
                    setTimeout(() => {
                        loadLevel(currentLevel + 1);
                        this.levelCompleting = false;
                    }, 300);
                }
                
                // Create transition effect
                const transitionProgress = (Date.now() - this.transitionStart) / 2000;
                const circles = 5;
                
                // Draw expanding circles
                for (let i = 0; i < circles; i++) {
                    const delay = i * 0.2; // Stagger the circles
                    let progress = Math.max(0, Math.min(1, (transitionProgress - delay) * 2));
                    
                    if (progress > 0) {
                        ctx.beginPath();
                        ctx.fillStyle = `rgba(75, 0, 130, ${1 - progress})`;
                        const radius = progress * Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
                        ctx.arc(camera.x + canvas.width/4, canvas.height/4, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw completion text with fade-in effect
                const textOpacity = Math.min(1, transitionProgress * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${textOpacity})`;
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                const text = 'Level Complete!';
                ctx.fillText(text, camera.x + canvas.width/4, canvas.height/4);
                
                // Add floating particles
                if (Math.random() < 0.2) {
                    portal.particles.push({
                        x: camera.x + Math.random() * canvas.width/2,
                        y: Math.random() * canvas.height/2,
                        size: Math.random() * 4 + 2,
                        speedX: (Math.random() - 0.5) * 4,
                        speedY: -Math.random() * 2 - 1,
                        life: 1
                    });
                }
                
                // Update and draw celebration particles
                portal.particles = portal.particles.filter(p => {
                    p.x += p.speedX;
                    p.y += p.speedY;
                    p.life -= 0.02;
                    ctx.fillStyle = `rgba(147, 112, 219, ${p.life})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    return p.life > 0;
                });
            }

            ctx.restore(); // Restore the camera transform

            // Draw Game Over overlay if applicable.
            if (gameOver) {
                ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                ctx.fillRect(0, 0, canvas.width/2, canvas.height/2);
                ctx.fillStyle = 'white';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("Game Over!", canvas.width/4, canvas.height/4 - 30);
                ctx.font = '24px Arial';
                ctx.fillText("Press 'R' to Restart", canvas.width/4, canvas.height/4 + 20);
            }
        }

        function gameLoop() {
            if (!gameOver && titleScreen.style.display === 'none') {
                updatePlayer();
                updateBoomerang();
                updateEnemies();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>