<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Koala vs Kangaroos Platformer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            background-color: #87CEEB;
        }
        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        #score-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Comic Sans MS', cursive, sans-serif;
            font-size: 36px;
            color: #ffcc00;
            text-shadow: 3px 3px 5px rgba(0, 0, 0, 0.7),
                         -1px -1px 0 #000,  
                          1px -1px 0 #000,
                         -1px 1px 0 #000,
                          1px 1px 0 #000;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 5px 20px;
            border-radius: 20px;
            z-index: 5;
        }
        @keyframes scorePopup {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }
        .score-animation {
            animation: scorePopup 0.5s ease;
        }
        #music-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 10px;
            color: white;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            z-index: 5;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s ease;
        }
        #music-controls:hover {
            background-color: rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
        }
        #music-title {
            margin-bottom: 5px;
            font-size: 14px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }
        #music-buttons {
            display: flex;
            justify-content: center;
            gap: 5px;
        }
        .music-button {
            background-color: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s ease;
        }
        .music-button:hover {
            background-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
        }
        .music-button:active {
            transform: scale(0.95);
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
        }
        #start-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ffcc00;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
        }
        #start-screen p {
            font-size: 24px;
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
        }
        #start-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #start-button:hover {
            background-color: #45a049;
        }
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
        }
        #game-over-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff6666;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
        }
        #restart-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-top: 20px;
        }
        #restart-button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="score-display">SCORE: 0</div>
        <div id="ui-container">
            <div id="health">Health: 3</div>
            <div id="hunger">Hunger: 100%</div>
        </div>
        <div id="music-controls">
            <div id="music-title">Music: Off</div>
            <div id="music-buttons">
                <button id="prev-track" class="music-button">‚èÆÔ∏è</button>
                <button id="play-pause" class="music-button">‚ñ∂Ô∏è</button>
                <button id="next-track" class="music-button">‚è≠Ô∏è</button>
            </div>
        </div>
        <div id="start-screen">
            <h1>Koala vs Kangaroos</h1>
            <p>Help Koala defeat the angry kangaroos by throwing boomerangs at them! Collect bamboo to stay alive as your hunger constantly decreases. Use the arrow keys to move and jump, and press SPACE to throw boomerangs.</p>
            <button id="start-button">Start Game</button>
        </div>
        <div id="game-over-screen">
            <h1>Game Over</h1>
            <div id="final-score">Score: 0</div>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Game elements
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const scoreElement = document.getElementById('score-display');
            const healthElement = document.getElementById('health');
            const hungerElement = document.getElementById('hunger');
            const startScreen = document.getElementById('start-screen');
            const startButton = document.getElementById('start-button');
            const gameOverScreen = document.getElementById('game-over-screen');
            const finalScoreElement = document.getElementById('final-score');
            const restartButton = document.getElementById('restart-button');

            // Game state
            let gameRunning = false;
            let score = 0;
            let scoreMultiplier = 1;
            let survivalTimer = 0;
            let health = 3;
            let hunger = 100; // Hunger meter (100 = full, 0 = starving)
            let explosions = [];
            let bamboos = [];
            let iceProjectiles = [];
            let isBossFight = false;
            let bossSpawned = false;
            let playerFrozen = false;
            let freezeTimer = 0;
            const freezeDuration = 180; // 3 seconds at 60 FPS

            // Canvas setup
            canvas.width = 800;
            canvas.height = 500;

            // Load assets
            const koalaImg = new Image();
            koalaImg.src = 'https://images.fuzzycode.dev/fast_ai?search=cartoon%20koala%20character%20side%20view&resize=64x64&transparency=true';

            const koalaFrozenImg = new Image();
            koalaFrozenImg.src = 'https://images.fuzzycode.dev/fast_ai?search=cartoon%20koala%20character%20frozen%20blue%20icy&resize=64x64&transparency=true';

            const kangarooImg = new Image();
            kangarooImg.src = 'https://aws.fuzzycode.dev/image_buddy_365day_cache/uploads/1c159ab3-db18-4cfe-847d-0342d6f3038c/angry cartoon kangaroo side view!resize_64x64_843c9713a7.png';

            const superKangarooImg = new Image();
            superKangarooImg.src = 'https://images.fuzzycode.dev/fast_ai?search=giant%20muscular%20kangaroo%20boss%20with%20ice%20powers%20cartoon&resize=128x128&transparency=true';

            const iceProjectileImg = new Image();
            iceProjectileImg.src = 'https://images.fuzzycode.dev/fast_ai?search=blue%20ice%20shard%20projectile&resize=32x32&transparency=true';

            const boomerangImg = new Image();
            boomerangImg.src = 'https://images.fuzzycode.dev/fast_ai?search=wooden%20boomerang&resize=32x32&transparency=true';

            const platformImg = new Image();
            platformImg.src = 'https://aws.fuzzycode.dev/image_buddy_365day_cache/uploads/1c159ab3-db18-4cfe-847d-0342d6f3038c/grass platform pixel art!resize_128x32.png';

            const bambooImg = new Image();
            bambooImg.src = 'https://aws.fuzzycode.dev/image_buddy_365day_cache/uploads/1c159ab3-db18-4cfe-847d-0342d6f3038c/bamboo shoot cartoon lush green!resize_48x48.png';

            const backgroundImg = new Image();
            backgroundImg.src = 'https://images.fuzzycode.dev/fast_ai?search=australian%20outback%20landscape%20cartoon&resize=800x500';

            // Explosion sprite sheet
            const explosionImg = new Image();
            explosionImg.src = 'https://images.fuzzycode.dev/fast_ai?search=cartoon%20explosion%20sprite%20sheet%20sequence&resize=384x64&transparency=true';

            // Sound effects
            const jumpSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=koala%20jump%20sound&duration=0.5&ext=.mp3');
            const throwSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=boomerang%20throw%20whoosh&duration=0.5&ext=.mp3');
            const hitSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=kangaroo%20hurt%20sound&duration=0.5&ext=.mp3');
            const hurtSound = new Audio('https://aws.fuzzycode.dev/generated_sound_effects/cartoonish-koala-cry.wav');
            const explosionSound = new Audio('https://aws.fuzzycode.dev/generated_sound_effects/boomerang-hit-then-explosion.wav');
            const eatSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=koala%20eating%20bamboo%20crunch&duration=0.5&ext=.mp3');
            const hungerSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=stomach%20growling%20hungry&duration=1&ext=.mp3');
            const bossAppearSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=dramatic%20boss%20appearance%20stinger&duration=2&ext=.mp3');
            const iceThrowSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=ice%20shard%20throw%20cold%20whoosh&duration=0.5&ext=.mp3');
            const freezeSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=freezing%20ice%20crystallization&duration=1&ext=.mp3');
            const unfreezeSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=ice%20breaking%20thawing&duration=0.5&ext=.mp3');
            const bossDamageSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=large%20kangaroo%20boss%20roar%20in%20pain&duration=1&ext=.mp3');
            const bossDefeatSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=epic%20boss%20defeat%20explosion&duration=2&ext=.mp3');

            // Game music tracks
            const musicTracks = [
                {
                    name: "Adventure",
                    audio: new Audio('https://sounds.fuzzycode.dev/music?prompt=upbeat%20australian%20adventure%20game%20music&duration=30&ext=.mp3'),
                    icon: "üå¥"
                },
                {
                    name: "Action",
                    audio: new Audio('https://sounds.fuzzycode.dev/music?prompt=energetic%20koala%20action%20game%20music&duration=30&ext=.mp3'),
                    icon: "‚ö°"
                },
                {
                    name: "Chill",
                    audio: new Audio('https://sounds.fuzzycode.dev/music?prompt=relaxing%20bamboo%20forest%20ambient%20music&duration=30&ext=.mp3'),
                    icon: "üéã"
                }
            ];

            // Set all tracks to loop
            musicTracks.forEach(track => {
                track.audio.loop = true;
            });

            let currentMusicIndex = 0;
            let isMusicPlaying = false;
            let currentMusic = musicTracks[currentMusicIndex].audio;

            // Player
            const player = {
                x: 100,
                y: 300,
                width: 64,
                height: 64,
                velocityX: 0,
                velocityY: 0,
                jumping: false,
                facingRight: true,
                canThrow: true,
                throwCooldown: 500, // ms
                lastThrowTime: 0,
                invincible: false,
                invincibleTimer: 0,
                isFlashing: false,
                flashTimer: 0
            };

            // Platforms
            const platforms = [
                { x: 0, y: 450, width: 300, height: 32 },
                { x: 350, y: 400, width: 200, height: 32 },
                { x: 600, y: 350, width: 200, height: 32 },
                { x: 200, y: 300, width: 150, height: 32 },
                { x: 400, y: 250, width: 150, height: 32 },
                { x: 100, y: 200, width: 150, height: 32 },
                { x: 600, y: 150, width: 200, height: 32 }
            ];

            // Enemies
            let enemies = [];

            // Boomerang
            let boomerang = null;

            // Controls
            const keys = {
                left: false,
                right: false,
                up: false,
                space: false
            };

            // Game constants
            const gravity = 0.5;
            const playerSpeed = 5;
            const jumpStrength = 12;
            const boomerangSpeed = 8;
            const boomerangReturnSpeed = 10;
            const enemySpeed = 2;
            const hungerDecreaseRate = 0.1; // How fast hunger decreases
            const hungerDamageThreshold = 20; // Below this hunger level, health decreases
            const hungerHealthDamageRate = 180; // Frames before taking damage when hungry
            let hungerDamageCounter = 0;
            const bambooSpawnRate = 300; // Frames between bamboo spawns
            let bambooSpawnCounter = 0;

            // Event listeners
            window.addEventListener('keydown', function(e) {
                // Don't process arrow keys if a music control button is focused
                const activeElement = document.activeElement;
                const isMusicControlFocused = activeElement && activeElement.classList.contains('music-button');

                if (!isMusicControlFocused) {
                    if (e.key === 'ArrowLeft') keys.left = true;
                    if (e.key === 'ArrowRight') keys.right = true;
                    if (e.key === 'ArrowUp') keys.up = true;
                    if (e.key === ' ') keys.space = true;
                }
            });

            window.addEventListener('keyup', function(e) {
                if (e.key === 'ArrowLeft') keys.left = false;
                if (e.key === 'ArrowRight') keys.right = false;
                if (e.key === 'ArrowUp') keys.up = false;
                if (e.key === ' ') keys.space = false;
            });

            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartGame);

            // Game functions
            function startGame() {
                gameRunning = true;
                startScreen.style.display = 'none';
                score = 0;
                health = 3;
                hunger = 100;
                updateUI();
                resetGame();
                if (isMusicPlaying) {
                    playCurrentMusic();
                }
                gameLoop();
            }

            function restartGame() {
                gameRunning = true;
                gameOverScreen.style.display = 'none';
                score = 0;
                health = 3;
                hunger = 100;
                updateUI();
                resetGame();
                if (isMusicPlaying) {
                    playCurrentMusic();
                }
                gameLoop();
            }

            function resetGame() {
                player.x = 100;
                player.y = 300;
                player.velocityX = 0;
                player.velocityY = 0;
                player.jumping = false;
                player.facingRight = true;

                enemies = [];
                boomerang = null;
                explosions = [];
                bamboos = [];
                iceProjectiles = [];
                hungerDamageCounter = 0;
                bambooSpawnCounter = 0;
                isBossFight = false;
                bossSpawned = false;
                playerFrozen = false;
                freezeTimer = 0;

                // Spawn initial enemies
                spawnEnemy();

                // Spawn initial bamboo
                spawnBamboo();
            }

            function gameLoop() {
                if (!gameRunning) return;

                update();
                render();

                requestAnimationFrame(gameLoop);
            }

            function update() {
                // Update survival timer and score multiplier
                if (gameRunning) {
                    survivalTimer++;

                    // Increase score just for surviving
                    if (survivalTimer % 60 === 0) { // Every second (assuming 60 FPS)
                        increaseScore(1 * scoreMultiplier);
                    }

                    // Increase multiplier over time
                    if (survivalTimer % 600 === 0) { // Every 10 seconds
                        scoreMultiplier += 0.1;
                    }

                    // Check if we should start boss fight
                    if (score >= 500 && !bossSpawned) {
                        startBossFight();
                    }
                    
                    // Safety check for boss - ensure it stays on screen
                    const bossIndex = enemies.findIndex(e => e.isBoss);
                    if (bossIndex !== -1) {
                        const boss = enemies[bossIndex];
                        
                        // If boss somehow got off screen, bring it back
                        if (boss.x < -50 || boss.x > canvas.width + 50 || 
                            boss.y < -100 || boss.y > canvas.height + 100) {
                            console.log("Boss recovery triggered - boss was off screen");
                            
                            // Find best platform for boss to stand on
                            let bestPlatform = platforms[0];
                            for (let platform of platforms) {
                                if (platform.width > bestPlatform.width) {
                                    bestPlatform = platform;
                                }
                            }
                            
                            // Reset boss to a safe position
                            boss.x = bestPlatform.x + bestPlatform.width/2 - boss.width/2;
                            boss.y = bestPlatform.y - boss.height;
                            boss.velocityY = 0;
                            boss.velocityX = boss.velocityX > 0 ? -3 : 3; // Ensure it's moving
                            boss.isEntering = false;
                            boss.currentPlatform = bestPlatform;
                            boss.aiState = 'patrol';
                        }
                    }
                }

                // Update freeze state if player is frozen
                if (playerFrozen) {
                    freezeTimer--;
                    if (freezeTimer <= 0) {
                        playerFrozen = false;
                        unfreezeSound.cloneNode().play();
                    }
                }

                // Update hunger
                hunger = Math.max(0, hunger - hungerDecreaseRate);

                // Check if hunger is below threshold and damage health
                if (hunger <= hungerDamageThreshold) {
                    hungerDamageCounter++;
                    if (hungerDamageCounter >= hungerHealthDamageRate) {
                        health--;
                        updateUI();
                        hungerSound.cloneNode().play();
                        hungerDamageCounter = 0;

                        if (health <= 0) {
                            gameOver();
                            return;
                        }
                    }
                }

                // Spawn bamboo periodically
                bambooSpawnCounter++;
                if (bambooSpawnCounter >= bambooSpawnRate) {
                    spawnBamboo();
                    bambooSpawnCounter = 0;
                }

                // Update explosions
                for (let i = explosions.length - 1; i >= 0; i--) {
                    explosions[i].update();
                    if (explosions[i].finished) {
                        explosions.splice(i, 1);
                    }
                }

                // Player movement - only if not frozen
                if (!playerFrozen) {
                    if (keys.left) {
                        player.velocityX = -playerSpeed;
                        player.facingRight = false;
                    } else if (keys.right) {
                        player.velocityX = playerSpeed;
                        player.facingRight = true;
                    } else {
                        player.velocityX = 0;
                    }

                    // Jumping
                    if (keys.up && !player.jumping) {
                        player.velocityY = -jumpStrength;
                        player.jumping = true;
                        jumpSound.cloneNode().play();
                    }
                } else {
                    // When frozen, player can't move
                    player.velocityX = 0;
                }

                // Apply gravity
                player.velocityY += gravity;

                // Update player position
                player.x += player.velocityX;
                player.y += player.velocityY;

                // Keep player in bounds
                if (player.x < 0) player.x = 0;
                if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
                
                // Update invincibility state
                if (player.invincible) {
                    player.invincibleTimer--;
                    if (player.invincibleTimer <= 0) {
                        player.invincible = false;
                        player.isFlashing = false;
                    }
                }

                // Check for platform collisions
                player.jumping = true;
                for (let platform of platforms) {
                    if (player.y + player.height > platform.y && 
                        player.y < platform.y + platform.height &&
                        player.x + player.width > platform.x && 
                        player.x < platform.x + platform.width) {

                        // Landing on platform
                        if (player.velocityY > 0 && player.y + player.height - player.velocityY <= platform.y) {
                            player.y = platform.y - player.height;
                            player.velocityY = 0;
                            player.jumping = false;
                        } 
                        // Hitting platform from below
                        else if (player.velocityY < 0 && player.y >= platform.y + platform.height) {
                            player.y = platform.y + platform.height;
                            player.velocityY = 0;
                        }
                    }
                }

                // Check if player fell off the screen
                if (player.y > canvas.height) {
                    health--;
                    updateUI();
                    hurtSound.cloneNode().play();
                    player.x = 100;
                    player.y = 300;
                    player.velocityY = 0;

                    if (health <= 0) {
                        gameOver();
                    }
                }

                // Throw boomerang - only if not frozen
                if (keys.space && player.canThrow && boomerang === null && !playerFrozen) {
                    throwBoomerang();
                    player.lastThrowTime = Date.now();
                    throwSound.cloneNode().play();
                }

                // Update boomerang
                if (boomerang !== null) {
                    // Rotate boomerang
                    boomerang.rotation += 0.2;

                    if (!boomerang.returning) {
                        // Outward flight
                        boomerang.x += boomerang.velocityX;

                        // Check if boomerang should return (reached max distance or edge of screen)
                        if ((boomerang.initialDirection > 0 && boomerang.x > boomerang.maxDistance) || 
                            (boomerang.initialDirection < 0 && boomerang.x < boomerang.maxDistance) ||
                            boomerang.x < 0 || 
                            boomerang.x > canvas.width) {

                            boomerang.returning = true;
                            // Play return sound
                            throwSound.cloneNode().play();
                        }

                        // Check for collisions with enemies
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            let enemy = enemies[j];

                            if (boomerang && enemy &&
                                boomerang.x + boomerang.width > enemy.x && 
                                boomerang.x < enemy.x + enemy.width && 
                                boomerang.y + boomerang.height > enemy.y && 
                                boomerang.y < enemy.y + enemy.height) {

                                // Handle boss differently
                                if (enemy.isBoss) {
                                    enemy.health--;
                                    bossDamageSound.cloneNode().play();

                                    // Start return journey
                                    boomerang.returning = true;

                                    // Increase score for hitting boss
                                    increaseScore(20 * scoreMultiplier);

                                    // If boss health is depleted
                                    if (enemy.health <= 0) {
                                        // Create explosion at boss position
                                        createExplosion(enemy.x, enemy.y);
                                        createExplosion(enemy.x + 50, enemy.y + 20);
                                        createExplosion(enemy.x + 25, enemy.y + 50);

                                        // Remove boss
                                        enemies.splice(j, 1);

                                        // End boss fight
                                        isBossFight = false;

                                        // Increase score for defeating boss
                                        increaseScore(500 * scoreMultiplier);

                                        // Play boss defeat sound
                                        bossDefeatSound.cloneNode().play();

                                        // Spawn regular enemies
                                        setTimeout(spawnEnemy, 2000);
                                        setTimeout(spawnEnemy, 4000);
                                    }
                                } else {
                                    // Regular enemy handling
                                    // Create explosion at enemy position
                                    createExplosion(enemy.x, enemy.y);

                                    // Remove enemy
                                    enemies.splice(j, 1);

                                    // Start return journey
                                    boomerang.returning = true;

                                    // Increase score for defeating enemy
                                    increaseScore(50 * scoreMultiplier);

                                    // Play hit sound
                                    hitSound.cloneNode().play();

                                    // Spawn a new enemy
                                    setTimeout(spawnEnemy, 2000);
                                }
                            }
                        }
                    } else {
                        // Return flight - move toward player
                        const dx = (player.x + player.width / 2) - (boomerang.x + boomerang.width / 2);
                        const dy = (player.y + player.height / 2) - (boomerang.y + boomerang.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > boomerangReturnSpeed) {
                            // Move toward player
                            boomerang.x += (dx / distance) * boomerangReturnSpeed;
                            boomerang.y += (dy / distance) * boomerangReturnSpeed;
                        } else {
                            // Check if close enough to catch
                            if (distance < 30) {
                                // Boomerang caught
                                boomerang = null;
                                return; // Exit early to prevent accessing null boomerang
                            } else {
                                // Final approach
                                boomerang.x += dx * 0.2;
                                boomerang.y += dy * 0.2;
                            }
                        }

                        // Check for collisions with enemies during return
                        if (boomerang) { // Additional null check
                            for (let j = enemies.length - 1; j >= 0; j--) {
                                let enemy = enemies[j];

                                if (enemy && boomerang &&
                                    boomerang.x + boomerang.width > enemy.x && 
                                    boomerang.x < enemy.x + enemy.width && 
                                    boomerang.y + boomerang.height > enemy.y && 
                                    boomerang.y < enemy.y + enemy.height) {

                                    // Handle boss differently
                                    if (enemy.isBoss) {
                                        enemy.health--;
                                        bossDamageSound.cloneNode().play();

                                        // Increase score for hitting boss
                                        increaseScore(20 * scoreMultiplier);

                                        // If boss health is depleted
                                        if (enemy.health <= 0) {
                                            // Create multiple explosions at boss position
                                            createExplosion(enemy.x, enemy.y);
                                            createExplosion(enemy.x + 50, enemy.y + 20);
                                            createExplosion(enemy.x + 25, enemy.y + 50);

                                            // Remove boss
                                            enemies.splice(j, 1);

                                            // End boss fight
                                            isBossFight = false;

                                            // Increase score for defeating boss
                                            increaseScore(500 * scoreMultiplier);

                                            // Play boss defeat sound
                                            bossDefeatSound.cloneNode().play();

                                            // Spawn regular enemies
                                            setTimeout(spawnEnemy, 2000);
                                            setTimeout(spawnEnemy, 4000);
                                        }
                                    } else {
                                        // Regular enemy handling
                                        // Create explosion at enemy position
                                        createExplosion(enemy.x, enemy.y);

                                        // Remove enemy
                                        enemies.splice(j, 1);

                                        // Increase score
                                        increaseScore(50 * scoreMultiplier);

                                        // Play hit sound
                                        hitSound.cloneNode().play();

                                        // Spawn a new enemy
                                        setTimeout(spawnEnemy, 2000);
                                    }
                                }
                            }
                        }
                    }
                }

                // Update ice projectiles
                for (let i = iceProjectiles.length - 1; i >= 0; i--) {
                    let ice = iceProjectiles[i];

                    // Move ice projectile
                    ice.x += ice.velocityX;
                    ice.y += ice.velocityY;

                    // Rotate ice projectile
                    ice.rotation += 0.1;

                    // Check if ice is off screen
                    if (ice.x < -50 || ice.x > canvas.width + 50 || 
                        ice.y < -50 || ice.y > canvas.height + 50) {
                        iceProjectiles.splice(i, 1);
                        continue;
                    }

                    // Check for collision with player
                    if (!playerFrozen && 
                        player.x + player.width > ice.x && 
                        player.x < ice.x + ice.width && 
                        player.y + player.height > ice.y && 
                        player.y < ice.y + ice.height) {

                        // Freeze player
                        playerFrozen = true;
                        freezeTimer = freezeDuration;
                        freezeSound.cloneNode().play();

                        // Remove ice projectile
                        iceProjectiles.splice(i, 1);
                    }
                }

                // Update enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    let enemy = enemies[i];

                    // Special boss behavior
                    if (enemy.isBoss) {
                        // Manage boss AI state
                        if (enemy.isEntering) {
                            // Boss is still entering - handled by entry code below
                        } else {
                            // Decrement cooldowns
                            if (enemy.jumpCooldown > 0) enemy.jumpCooldown--;

                            // Update movement timer and handle state transitions
                            enemy.movementTimer++;
                            if (enemy.movementTimer >= enemy.movementDuration) {
                                // Change state periodically
                                enemy.movementTimer = 0;

                                // Decide next state based on player position and current state
                                const distToPlayer = Math.abs((player.x + player.width/2) - (enemy.x + enemy.width/2));

                                if (distToPlayer < 300) {
                                    // Close to player - attack
                                    enemy.aiState = 'attack';
                                } else if (Math.random() < 0.7) {
                                    // Mostly patrol
                                    enemy.aiState = 'patrol';
                                } else {
                                    // Sometimes approach player
                                    enemy.aiState = 'approach';
                                }
                            }

                            // Execute behavior based on current state
                            switch (enemy.aiState) {
                                case 'patrol':
                                    // Just move back and forth on platform
                                    // Direction changes handled by platform edge detection
                                    break;

                                case 'approach':
                                    // Move toward player
                                    if (player.x + player.width/2 < enemy.x + enemy.width/2) {
                                        enemy.velocityX = -3;
                                    } else {
                                        enemy.velocityX = 3;
                                    }

                                    // Jump to player's platform if needed and cooldown allows
                                    if (enemy.jumpCooldown === 0) {
                                        // Find player's platform
                                        let playerPlatform = null;
                                        for (let platform of platforms) {
                                            if (player.y + player.height >= platform.y && 
                                                player.y + player.height <= platform.y + 10 &&
                                                player.x + player.width > platform.x && 
                                                player.x < platform.x + platform.width) {
                                                playerPlatform = platform;
                                                break;
                                            }
                                        }

                                        // If player is on a different platform and it's reasonably close
                                        if (playerPlatform && playerPlatform !== enemy.currentPlatform) {
                                            const horizontalDist = Math.abs((playerPlatform.x + playerPlatform.width/2) - 
                                                                          (enemy.x + enemy.width/2));
                                            const verticalDist = Math.abs(playerPlatform.y - enemy.currentPlatform.y);

                                            // Only jump if platform is not too far
                                            if (horizontalDist < 400 && verticalDist < 200) {
                                                // Calculate jump strength based on height difference
                                                const jumpStrength = 12 + (verticalDist / 10);
                                                enemy.velocityY = -jumpStrength;
                                                enemy.isJumping = true;
                                                enemy.jumpCooldown = 90; // 1.5 second cooldown
                                            }
                                        }
                                    }
                                    break;

                                case 'attack':
                                    // Throw ice more frequently in attack mode
                                    if (Math.random() < 0.05) {
                                        throwIceProjectile(enemy);
                                    }

                                    // Move toward player more aggressively
                                    if (player.x + player.width/2 < enemy.x + enemy.width/2) {
                                        enemy.velocityX = -4;
                                    } else {
                                        enemy.velocityX = 4;
                                    }
                                    break;
                            }

                            // Always throw ice projectiles occasionally
                            if (Math.random() < 0.02) {
                                throwIceProjectile(enemy);
                            }
                        }
                    }

                    // Move enemy
                    enemy.x += enemy.velocityX;

                    // Handle entry animation and physics
                    if (enemy.isEntering) {
                        // Apply gravity during jump
                        enemy.velocityY += enemy.gravity;

                        // Store previous position for collision detection
                        const prevY = enemy.y;
                        const prevX = enemy.x;

                        // Update position
                        enemy.y += enemy.velocityY;
                        enemy.x += enemy.velocityX;

                        // Special handling for boss entry
                        if (enemy.isBoss) {
                            // Check if boss is above the target platform
                            const isAbovePlatform = enemy.x + enemy.width > enemy.targetPlatform.x && 
                                                   enemy.x < enemy.targetPlatform.x + enemy.targetPlatform.width;

                            if (isAbovePlatform) {
                                // Ensure boss lands perfectly on the platform when directly above it
                                if (enemy.y + enemy.height >= enemy.targetPlatform.y - 5 && 
                                    enemy.y + enemy.height <= enemy.targetPlatform.y + 10) {
                                    // Snap to platform surface
                                    enemy.y = enemy.targetPlatform.y - enemy.height;
                                    enemy.velocityY = 0;
                                    enemy.isEntering = false;
                                    enemy.velocityX = -3; // Start moving left
                                    enemy.currentPlatform = enemy.targetPlatform;
                                    enemy.aiState = 'patrol';
                                } else if (enemy.y + enemy.height < enemy.targetPlatform.y - 5) {
                                    // Still approaching from above, carefully guide to platform
                                    // Calculate how many frames until we reach the platform horizontally
                                    const timeToReachX = Math.abs((enemy.targetPlatform.x + enemy.targetPlatform.width/2 - enemy.width/2 - enemy.x) / enemy.velocityX);

                                    // Calculate ideal Y velocity to land perfectly
                                    const targetY = enemy.targetPlatform.y - enemy.height;
                                    const distanceY = targetY - enemy.y;
                                    const idealVelocityY = distanceY / timeToReachX;

                                    // Apply a weighted adjustment to current velocity (stronger than before)
                                    enemy.velocityY = enemy.velocityY * 0.7 + idealVelocityY * 0.3;
                                }
                            } else {
                                // Not yet above platform, maintain horizontal movement
                                // Adjust trajectory to aim for platform center
                                const platformCenterX = enemy.targetPlatform.x + enemy.targetPlatform.width/2 - enemy.width/2;
                                const distToCenter = platformCenterX - enemy.x;

                                // Slow down if getting close to ensure we don't overshoot
                                if (Math.abs(distToCenter) < 100) {
                                    enemy.velocityX = Math.sign(enemy.velocityX) * Math.min(Math.abs(enemy.velocityX), 2);
                                }

                                // Adjust vertical position to line up with platform
                                const idealY = enemy.targetPlatform.y - enemy.height - 100; // Aim to be 100px above platform
                                const yDiff = idealY - enemy.y;

                                // Apply gentle vertical adjustment
                                enemy.velocityY = enemy.velocityY * 0.9 + (yDiff * 0.02);
                            }

                            // Safety check - if somehow boss gets below all platforms or off screen
                            if (enemy.y > canvas.height - 200 || enemy.y < -100 || 
                                enemy.x < -100 || enemy.x > canvas.width + 100) {
                                // Emergency teleport to above the target platform
                                enemy.y = enemy.targetPlatform.y - enemy.height - 50;
                                enemy.x = Math.max(50, Math.min(canvas.width - enemy.width - 50, enemy.x));
                                enemy.velocityY = 0;
                                enemy.velocityX = enemy.velocityX > 0 ? -2 : 2; // Reverse direction
                            }
                        } else {
                            // Regular enemy handling
                            // Check if landed on target platform
                            if (enemy.velocityY > 0 && 
                                prevY + enemy.height <= enemy.targetPlatform.y &&
                                enemy.y + enemy.height >= enemy.targetPlatform.y && 
                                enemy.x + enemy.width > enemy.targetPlatform.x && 
                                enemy.x < enemy.targetPlatform.x + enemy.targetPlatform.width) {

                                // Landed on platform
                                enemy.y = enemy.targetPlatform.y - enemy.height;
                                enemy.velocityY = 0;
                                enemy.isEntering = false;
                                enemy.velocityX = enemy.velocityX > 0 ? enemySpeed : -enemySpeed;
                            }

                            // Check if landed on any other platform
                            for (let platform of platforms) {
                                if (platform !== enemy.targetPlatform && 
                                    enemy.velocityY > 0 && 
                                    prevY + enemy.height <= platform.y &&
                                    enemy.y + enemy.height >= platform.y && 
                                    enemy.x + enemy.width > platform.x && 
                                    enemy.x < platform.x + platform.width) {

                                    // Landed on a different platform
                                    enemy.y = platform.y - enemy.height;
                                    enemy.velocityY = 0;
                                    enemy.isEntering = false;
                                    enemy.velocityX = enemy.velocityX > 0 ? enemySpeed : -enemySpeed;
                                    break;
                                }
                            }

                            // If missed platform or went off-screen, remove and spawn new
                            if (enemy.y > canvas.height || 
                                (enemy.velocityX > 0 && enemy.x > canvas.width + 100) || 
                                (enemy.velocityX < 0 && enemy.x < -100)) {
                                enemies.splice(i, 1);
                                setTimeout(spawnEnemy, 1000);
                                continue;
                            }
                        }
                    } else {
                        // Apply gravity
                        enemy.velocityY += gravity;

                        // Store previous position for collision detection
                        const prevY = enemy.y;
                        const prevX = enemy.x;

                        // First move horizontally
                        enemy.x += enemy.velocityX;

                        // Then check vertical movement
                        enemy.y += enemy.velocityY;

                        // Handle platform collisions
                        let onPlatform = false;
                        let onPlatformEdge = true;
                        let currentPlatform = null;

                        for (let platform of platforms) {
                            // Check if enemy is on or falling onto this platform
                            if (prevY + enemy.height <= platform.y && 
                                enemy.y + enemy.height >= platform.y &&
                                enemy.x + enemy.width > platform.x && 
                                enemy.x < platform.x + platform.width) {

                                // Land on platform
                                enemy.y = platform.y - enemy.height;
                                enemy.velocityY = 0;
                                onPlatform = true;
                                currentPlatform = platform;

                                // For boss, update current platform
                                if (enemy.isBoss) {
                                    enemy.currentPlatform = platform;
                                    enemy.isJumping = false;
                                }

                                // Check if enemy is not at the edge
                                const leftEdge = platform.x + 5; // 5px buffer
                                const rightEdge = platform.x + platform.width - 5; // 5px buffer

                                if (enemy.velocityX < 0 && enemy.x > leftEdge || 
                                    enemy.velocityX > 0 && enemy.x + enemy.width < rightEdge) {
                                    onPlatformEdge = false;
                                }

                                break; // Found a platform to stand on, no need to check others
                            }
                        }

                        // Check for side collisions with platforms
                        for (let platform of platforms) {
                            if (enemy.y + enemy.height > platform.y + 5 && 
                                enemy.y < platform.y + platform.height - 5) {

                                // Hitting platform from the side
                                if (prevX + enemy.width <= platform.x && enemy.x + enemy.width > platform.x) {
                                    // Hitting from left
                                    enemy.x = platform.x - enemy.width;
                                    enemy.velocityX *= -1;
                                }
                                else if (prevX >= platform.x + platform.width && enemy.x < platform.x + platform.width) {
                                    // Hitting from right
                                    enemy.x = platform.x + platform.width;
                                    enemy.velocityX *= -1;
                                }
                            }
                        }

                        // If not on any platform and not falling, start falling
                        if (!onPlatform && enemy.velocityY === 0) {
                            enemy.velocityY = 0.1; // Start falling gently
                        }

                        // Change direction if at platform edge or wall
                        if (onPlatformEdge || enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) {
                            enemy.velocityX *= -1;

                            // Move slightly away from the edge to prevent falling
                            if (enemy.x <= 0) {
                                enemy.x = 1;
                            } else if (enemy.x + enemy.width >= canvas.width) {
                                enemy.x = canvas.width - enemy.width - 1;
                            }
                        }

                        // Additional check for boss to ensure it stays on screen
                        if (enemy.isBoss) {
                            // Ensure boss stays within screen boundaries
                            if (enemy.x < 0) {
                                enemy.x = 0;
                                enemy.velocityX = Math.abs(enemy.velocityX); // Force move right
                            } else if (enemy.x + enemy.width > canvas.width) {
                                enemy.x = canvas.width - enemy.width;
                                enemy.velocityX = -Math.abs(enemy.velocityX); // Force move left
                            }

                            // Ensure boss stays on its platform or a valid platform
                            if (!onPlatform && enemy.velocityY > 5) {
                                // Boss is falling too fast, find nearest platform
                                let nearestPlatform = null;
                                let minDistance = Infinity;

                                for (let platform of platforms) {
                                    if (enemy.x + enemy.width > platform.x && 
                                        enemy.x < platform.x + platform.width) {
                                        const distance = Math.abs(platform.y - (enemy.y + enemy.height));
                                        if (distance < minDistance) {
                                            minDistance = distance;
                                            nearestPlatform = platform;
                                        }
                                    }
                                }

                                // Teleport to nearest platform if falling off screen
                                if (nearestPlatform && enemy.y > canvas.height - 200) {
                                    enemy.y = nearestPlatform.y - enemy.height;
                                    enemy.velocityY = 0;
                                    enemy.currentPlatform = nearestPlatform;
                                }
                            }
                        }
                    }

                    // Check for collision with player - only if not invincible
                    if (!player.invincible && 
                        player.x + player.width > enemy.x && 
                        player.x < enemy.x + enemy.width && 
                        player.y + player.height > enemy.y && 
                        player.y < enemy.y + enemy.height) {

                        health--;
                        updateUI();
                        hurtSound.cloneNode().play();

                        // Push player away from enemy
                        if (player.x < enemy.x) {
                            player.velocityX = -10;
                        } else {
                            player.velocityX = 10;
                        }
                        player.velocityY = -5;
                        
                        // Make player temporarily invincible
                        player.invincible = true;
                        player.invincibleTimer = 90; // 1.5 seconds at 60 FPS
                        
                        // Visual feedback for invincibility
                        player.flashTimer = 0;
                        player.isFlashing = true;

                        if (health <= 0) {
                            gameOver();
                        }
                    }
                }

                // Spawn new enemy if there are none
                if (enemies.length === 0) {
                    spawnEnemy();
                }

                // Check for bamboo collection
                for (let i = bamboos.length - 1; i >= 0; i--) {
                    if (player.x + player.width > bamboos[i].x && 
                        player.x < bamboos[i].x + bamboos[i].width && 
                        player.y + player.height > bamboos[i].y && 
                        player.y < bamboos[i].y + bamboos[i].height) {

                        // Collect bamboo
                        hunger = Math.min(100, hunger + bamboos[i].nutritionValue);
                        increaseScore(20 * scoreMultiplier);
                        eatSound.cloneNode().play();
                        bamboos.splice(i, 1);
                    }
                }
            }

            function render() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw background
                ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);

                // If boss fight, add dark overlay
                if (isBossFight) {
                    ctx.fillStyle = 'rgba(0, 0, 100, 0.2)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                // Draw platforms
                for (let platform of platforms) {
                    // Draw platform with repetition
                    let segments = Math.ceil(platform.width / 128);
                    for (let i = 0; i < segments; i++) {
                        let segmentWidth = Math.min(128, platform.width - i * 128);
                        ctx.drawImage(platformImg, 0, 0, segmentWidth, 32, platform.x + i * 128, platform.y, segmentWidth, 32);
                    }
                }

                // Draw player - choose frozen or normal sprite
                const playerImage = playerFrozen ? koalaFrozenImg : koalaImg;
                
                // Handle invincibility flashing effect
                let shouldDrawPlayer = true;
                if (player.invincible) {
                    player.flashTimer++;
                    if (player.flashTimer % 6 < 3) { // Flash every few frames
                        shouldDrawPlayer = false;
                    }
                }
                
                if (shouldDrawPlayer) {
                    if (player.facingRight) {
                        ctx.save();
                        ctx.scale(-1, 1);
                        ctx.drawImage(playerImage, -player.x - player.width, player.y, player.width, player.height);
                        ctx.restore();
                    } else {
                        ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
                    }
                }

                // If player is frozen, draw ice effect
                if (playerFrozen) {
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = 'rgba(150, 217, 250, 0.3)';
                    ctx.fillRect(player.x, player.y, player.width, player.height);

                    // Draw ice crystals
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    for (let i = 0; i < 10; i++) {
                        const x = player.x + Math.random() * player.width;
                        const y = player.y + Math.random() * player.height;
                        const size = 2 + Math.random() * 4;
                        ctx.fillRect(x, y, size, size);
                    }
                    ctx.restore();
                }

                // Draw boomerang
                if (boomerang !== null) {
                    ctx.save();
                    ctx.translate(boomerang.x + boomerang.width / 2, boomerang.y + boomerang.height / 2);
                    ctx.rotate(boomerang.rotation);
                    ctx.drawImage(boomerangImg, -boomerang.width / 2, -boomerang.height / 2, boomerang.width, boomerang.height);
                    ctx.restore();
                }

                // Draw enemies
                for (let enemy of enemies) {
                    if (enemy.isBoss) {
                        // Draw boss with appropriate facing
                        if (enemy.velocityX > 0) {
                            ctx.drawImage(superKangarooImg, enemy.x, enemy.y, enemy.width, enemy.height);
                        } else {
                            ctx.save();
                            ctx.scale(-1, 1);
                            ctx.drawImage(superKangarooImg, -enemy.x - enemy.width, enemy.y, enemy.width, enemy.height);
                            ctx.restore();
                        }

                        // Draw boss health bar
                        const healthBarWidth = enemy.width;
                        const healthBarHeight = 10;
                        const healthPercentage = enemy.health / enemy.maxHealth;

                        // Background of health bar
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(enemy.x, enemy.y - 20, healthBarWidth, healthBarHeight);

                        // Health bar color based on remaining health
                        if (healthPercentage > 0.6) {
                            ctx.fillStyle = 'lime';
                        } else if (healthPercentage > 0.3) {
                            ctx.fillStyle = 'yellow';
                        } else {
                            ctx.fillStyle = 'red';
                        }

                        // Health bar
                        ctx.fillRect(enemy.x, enemy.y - 20, healthBarWidth * healthPercentage, healthBarHeight);

                        // Ice aura effect for boss
                        ctx.save();
                        ctx.globalAlpha = 0.3;
                        ctx.fillStyle = 'rgba(150, 217, 250, 0.5)';

                        // Draw aura
                        ctx.beginPath();
                        ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 
                                enemy.width/1.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    } else {
                        // Regular enemies
                        if (enemy.velocityX > 0) {
                            ctx.drawImage(kangarooImg, enemy.x, enemy.y, enemy.width, enemy.height);
                        } else {
                            ctx.save();
                            ctx.scale(-1, 1);
                            ctx.drawImage(kangarooImg, -enemy.x - enemy.width, enemy.y, enemy.width, enemy.height);
                            ctx.restore();
                        }
                    }
                }

                // Draw ice projectiles
                for (let ice of iceProjectiles) {
                    ctx.save();
                    ctx.translate(ice.x + ice.width/2, ice.y + ice.height/2);
                    ctx.rotate(ice.rotation);
                    ctx.drawImage(iceProjectileImg, -ice.width/2, -ice.height/2, ice.width, ice.height);
                    ctx.restore();

                    // Draw ice trail effect
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    for (let i = 0; i < 3; i++) {
                        const trailX = ice.x - ice.velocityX * (i * 0.5);
                        const trailY = ice.y - ice.velocityY * (i * 0.5);
                        const trailSize = ice.width * (1 - i * 0.2);

                        ctx.globalAlpha = 0.3 - (i * 0.1);
                        ctx.translate(trailX + trailSize/2, trailY + trailSize/2);
                        ctx.rotate(ice.rotation - (i * 0.2));
                        ctx.drawImage(iceProjectileImg, -trailSize/2, -trailSize/2, trailSize, trailSize);
                        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
                    }
                    ctx.restore();
                }

                // Draw explosions
                for (let explosion of explosions) {
                    explosion.draw(ctx);
                }

                // Draw bamboo with glow effect
                for (let bamboo of bamboos) {
                    // Update glow animation
                    bamboo.glowSize += 0.05 * bamboo.glowDirection;
                    if (bamboo.glowSize >= 1.5) bamboo.glowDirection = -1;
                    if (bamboo.glowSize <= 0) bamboo.glowDirection = 1;

                    // Draw glow effect
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    const glowSize = bamboo.width * (1 + bamboo.glowSize * 0.3);
                    const glowX = bamboo.x - (glowSize - bamboo.width) / 2;
                    const glowY = bamboo.y - (glowSize - bamboo.height) / 2;

                    // Create glow gradient
                    const gradient = ctx.createRadialGradient(
                        bamboo.x + bamboo.width/2, bamboo.y + bamboo.height/2, bamboo.width/4,
                        bamboo.x + bamboo.width/2, bamboo.y + bamboo.height/2, bamboo.width
                    );
                    gradient.addColorStop(0, 'rgba(144, 238, 144, 0.8)');
                    gradient.addColorStop(1, 'rgba(144, 238, 144, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(bamboo.x + bamboo.width/2, bamboo.y + bamboo.height/2, glowSize/1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    ctx.restore();

                    // Draw bamboo image
                    ctx.drawImage(bambooImg, bamboo.x, bamboo.y, bamboo.width, bamboo.height);
                }

                // Draw hunger bar
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(player.x, player.y - 15, player.width, 5);

                // Color changes based on hunger level
                if (hunger > 60) {
                    ctx.fillStyle = 'green';
                } else if (hunger > 30) {
                    ctx.fillStyle = 'yellow';
                } else {
                    ctx.fillStyle = 'red';
                }

                ctx.fillRect(player.x, player.y - 15, player.width * (hunger / 100), 5);
            }

            function throwBoomerang() {
                const direction = player.facingRight ? 1 : -1;
                boomerang = {
                    x: player.facingRight ? player.x + player.width : player.x,
                    y: player.y + player.height / 2 - 16,
                    width: 32,
                    height: 32,
                    velocityX: direction * boomerangSpeed,
                    rotation: 0,
                    returning: false,
                    initialDirection: direction,
                    maxDistance: player.facingRight ? 
                        Math.min(player.x + 300, canvas.width) : 
                        Math.max(player.x - 300, 0)
                };
            }

            function createExplosion(x, y) {
                // Create a new explosion at the given position
                const explosion = {
                    x: x,
                    y: y,
                    width: 64,
                    height: 64,
                    frameWidth: 64, // Width of each frame in the sprite sheet
                    frameHeight: 64, // Height of each frame
                    currentFrame: 0,
                    totalFrames: 6, // Total number of frames in the explosion animation
                    frameDelay: 4, // Frames to wait before showing next sprite
                    frameCounter: 0,
                    finished: false,

                    update: function() {
                        this.frameCounter++;
                        if (this.frameCounter >= this.frameDelay) {
                            this.frameCounter = 0;
                            this.currentFrame++;
                            if (this.currentFrame >= this.totalFrames) {
                                this.finished = true;
                            }
                        }
                    },

                    draw: function(ctx) {
                        if (!this.finished) {
                            // Draw the current frame from the sprite sheet
                            ctx.drawImage(
                                explosionImg,
                                this.currentFrame * this.frameWidth, 0, // Source x, y
                                this.frameWidth, this.frameHeight, // Source width, height
                                this.x, this.y, // Destination x, y
                                this.width, this.height // Destination width, height
                            );
                        }
                    }
                };

                explosions.push(explosion);
                explosionSound.cloneNode().play();
            }

            function spawnBamboo() {
                // Find a random platform to place bamboo on
                const platformIndex = Math.floor(Math.random() * platforms.length);
                const platform = platforms[platformIndex];

                // Place bamboo at a random position on the platform
                const bambooX = platform.x + Math.random() * (platform.width - 48);
                const bambooY = platform.y - 48; // Place on top of platform

                const bamboo = {
                    x: bambooX,
                    y: bambooY - 10, // Position it a bit higher to account for bigger size
                    width: 48,
                    height: 48,
                    nutritionValue: 20 + Math.floor(Math.random() * 20), // 20-40 hunger points
                    glowSize: 0, // For glow animation
                    glowDirection: 1 // Direction of glow animation (growing or shrinking)
                };

                bamboos.push(bamboo);
            }

            function startBossFight() {
                // Only spawn boss if not already in boss fight
                if (!isBossFight) {
                    isBossFight = true;
                    bossSpawned = true;

                    // Clear regular enemies
                    enemies = [];

                    // Display boss warning
                    const bossWarning = document.createElement('div');
                    bossWarning.textContent = "‚ö†Ô∏è SUPER KANGAROO BOSS INCOMING! ‚ö†Ô∏è";
                    bossWarning.style.position = 'absolute';
                    bossWarning.style.top = '100px';
                    bossWarning.style.left = '50%';
                    bossWarning.style.transform = 'translateX(-50%)';
                    bossWarning.style.color = 'red';
                    bossWarning.style.fontSize = '36px';
                    bossWarning.style.fontWeight = 'bold';
                    bossWarning.style.textShadow = '2px 2px 4px black';
                    bossWarning.style.zIndex = '100';
                    bossWarning.style.fontFamily = "'Comic Sans MS', cursive, sans-serif";
                    document.getElementById('game-container').appendChild(bossWarning);

                    // Play boss appear sound
                    bossAppearSound.cloneNode().play();

                    // Remove warning after 3 seconds
                    setTimeout(() => {
                        bossWarning.remove();
                        spawnBoss();
                    }, 3000);
                }
            }

            function spawnBoss() {
                // Find the largest platform to spawn boss on
                let largestPlatform = platforms[0];
                for (let platform of platforms) {
                    if (platform.width > largestPlatform.width) {
                        largestPlatform = platform;
                    }
                }

                // Calculate a good entry position above and to the right of the platform
                const entryY = Math.min(largestPlatform.y - 200, 100); // Higher position for more controlled descent

                // Create boss enemy
                const boss = {
                    x: canvas.width + 100, // Start off-screen
                    y: entryY, // Position well above platform for a controlled descent
                    width: 128,
                    height: 128,
                    velocityX: -2, // Move left initially, slower for better control
                    velocityY: 0,
                    targetPlatform: largestPlatform,
                    isEntering: true,
                    gravity: 0.1, // Even lower gravity for boss for better control
                    isBoss: true,
                    health: 10, // Boss has more health
                    maxHealth: 10,
                    isJumping: false,
                    lastIceThrow: 0,
                    iceThrowCooldown: 1500, // ms
                    movementTimer: 0,
                    movementDuration: 120, // 2 seconds at 60FPS
                    currentPlatform: largestPlatform,
                    jumpCooldown: 0,
                    aiState: 'approach', // approach, patrol, attack
                    entryPhase: 'approach', // Tracking the phase of entry: approach, descend, land
                    stuckCounter: 0 // Counter to detect if boss gets stuck
                };

                enemies.push(boss);

                // Add a safety timeout to ensure boss doesn't get stuck in entering state
                setTimeout(() => {
                    // Find the boss in the enemies array
                    const bossIndex = enemies.findIndex(e => e.isBoss && e.isEntering);
                    if (bossIndex !== -1) {
                        // Force boss to land if still in entering state after 10 seconds
                        enemies[bossIndex].isEntering = false;
                        enemies[bossIndex].y = enemies[bossIndex].targetPlatform.y - enemies[bossIndex].height;
                        enemies[bossIndex].velocityY = 0;
                        enemies[bossIndex].velocityX = -3;
                        enemies[bossIndex].currentPlatform = enemies[bossIndex].targetPlatform;
                        enemies[bossIndex].aiState = 'patrol';
                    }
                }, 10000);
            }

            function throwIceProjectile(boss) {
                // Only throw if cooldown has passed
                const now = Date.now();
                if (now - boss.lastIceThrow < boss.iceThrowCooldown) return;

                boss.lastIceThrow = now;

                // Calculate direction to player
                const dx = (player.x + player.width / 2) - (boss.x + boss.width / 2);
                const dy = (player.y + player.height / 2) - (boss.y + boss.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Create ice projectile
                const ice = {
                    x: boss.x + boss.width / 2 - 16, // Center of boss
                    y: boss.y + boss.height / 3, // Upper part of boss
                    width: 32,
                    height: 32,
                    velocityX: (dx / distance) * 6, // Speed in direction of player
                    velocityY: (dy / distance) * 6,
                    rotation: 0
                };

                iceProjectiles.push(ice);
                iceThrowSound.cloneNode().play();
            }

            function spawnEnemy() {
                // Don't spawn regular enemies during boss fight
                if (isBossFight) return;

                // Decide which side to spawn from
                const spawnFromRight = Math.random() > 0.5;

                // Pick a random platform to target
                const platformIndex = Math.floor(Math.random() * platforms.length);
                const platform = platforms[platformIndex];

                // Make sure we pick a platform with enough room
                let safeEntryPlatform = platform;
                if (platform.width < 150) { // Increase minimum width requirement
                    // Find a wider platform as fallback
                    for (let p of platforms) {
                        if (p.width >= 150) {
                            safeEntryPlatform = p;
                            break;
                        }
                    }
                }

                // Calculate a safe landing position (not too close to the edge)
                const buffer = 30; // Buffer from platform edge
                const safeX = spawnFromRight ? 
                    safeEntryPlatform.x + buffer : 
                    safeEntryPlatform.x + safeEntryPlatform.width - 64 - buffer;

                // Calculate jump arc to land properly
                const horizontalDistance = spawnFromRight ? 
                    canvas.width - safeX + 64 : 
                    safeX + 64;

                // Adjust initial velocity based on distance
                const initialVelX = (spawnFromRight ? -1 : 1) * Math.min(enemySpeed * 1.5, horizontalDistance / 60);

                const enemy = {
                    x: spawnFromRight ? canvas.width : -64, // Start off-screen
                    y: safeEntryPlatform.y - 150, // Start higher to create jumping arc
                    width: 64,
                    height: 64,
                    velocityX: initialVelX,
                    velocityY: -5, // Initial upward velocity for jump arc
                    targetPlatform: safeEntryPlatform,
                    targetX: safeX, // Target landing X position (center of platform)
                    isEntering: true, // Flag to track entry animation
                    gravity: 0.3, // Slightly less gravity than player for smoother arc
                    lastX: spawnFromRight ? canvas.width : -64, // Track previous X position
                    lastY: safeEntryPlatform.y - 150 // Track previous Y position
                };

                enemies.push(enemy);
            }

            function updateUI() {
                scoreElement.textContent = `SCORE: ${Math.floor(score)}`;
                healthElement.textContent = `Health: ${health}`;
                hungerElement.textContent = `Hunger: ${Math.floor(hunger)}%`;
            }

            function increaseScore(amount) {
                const oldScore = score;
                score += amount;
                updateUI();

                // Animate score element
                scoreElement.classList.remove('score-animation');
                void scoreElement.offsetWidth; // Trigger reflow to restart animation
                scoreElement.classList.add('score-animation');

                // Display floating score text
                const floatingScore = document.createElement('div');
                floatingScore.textContent = `+${Math.floor(amount)}`;
                floatingScore.style.position = 'absolute';
                floatingScore.style.color = '#ffcc00';
                floatingScore.style.fontFamily = "'Comic Sans MS', cursive, sans-serif";
                floatingScore.style.fontSize = '24px';
                floatingScore.style.fontWeight = 'bold';
                floatingScore.style.textShadow = '2px 2px 3px rgba(0,0,0,0.7)';
                floatingScore.style.zIndex = '100';

                // Random position near the score display
                floatingScore.style.top = `${Math.random() * 30 + 70}px`;
                floatingScore.style.left = `${Math.random() * 100 + canvas.width/2 - 50}px`;

                document.getElementById('game-container').appendChild(floatingScore);

                // Animate and remove
                floatingScore.animate([
                    { transform: 'translateY(0)', opacity: 1 },
                    { transform: 'translateY(-50px)', opacity: 0 }
                ], {
                    duration: 1000,
                    easing: 'ease-out'
                }).onfinish = () => floatingScore.remove();
            }

            function gameOver() {
                gameRunning = false;
                pauseAllMusic();

                finalScoreElement.textContent = `Score: ${score}`;
                gameOverScreen.style.display = 'flex';
            }

            // Music control functions
            function setupMusicControls() {
                const musicTitle = document.getElementById('music-title');
                const playPauseBtn = document.getElementById('play-pause');
                const prevTrackBtn = document.getElementById('prev-track');
                const nextTrackBtn = document.getElementById('next-track');

                // Play/Pause button
                playPauseBtn.addEventListener('click', () => {
                    if (isMusicPlaying) {
                        pauseCurrentMusic();
                        playPauseBtn.textContent = '‚ñ∂Ô∏è';
                        musicTitle.textContent = 'Music: Off';
                        isMusicPlaying = false;
                    } else {
                        playCurrentMusic();
                        playPauseBtn.textContent = '‚è∏Ô∏è';
                        updateMusicTitle();
                        isMusicPlaying = true;
                    }
                });

                // Previous track button
                prevTrackBtn.addEventListener('click', () => {
                    pauseCurrentMusic();
                    currentMusicIndex = (currentMusicIndex - 1 + musicTracks.length) % musicTracks.length;
                    currentMusic = musicTracks[currentMusicIndex].audio;

                    if (isMusicPlaying) {
                        playCurrentMusic();
                    }
                    updateMusicTitle();
                });

                // Next track button
                nextTrackBtn.addEventListener('click', () => {
                    pauseCurrentMusic();
                    currentMusicIndex = (currentMusicIndex + 1) % musicTracks.length;
                    currentMusic = musicTracks[currentMusicIndex].audio;

                    if (isMusicPlaying) {
                        playCurrentMusic();
                    }
                    updateMusicTitle();
                });
            }

            function updateMusicTitle() {
                const musicTitle = document.getElementById('music-title');
                if (isMusicPlaying) {
                    const track = musicTracks[currentMusicIndex];
                    musicTitle.textContent = `${track.icon} ${track.name}`;
                } else {
                    musicTitle.textContent = 'Music: Off';
                }
            }

            function playCurrentMusic() {
                currentMusic.play();
            }

            function pauseCurrentMusic() {
                currentMusic.pause();
                currentMusic.currentTime = 0;
            }

            function pauseAllMusic() {
                musicTracks.forEach(track => {
                    track.audio.pause();
                    track.audio.currentTime = 0;
                });
            }

            // Make sure canvas resizes with window
            function resizeCanvas() {
                const container = document.getElementById('game-container');
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;

                const scale = Math.min(containerWidth / 800, containerHeight / 500);

                canvas.style.width = `${800 * scale}px`;
                canvas.style.height = `${500 * scale}px`;
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Wait for assets to load
            let assetsLoaded = 0;
            const totalAssets = 10; // 11 images

            function checkAllAssetsLoaded() {
                assetsLoaded++;
                if (assetsLoaded === totalAssets) {
                    // All assets loaded, game is ready to start
                    startButton.disabled = false;
                }
            }

            koalaImg.onload = checkAllAssetsLoaded;
            koalaFrozenImg.onload = checkAllAssetsLoaded;
            kangarooImg.onload = checkAllAssetsLoaded;
            superKangarooImg.onload = checkAllAssetsLoaded;
            iceProjectileImg.onload = checkAllAssetsLoaded;
            boomerangImg.onload = checkAllAssetsLoaded;
            platformImg.onload = checkAllAssetsLoaded;
            backgroundImg.onload = checkAllAssetsLoaded;
            explosionImg.onload = checkAllAssetsLoaded;
            bambooImg.onload = checkAllAssetsLoaded;

            // Disable start button until assets are loaded
            startButton.disabled = true;

            // Setup music controls
            setupMusicControls();
        });
    </script>
</body>
</html>