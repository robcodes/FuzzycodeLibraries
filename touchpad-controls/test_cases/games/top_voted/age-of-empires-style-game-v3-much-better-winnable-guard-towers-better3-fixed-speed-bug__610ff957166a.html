<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Age of Empires Style Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background-color: #000;
        }

        #victory-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            color: white;
            text-align: center;
        }

        #victory-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: gold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
        }

        #victory-screen p {
            font-size: 24px;
            margin-bottom: 30px;
        }

        #restart-game-button {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 20px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #restart-game-button:hover {
            background-color: #45a049;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #game-canvas {
            position: absolute;
            cursor: default;
        }

        .selection-box {
            position: absolute;
            border: 1px dashed #ffffff;
            background-color: rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }

        #hud {
            position: fixed;
            bottom: 10px;
            left: 0;
            width: 100%;
            height: 120px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #ffffff;
            display: flex;
            z-index: 100;
        }

        #resources {
            display: flex;
            align-items: center;
            padding: 10px;
            gap: 20px;
        }

        .resource-display {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .resource-icon {
            width: 20px;
            height: 20px;
            background-size: contain;
            background-repeat: no-repeat;
        }

        .food-icon {
            background-image: url('https://images.fuzzycode.dev/fast_ai?search=food%20icon%20game%20resource&resize=20x20&transparency=true');
        }

        .wood-icon {
            background-image: url('https://images.fuzzycode.dev/fast_ai?search=wood%20icon%20game%20resource&resize=20x20&transparency=true');
        }

        .gold-icon {
            background-image: url('https://images.fuzzycode.dev/fast_ai?search=gold%20icon%20game%20resource&resize=20x20&transparency=true');
        }

        .stone-icon {
            background-image: url('https://images.fuzzycode.dev/fast_ai?search=stone%20icon%20game%20resource&resize=20x20&transparency=true');
        }

        #actions {
            flex-grow: 1;
            display: flex;
            flex-wrap: wrap;
            padding: 10px;
            gap: 5px;
        }

        .action-button {
            width: 50px;
            height: 50px;
            background-color: #333;
            border: 1px solid #666;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #fff;
            background-size: 80%;
            background-position: center;
            background-repeat: no-repeat;
        }

        .action-button:hover {
            background-color: #444;
        }

        #minimap {
            width: 150px;
            height: 100px;
            margin: 10px;
            background-color: #225522;
            position: relative;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        #notifications {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 300px;
            z-index: 200;
        }

        .notification {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 5px;
            animation: fadeOut 3s forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        #build-menu, #train-menu {
            display: none;
            position: absolute;
            bottom: 130px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 150;
        }

        .menu-title {
            color: white;
            margin-bottom: 10px;
            text-align: center;
        }

        .menu-options {
            display: flex;
            gap: 10px;
        }

        .menu-option {
            width: 60px;
            height: 60px;
            background-color: #333;
            border: 1px solid #666;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 5px;
        }

        .menu-option-icon {
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .menu-option-label {
            font-size: 10px;
            color: white;
            text-align: center;
            margin-top: 2px;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #loading-progress {
            width: 300px;
            height: 20px;
            background-color: #333;
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
        }

        #progress-bar {
            height: 100%;
            width: 0%;
            background-color: #4CAF50;
            transition: width 0.3s;
        }

        #start-game-button {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
        }

        #start-game-button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h1>Age of Empires Style Game</h1>
        <p>Loading game assets...</p>
        <div id="loading-progress">
            <div id="progress-bar"></div>
        </div>
        <button id="start-game-button">Start Game</button>
    </div>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <div id="hud">
        <div id="resources">
            <div class="resource-display" id="food-display">
                <div class="resource-icon food-icon"></div>
                <span id="food-count">200</span>
            </div>
            <div class="resource-display" id="wood-display">
                <div class="resource-icon wood-icon"></div>
                <span id="wood-count">200</span>
            </div>
            <div class="resource-display" id="gold-display">
                <div class="resource-icon gold-icon"></div>
                <span id="gold-count">100</span>
            </div>
            <div class="resource-display" id="stone-display">
                <div class="resource-icon stone-icon"></div>
                <span id="stone-count">100</span>
            </div>
            <div>
                Population: <span id="population">0</span>/<span id="population-cap">5</span>
            </div>
        </div>
        <div id="actions"></div>
        <div id="minimap">
            <canvas id="minimap-canvas"></canvas>
        </div>
    </div>

    <div id="build-menu">            <div class="menu-title">Build</div>
        <div class="menu-options">
            <div class="menu-option" data-building="house" data-cost="wood:30" data-hotkey="z">
                <div class="menu-option-icon" style="background-image: url('https://images.fuzzycode.dev/fast_ai?search=medieval%20house%20top%20down%20game%20sprite&resize=40x40&transparency=true')"></div>
                <div class="menu-option-label">House (30W) (Z)</div>
            </div>
            <div class="menu-option" data-building="barracks" data-cost="wood:125" data-hotkey="x">
                <div class="menu-option-icon" style="background-image: url('https://images.fuzzycode.dev/fast_ai?search=medieval%20barracks%20top%20down%20game%20sprite&resize=40x40&transparency=true')"></div>
                <div class="menu-option-label">Barracks (125W) (X)</div>
            </div>
            <div class="menu-option" data-building="lumber-camp" data-cost="wood:70" data-hotkey="c">
                <div class="menu-option-icon" style="background-image: url('https://images.fuzzycode.dev/fast_ai?search=medieval%20lumber%20camp%20top%20down%20game%20sprite&resize=40x40&transparency=true')"></div>
                <div class="menu-option-label">Lumber Camp (70W) (C)</div>
            </div>
            <div class="menu-option" data-building="mining-camp" data-cost="wood:70" data-hotkey="v">
                <div class="menu-option-icon" style="background-image: url('https://images.fuzzycode.dev/fast_ai?search=medieval%20mining%20camp%20top%20down%20game%20sprite&resize=40x40&transparency=true')"></div>
                <div class="menu-option-label">Mining Camp (70W) (V)</div>
            </div>
            <div class="menu-option" data-building="mill" data-cost="wood:70" data-hotkey="b">
                <div class="menu-option-icon" style="background-image: url('https://images.fuzzycode.dev/fast_ai?search=medieval%20mill%20top%20down%20game%20sprite&resize=40x40&transparency=true')"></div>
                <div class="menu-option-label">Mill (70W) (B)</div>
            </div>
            <div class="menu-option" data-building="guard-tower" data-cost="wood:50,stone:100" data-hotkey="n">
                <div class="menu-option-icon" style="background-image: url('https://images.fuzzycode.dev/fast_ai?search=medieval%20guard%20tower%20top%20down%20game%20sprite&resize=40x40&transparency=true')"></div>
                <div class="menu-option-label">Guard Tower (50W, 100S) (N)</div>
            </div>
        </div>
    </div>

    <div id="train-menu">
        <div class="menu-title">Train</div>
        <div class="menu-options">
            <div class="menu-option" data-unit="villager" data-cost="food:50" data-hotkey="z">
                <div class="menu-option-icon" style="background-image: url('https://aws.fuzzycode.dev/image_buddy_365day_cache/uploads/1c159ab3-db18-4cfe-847d-0342d6f3038c/medieval villager top down game sprite!resize_40x40_0d7fc07708.png')"></div>
                <div class="menu-option-label">Villager (50F) (Z)</div>
            </div>
        </div>
    </div>

    <div id="notifications"></div>

    <div id="victory-screen">
        <h1>Victory!</h1>
        <p>Congratulations! You have defeated all enemies!</p>
        <button id="restart-game-button">Start New Game</button>
    </div>

    <script>
        // Game state
        const gameState = {
            resources: {
                food: 200,
                wood: 200,
                gold: 100,
                stone: 100
            },
            population: 0,
            populationCap: 5,
            selectedEntities: [],
            camera: { x: 0, y: 0 },
            dragStart: null,
            selectionBox: null,
            units: [],
            buildings: [],
            resourceNodes: [],
            enemies: [],
            buildingMode: false,
            buildingType: null,
            gameStarted: false,
            gameOver: false,
            minimapDragging: false,
            cameraLerpStart: null,
            cameraLerpTarget: null,
            edgeScrolling: true, // Enable edge scrolling by default
            edgeScrollMargin: 20, // Pixels from edge to trigger scrolling
            edgeScrollSpeed: 15, // Scroll speed when at edge
            villagerCapacity: 10, // Maximum resources a villager can carry
            idleVillagerIndex: 0, // To cycle through idle villagers
            idleMilitaryIndex: 0, // To cycle through idle military units
            projectiles: [], // Initialize projectiles array
            showGatherPoints: false, // Whether to show gather points
            buildingSounds: {
                complete: 'https://sounds.fuzzycode.dev/sound_effect?prompt=building%20complete%20notification&duration=1&ext=.mp3',
                start: 'https://sounds.fuzzycode.dev/sound_effect?prompt=start%20building%20construction&duration=1&ext=.mp3',
                dropoff: 'https://sounds.fuzzycode.dev/sound_effect?prompt=resources%20drop%20off%20sound&duration=0.5&ext=.mp3',
                construct: 'https://sounds.fuzzycode.dev/sound_effect?prompt=hammering%20wood%20construction&duration=0.5&ext=.mp3'
            },
            unitSounds: {
                select: 'https://sounds.fuzzycode.dev/sound_effect?prompt=unit%20selected%20click&duration=0.5&ext=.mp3',
                move: 'https://sounds.fuzzycode.dev/sound_effect?prompt=unit%20acknowledgement%20yes%20sir&duration=1&ext=.mp3',
                attack: 'https://sounds.fuzzycode.dev/sound_effect?prompt=soldier%20attack%20battle%20cry&duration=1&ext=.mp3',
                build: 'https://sounds.fuzzycode.dev/sound_effect?prompt=villager%20acknowledge%20building&duration=0.5&ext=.mp3',
                sword: 'https://sounds.fuzzycode.dev/sound_effect?prompt=sword%20slash%20attack%20hit&duration=0.5&ext=.mp3',
                buildingDamage: 'https://sounds.fuzzycode.dev/sound_effect?prompt=building%20being%20damaged%20crash&duration=1&ext=.mp3'
            },
            backgroundMusic: 'https://sounds.fuzzycode.dev/music?prompt=medieval%20strategy%20game%20background%20music&duration=30&ext=.mp3',
            sounds: {},
            images: {},
            mapSize: { width: 3000, height: 3000 },
            entityIdCounter: 0,
            lastFrameTime: 0,
            fps: 0,
            projectiles: []
        };

        // DOM elements
        const gameContainer = document.getElementById('game-container');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const actionsPanel = document.getElementById('actions');
        const buildMenu = document.getElementById('build-menu');
        const trainMenu = document.getElementById('train-menu');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const notificationsElement = document.getElementById('notifications');
        const loadingScreen = document.getElementById('loading-screen');
        const progressBar = document.getElementById('progress-bar');
        const startGameButton = document.getElementById('start-game-button');

        // Resource counters
        const foodCount = document.getElementById('food-count');
        const woodCount = document.getElementById('wood-count');
        const goldCount = document.getElementById('gold-count');
        const stoneCount = document.getElementById('stone-count');
        const populationElement = document.getElementById('population');
        const populationCapElement = document.getElementById('population-cap');

        // Set canvas size to match window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            minimapCanvas.width = 150;
            minimapCanvas.height = 100;
        }

        // Call initially and on window resize
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Image loading function with progress tracking
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => {
                    console.error('Failed to load image:', url);
                    // Create a fallback colored rectangle
                    const canvas = document.createElement('canvas');
                    canvas.width = 50;
                    canvas.height = 50;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#' + Math.floor(Math.random() * 16777215).toString(16);
                    ctx.fillRect(0, 0, 50, 50);
                    resolve(canvas);
                };
                img.src = url;
            });
        }

        // Preload all images
        async function preloadImages() {
            const imagesToLoad = {
                // Map and terrain
                'grass': 'https://aws.fuzzycode.dev/image_buddy_365day_cache/uploads/1c159ab3-db18-4cfe-847d-0342d6f3038c/medieval game grass texture top down!resize_200x200!resize_200x200!resize_200x200!resize_200x200!resize_200x200.png',

                // Resources
                'tree': 'https://images.fuzzycode.dev/fast_ai?search=oak%20tree%20top%20down%20game%20sprite&resize=50x50&transparency=true',
                'gold': 'https://images.fuzzycode.dev/fast_ai?search=gold%20mine%20top%20down%20game%20sprite&resize=50x50&transparency=true',
                'stone': 'https://images.fuzzycode.dev/fast_ai?search=stone%20quarry%20top%20down%20game%20sprite&resize=50x50&transparency=true',
                'berry': 'https://images.fuzzycode.dev/fast_ai?search=berry%20bush%20top%20down%20game%20sprite&resize=50x50&transparency=true',

                // Units
                'villager': 'https://aws.fuzzycode.dev/image_buddy_365day_cache/uploads/1c159ab3-db18-4cfe-847d-0342d6f3038c/medieval villager top down game sprite!resize_40x40_0d7fc07708.png',
                'soldier': 'https://images.fuzzycode.dev/fast_ai?search=medieval%20soldier%20top%20down%20game%20sprite&resize=40x40&transparency=true',
                'arrow': 'https://images.fuzzycode.dev/fast_ai?search=arrow%20projectile%20sprite&resize=20x10&transparency=true',

                // Buildings
                'town-center': 'https://images.fuzzycode.dev/fast_ai?search=medieval%20town%20center%20top%20down%20game%20sprite&resize=100x100&transparency=true',
                'barracks': 'https://images.fuzzycode.dev/fast_ai?search=medieval%20barracks%20top%20down%20game%20sprite&resize=80x80&transparency=true',
                'house': 'https://images.fuzzycode.dev/fast_ai?search=medieval%20house%20top%20down%20game%20sprite&resize=60x60&transparency=true',
                'lumber-camp': 'https://images.fuzzycode.dev/fast_ai?search=medieval%20lumber%20camp%20top%20down%20game%20sprite&resize=60x60&transparency=true',
                'mining-camp': 'https://images.fuzzycode.dev/fast_ai?search=medieval%20mining%20camp%20top%20down%20game%20sprite&resize=60x60&transparency=true',
                'mill': 'https://images.fuzzycode.dev/fast_ai?search=medieval%20mill%20top%20down%20game%20sprite&resize=60x60&transparency=true',
                'guard-tower': 'https://images.fuzzycode.dev/fast_ai?search=medieval%20guard%20tower%20top%20down%20game%20sprite&resize=60x60&transparency=true',
                'enemy-base': 'https://images.fuzzycode.dev/fast_ai?search=medieval%20enemy%20base%20top%20down%20game%20sprite&resize=150x150&transparency=true',

                // UI icons
                'food-icon': 'https://images.fuzzycode.dev/fast_ai?search=food%20icon%20game%20resource&resize=20x20&transparency=true',
                'wood-icon': 'https://images.fuzzycode.dev/fast_ai?search=wood%20icon%20game%20resource&resize=20x20&transparency=true',
                'gold-icon': 'https://images.fuzzycode.dev/fast_ai?search=gold%20icon%20game%20resource&resize=20x20&transparency=true',
                'stone-icon': 'https://images.fuzzycode.dev/fast_ai?search=stone%20icon%20game%20resource&resize=20x20&transparency=true'
            };

            const total = Object.keys(imagesToLoad).length;
            let loaded = 0;

            for (const [key, url] of Object.entries(imagesToLoad)) {
                try {
                    gameState.images[key] = await loadImage(url);
                    loaded++;
                    updateLoadingProgress((loaded / total) * 50); // Images are 50% of loading
                } catch (error) {
                    console.error(`Failed to load image ${key}:`, error);
                    loaded++;
                    updateLoadingProgress((loaded / total) * 50);
                }
            }
        }

        // Preload sounds
        function preloadSounds() {
            return new Promise((resolve) => {
                const soundsToLoad = [
                    gameState.buildingSounds.complete,
                    gameState.buildingSounds.start,
                    gameState.unitSounds.select,
                    gameState.unitSounds.move,
                    gameState.unitSounds.attack,
                    gameState.backgroundMusic,
                    'https://sounds.fuzzycode.dev/sound_effect?prompt=axe%20chopping%20wood&duration=0.5&ext=.mp3',
                    'https://sounds.fuzzycode.dev/sound_effect?prompt=pickaxe%20hitting%20stone&duration=0.5&ext=.mp3',
                    'https://sounds.fuzzycode.dev/sound_effect?prompt=picking%20berries%20rustle&duration=0.5&ext=.mp3'
                ];

                let loadedCount = 0;
                const total = soundsToLoad.length;

                soundsToLoad.forEach((soundUrl) => {
                    // Create new Audio element for each sound
                    const audio = new Audio();

                    // Add error handling before setting source
                    audio.addEventListener('error', () => {
                        console.error('Error loading sound:', soundUrl);
                        // Create a silent audio fallback
                        const silentAudio = new Audio();
                        const context = new (window.AudioContext || window.webkitAudioContext)();
                        const source = context.createBufferSource();
                        const buffer = context.createBuffer(1, 1, 22050);
                        source.buffer = buffer;
                        source.connect(context.destination);

                        // Store the fallback audio
                        gameState.sounds[soundUrl] = silentAudio;

                        // Count as loaded
                        loadedCount++;
                        updateLoadingProgress(50 + (loadedCount / total * 50));

                        if (loadedCount === total) {
                            resolve();
                        }
                    });

                    audio.addEventListener('canplaythrough', () => {
                        loadedCount++;
                        updateLoadingProgress(50 + (loadedCount / total * 50)); // Sounds are the other 50%

                        if (loadedCount === total) {
                            resolve();
                        }
                    });

                    // Set source after adding event listeners
                    audio.src = soundUrl;

                    // Store the audio element
                    gameState.sounds[soundUrl] = audio;
                });

                // If no sounds loaded after 5 seconds, resolve anyway
                setTimeout(() => {
                    if (loadedCount < total) {
                        console.warn('Not all sounds loaded, but continuing');
                        resolve();
                    }
                }, 5000);
            });
        }

        function updateLoadingProgress(percentage) {
            progressBar.style.width = `${percentage}%`;

            if (percentage >= 100) {
                startGameButton.style.display = 'block';
            }
        }

        // Initialize game
        async function initGame() {
            try {
                await preloadImages();
                await preloadSounds();

                startGameButton.addEventListener('click', () => {
                    loadingScreen.style.display = 'none';
                    startGame();
                });
            } catch (error) {
                console.error('Error initializing game:', error);
                // Show error but allow starting anyway
                startGameButton.style.display = 'block';
            }
        }

        function startGame() {
            // Reset game state
            gameState.gameStarted = true;
            gameState.gameOver = false;
            gameState.gameStartTime = Date.now();
            gameState.resources = {
                food: 200,
                wood: 200,
                gold: 100,
                stone: 100
            };
            gameState.population = 0;
            gameState.populationCap = 5;
            gameState.selectedEntities = [];
            gameState.camera = { x: 0, y: 0 };
            gameState.units = [];
            gameState.buildings = [];
            gameState.resourceNodes = [];
            gameState.enemies = [];
            gameState.projectiles = [];

            if (gameState.particles) {
                gameState.particles = [];
            }

            // Hide victory screen if visible
            document.getElementById('victory-screen').style.display = 'none';

            // Play background music
            const music = gameState.sounds[gameState.backgroundMusic];
            if (music) {
                music.loop = true;
                music.volume = 0.15; // Lower volume to make action sounds more noticeable
                music.play().catch(e => {
                    console.log("Music autoplay prevented:", e);
                    // Show user a play music button if autoplay fails
                    const musicButton = document.createElement('button');
                    musicButton.textContent = 'ðŸŽµ Play Music';
                    musicButton.style.position = 'fixed';
                    musicButton.style.top = '10px';
                    musicButton.style.right = '10px';
                    musicButton.style.zIndex = '1000';
                    musicButton.style.padding = '5px 10px';
                    musicButton.style.backgroundColor = 'rgba(0,0,0,0.6)';
                    musicButton.style.color = 'white';
                    musicButton.style.border = 'none';
                    musicButton.style.borderRadius = '4px';
                    musicButton.style.cursor = 'pointer';

                    musicButton.onclick = () => {
                        music.play();
                        musicButton.remove();
                    };

                    document.body.appendChild(musicButton);
                });
            }

            // Position camera to center of map
            gameState.camera.x = 1500 - window.innerWidth / 2;
            gameState.camera.y = 1500 - window.innerHeight / 2;

            // Create initial resources
            createInitialResources();

            // Create town center and starting units
            createTownCenter();

            // Create enemy base
            createEnemyBase();

            // Update resource display
            updateResourcesDisplay();

            // Start game loop if not already running
            if (!gameState.gameLoopRunning) {
                gameState.gameLoopRunning = true;
                requestAnimationFrame(gameLoop);
            }

            // Add notification
            showNotification("Welcome to Age of Empires Style Game! Build your empire and defeat the enemy.");
        }

        // Helper function to generate unique IDs
        function generateEntityId() {
            return 'entity_' + (gameState.entityIdCounter++);
        }

        function createInitialResources() {
            // Create trees
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 2800 + 100;
                const y = Math.random() * 2800 + 100;
                createResource('tree', x, y);
            }

            // Create gold mines
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * 2000 + 500;
                const y = Math.random() * 2000 + 500;
                createResource('gold', x, y);
            }

            // Create stone quarries
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * 2000 + 500;
                const y = Math.random() * 2000 + 500;
                createResource('stone', x, y);
            }

            // Create berry bushes
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * 2000 + 500;
                const y = Math.random() * 2000 + 500;
                createResource('berry', x, y);
            }
        }

        function createTownCenter() {
            // Create completed town center near center of map (starts complete since it's initial)
            const townCenter = createBuilding('town-center', 1400, 1400, true);

            // Create initial villagers
            for (let i = 0; i < 3; i++) {
                createUnit('villager', 1400 + 60 + Math.random() * 40, 1400 + 60 + Math.random() * 40);
            }
        }

        function createEnemyBase() {
            // Initialize enemy AI state first
            gameState.enemyAI = {
                resources: {
                    food: 200,
                    wood: 200,
                    gold: 100,
                    stone: 100
                },
                population: 8,
                populationCap: 15,
                militaryTarget: null,
                lastDecisionTime: Date.now(),
                decisionInterval: 5000, // Make decisions every 5 seconds
                phase: 'gathering', // Initial phase: gathering, building, attacking
                nextPhaseTime: Date.now() + 180000, // Move to next phase after 3 minutes
                needMoreVillagers: true,
                needMoreSoldiers: false,
                lastTrainTime: 0,
                attackForce: [],
                scoutingParty: [],
                discoveredPlayerBase: false,
                baseDefenders: []
            };

            // Create enemy base far from player
            const enemyBase = {
                id: generateEntityId(),
                type: 'enemy-base',
                x: 2500,
                y: 2500,
                width: 150,
                height: 150,
                hp: 3000,
                maxHp: 3000,
                isComplete: true, // Enemy base starts fully built
                isEnemy: true,
                acceptsResources: ['food', 'wood', 'gold', 'stone'], // Enemy base accepts resources
                isUnderAttack: false,
                lastDamageTime: 0
            };

            console.log("Enemy base created with ID:", enemyBase.id);
            gameState.buildings.push(enemyBase);

            // Create enemy buildings
            createEnemyBuilding('lumber-camp', 2450, 2400);
            createEnemyBuilding('mining-camp', 2600, 2400);
            createEnemyBuilding('mill', 2500, 2400);
            createEnemyBuilding('barracks', 2550, 2500);
            createEnemyBuilding('guard-tower', 2450, 2550);
            createEnemyBuilding('house', 2650, 2550);
            createEnemyBuilding('house', 2650, 2450);

            // Add enemy villagers
            for (let i = 0; i < 5; i++) {
                createUnit('villager', 2500 + Math.random() * 100, 2500 + Math.random() * 100, true);
                const villager = gameState.enemies[gameState.enemies.length - 1];

                // Assign initial tasks to villagers
                if (i === 0 || i === 1) {
                    // Wood gatherers
                    villager.aiRole = 'wood';
                } else if (i === 2) {
                    // Food gatherer
                    villager.aiRole = 'food';
                } else if (i === 3) {
                    // Stone gatherer
                    villager.aiRole = 'stone';
                } else {
                    // Gold gatherer
                    villager.aiRole = 'gold';
                }
            }

            // Add some enemy military units
            for (let i = 0; i < 3; i++) {
                createUnit('soldier', 2500 + Math.random() * 100, 2500 + Math.random() * 100, true);
                const enemy = gameState.enemies[gameState.enemies.length - 1];
                enemy.aiRole = 'defender';
            }
        }

        function createEnemyBuilding(type, x, y) {
            let width, height;

            switch(type) {
                case 'barracks':
                    width = 80;
                    height = 80;
                    break;
                case 'house':
                    width = 60;
                    height = 60;
                    break;
                case 'lumber-camp':
                    width = 60;
                    height = 60;
                    break;
                case 'mining-camp':
                    width = 60;
                    height = 60;
                    break;
                case 'mill':
                    width = 60;
                    height = 60;
                    break;
                case 'guard-tower':
                    width = 60;
                    height = 60;
                    break;
                default:
                    width = 60;
                    height = 60;
            }

            const building = {
                id: generateEntityId(),
                type: type,
                x: x,
                y: y,
                width: width,
                height: height,
                hp: type === 'barracks' ? 1800 : 
                    type === 'guard-tower' ? 1000 : 1200,
                maxHp: type === 'barracks' ? 1800 : 
                       type === 'guard-tower' ? 1000 : 1200,
                isEnemy: true,
                isComplete: true,
                acceptsResources: getAcceptedResources(type),
                isUnderAttack: false,
                lastDamageTime: 0,
                lastAttackTime: 0,
                attackRange: type === 'guard-tower' ? 250 : 0,
                attackDamage: type === 'guard-tower' ? 8 : 0,
                attackCooldown: type === 'guard-tower' ? 2000 : 0,
                // Gather point properties for buildings that can train
                canTrain: type === 'barracks',
                gatherPoint: type === 'barracks' ? {
                    x: x + 100,
                    y: y + 50,
                    target: null
                } : null
            };

            gameState.buildings.push(building);

            // Update enemy population cap for houses
            if (type === 'house') {
                gameState.enemyAI.populationCap += 5;
            }

            return building;
        }

        function createResource(type, x, y) {
            const resource = {
                id: generateEntityId(),
                type: type,
                x: x,
                y: y,
                width: 50,
                height: 50,
                amount: type === 'tree' ? 100 : type === 'gold' || type === 'stone' ? 250 : 100
            };

            gameState.resourceNodes.push(resource);
            return resource;
        }

        function createBuilding(type, x, y, isComplete = true) {
            let width, height;

            switch(type) {
                case 'town-center':
                    width = 100;
                    height = 100;
                    break;
                case 'barracks':
                    width = 80;
                    height = 80;
                    break;
                case 'house':
                    width = 60;
                    height = 60;
                    break;
                case 'lumber-camp':
                    width = 60;
                    height = 60;
                    break;
                case 'mining-camp':
                    width = 60;
                    height = 60;
                    break;
                case 'mill':
                    width = 60;
                    height = 60;
                    break;
                case 'guard-tower':
                    width = 60;
                    height = 60;
                    break;
                default:
                    width = 60;
                    height = 60;
            }

            const building = {
                id: generateEntityId(),
                type: type,
                x: x,
                y: y,
                width: width,
                height: height,
                hp: type === 'town-center' ? 2500 : 
                    type === 'barracks' ? 1800 : 
                    type === 'guard-tower' ? 1000 : 1200, // Different HP based on building type
                maxHp: type === 'town-center' ? 2500 : 
                       type === 'barracks' ? 1800 : 
                       type === 'guard-tower' ? 1000 : 1200,
                isEnemy: false,
                isComplete: isComplete,
                // Define what resources this building can accept
                acceptsResources: isComplete ? getAcceptedResources(type) : [],
                isUnderAttack: false,
                lastDamageTime: 0,
                // Tower-specific properties
                lastAttackTime: 0,
                attackRange: type === 'guard-tower' ? 250 : 0,
                attackDamage: type === 'guard-tower' ? 8 : 0,
                attackCooldown: type === 'guard-tower' ? 2000 : 0, // Time in ms between attacks
                // Gather point properties for buildings that can train
                canTrain: type === 'town-center' || type === 'barracks',
                gatherPoint: type === 'town-center' || type === 'barracks' ? {
                    x: type === 'town-center' ? x + 120 : x + 100,
                    y: type === 'town-center' ? y + 70 : y + 50,
                    target: null // Can be an entity ID for targeting a resource or enemy
                } : null
            };

            gameState.buildings.push(building);

            // Update population cap for houses (only if complete)
            if (type === 'house' && isComplete) {
                gameState.populationCap += 5;
                populationCapElement.textContent = gameState.populationCap;
            }

            // Play building creation sound (only if complete)
            if (isComplete) {
                playSound(gameState.buildingSounds.complete);
            }

            return building;
        }

        function createBuildingFoundation(type, x, y, cost) {
            // Create an incomplete building (foundation)
            const foundation = createBuilding(type, x, y, false);

            // Add construction properties
            foundation.isFoundation = true;
            foundation.buildProgress = 0;
            foundation.buildCost = cost;
            foundation.buildRate = 0.5; // Base build rate per second
            foundation.builders = [];

            return foundation;
        }

        function assignVillagerToBuild(villager, building) {
            // Stop current tasks
            villager.isGathering = false;
            villager.isReturningResources = false;
            villager.isAttacking = false;

            // Assign to building
            villager.isBuilding = true;
            villager.targetBuilding = building.id;

            // Distribute villagers evenly around the building by assigning different positions
            // Calculate a position around the building based on the number of builders
            const builderCount = building.builders.length;
            const angle = (builderCount * Math.PI / 4) % (2 * Math.PI); // Space builders around the building
            const radius = building.width/2 + 30;

            villager.targetX = building.x + building.width/2 + Math.cos(angle) * radius;
            villager.targetY = building.y + building.height/2 + Math.sin(angle) * radius;
            villager.isMoving = true;

            // Add villager to building's builder list if not already there
            if (!building.builders.includes(villager.id)) {
                building.builders.push(villager.id);
            }
        }

        // Helper function to determine what resources a building can accept
        function getAcceptedResources(buildingType) {
            switch(buildingType) {
                case 'town-center':
                    return ['food', 'wood', 'gold', 'stone']; // Can accept all resources
                case 'lumber-camp':
                    return ['wood'];
                case 'mining-camp':
                    return ['gold', 'stone'];
                case 'mill':
                    return ['food'];
                default:
                    return [];
            }
        }

        function createUnit(type, x, y, isEnemy = false) {
            const unit = {
                id: generateEntityId(),
                type: type,
                x: x,
                y: y,
                width: 30,
                height: 30,
                hp: type === 'villager' ? 25 : 40,
                speed: type === 'villager' ? 2 : 1.5, // Same speed for enemy and player units
                attack: type === 'villager' ? 3 : 10,
                isEnemy: isEnemy,
                isMoving: false,
                targetX: x,
                targetY: y,
                isGathering: false,
                targetResource: null,
                isAttacking: false,
                targetEnemy: null,
                angle: 0,  // For rotation
                // Resource carrying properties for villagers
                carrying: {
                    type: null,
                    amount: 0
                },
                isReturningResources: false,
                dropOffBuilding: null,
                lastGatheringSpot: null,
                justCreated: true  // Flag to indicate this unit was just created
            };

            if (!isEnemy) {
                gameState.units.push(unit);
                gameState.population++;
                populationElement.textContent = gameState.population;

                // Clear the justCreated flag after a short delay
                setTimeout(() => {
                    unit.justCreated = false;
                }, 100);
            } else {
                gameState.enemies.push(unit);
            }

            return unit;
        }

        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            notificationsElement.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Hotkey mapping for actions
        const HOTKEYS = {
            BUILD: 'z',
            TRAIN: 'z',

            // Building options
            HOUSE: 'z',
            BARRACKS: 'x',
            LUMBER_CAMP: 'c',
            MINING_CAMP: 'v',
            MILL: 'b',
            GUARD_TOWER: 'n',

            // Training options
            VILLAGER: 'z',
            SOLDIER: 'x'
        };

        // Draw functions
        function drawMap() {
            // Calculate visible area
            const startX = Math.floor(gameState.camera.x / 200) * 200;
            const startY = Math.floor(gameState.camera.y / 200) * 200;
            const endX = Math.ceil((gameState.camera.x + canvas.width) / 200) * 200;
            const endY = Math.ceil((gameState.camera.y + canvas.height) / 200) * 200;

            // Draw grass tiles only in visible area
            for (let x = startX; x < endX; x += 200) {
                for (let y = startY; y < endY; y += 200) {
                    ctx.drawImage(gameState.images['grass'], 
                        x - gameState.camera.x, 
                        y - gameState.camera.y,
                        200, 200);
                }
            }
        }

        function drawResources() {
            gameState.resourceNodes.forEach(resource => {
                // Only draw if in viewport
                if (isInViewport(resource)) {
                    ctx.drawImage(
                        gameState.images[resource.type],
                        resource.x - gameState.camera.x,
                        resource.y - gameState.camera.y,
                        resource.width,
                        resource.height
                    );

                    // Draw enemy AI status if in debug mode
                    if (gameState.debugMode) {
                        minimapCtx.fillStyle = '#ffffff';
                        minimapCtx.font = '8px Arial';
                        minimapCtx.fillText(`AI: ${gameState.enemyAI.phase}`, 5, 10);
                        minimapCtx.fillText(`Pop: ${gameState.enemyAI.population}/${gameState.enemyAI.populationCap}`, 5, 20);
                    }
                }
            });
        }

        function drawBuildings() {
            gameState.buildings.forEach(building => {
                // Only draw if in viewport
                if (isInViewport(building)) {
                    if (building.isFoundation || !building.isComplete) {
                        // Draw foundation/construction
                        const progressPercent = building.buildProgress || 0;

                        // Draw foundation outline
                        ctx.strokeStyle = '#aaa';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(
                            building.x - gameState.camera.x, 
                            building.y - gameState.camera.y, 
                            building.width, 
                            building.height
                        );

                        // Draw semi-transparent building
                        ctx.globalAlpha = 0.4 + (progressPercent * 0.6);
                        ctx.drawImage(
                            gameState.images[building.type] || gameState.images['enemy-base'],
                            building.x - gameState.camera.x,
                            building.y - gameState.camera.y,
                            building.width,
                            building.height
                        );
                        ctx.globalAlpha = 1.0;

                        // Draw construction scaffolding
                        ctx.strokeStyle = '#8B4513'; // Brown
                        ctx.beginPath();

                        // Vertical scaffolding poles
                        const poleCount = Math.floor(building.width / 20);
                        for (let i = 0; i <= poleCount; i++) {
                            const x = building.x + (i * (building.width / poleCount));
                            ctx.moveTo(x - gameState.camera.x, building.y - gameState.camera.y);
                            ctx.lineTo(x - gameState.camera.x, building.y + building.height - gameState.camera.y);
                        }

                        // Horizontal scaffolding poles
                        const rowCount = Math.floor(building.height / 20);
                        for (let i = 0; i <= rowCount; i++) {
                            const y = building.y + (i * (building.height / rowCount));
                            ctx.moveTo(building.x - gameState.camera.x, y - gameState.camera.y);
                            ctx.lineTo(building.x + building.width - gameState.camera.x, y - gameState.camera.y);
                        }

                        ctx.stroke();

                        // Draw construction progress bar
                        const barWidth = building.width * 0.8;

                        // Background
                        ctx.fillStyle = '#333';
                        ctx.fillRect(
                            building.x - gameState.camera.x + (building.width - barWidth) / 2,
                            building.y - gameState.camera.y - 15,
                            barWidth,
                            8
                        );

                        // Progress
                        ctx.fillStyle = '#3498db';
                        ctx.fillRect(
                            building.x - gameState.camera.x + (building.width - barWidth) / 2,
                            building.y - gameState.camera.y - 15,
                            barWidth * progressPercent,
                            8
                        );

                        // Progress text
                        ctx.fillStyle = '#fff';
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(
                            Math.floor(progressPercent * 100) + '%',
                            building.x - gameState.camera.x + building.width / 2,
                            building.y - gameState.camera.y - 8
                        );
                    } else {
                        // Draw completed building
                        ctx.drawImage(
                            gameState.images[building.type] || gameState.images['enemy-base'],
                            building.x - gameState.camera.x,
                            building.y - gameState.camera.y,
                            building.width,
                            building.height
                        );
                    }

                    // Draw selection outline if selected
                    if (gameState.selectedEntities.includes(building)) {
                        ctx.strokeStyle = '#00ff00';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(
                            building.x - gameState.camera.x, 
                            building.y - gameState.camera.y, 
                            building.width, 
                            building.height
                        );

                        // Draw gather point when building is selected and can train
                        if (building.canTrain && building.gatherPoint && building.isComplete) {
                            const gatherX = building.gatherPoint.x - gameState.camera.x;
                            const gatherY = building.gatherPoint.y - gameState.camera.y;
                            const buildingCenterX = building.x + building.width/2 - gameState.camera.x;
                            const buildingCenterY = building.y + building.height/2 - gameState.camera.y;

                            // Draw line from building to gather point
                            ctx.strokeStyle = '#00ff00';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(buildingCenterX, buildingCenterY);
                            ctx.lineTo(gatherX, gatherY);
                            ctx.stroke();

                            // Draw flag or marker at gather point
                            ctx.fillStyle = '#00ff00';
                            ctx.beginPath();
                            ctx.moveTo(gatherX, gatherY - 10);
                            ctx.lineTo(gatherX, gatherY + 10);
                            ctx.lineTo(gatherX + 15, gatherY);
                            ctx.closePath();
                            ctx.fill();

                            // If gather point has a target (resource or enemy), highlight it
                            if (building.gatherPoint.target) {
                                // Find the target entity
                                let targetEntity = null;

                                // Check resources
                                gameState.resourceNodes.forEach(resource => {
                                    if (resource.id === building.gatherPoint.target) {
                                        targetEntity = resource;
                                    }
                                });

                                // Check enemy units
                                if (!targetEntity) {
                                    gameState.enemies.forEach(enemy => {
                                        if (enemy.id === building.gatherPoint.target) {
                                            targetEntity = enemy;
                                        }
                                    });
                                }

                                // Check enemy buildings
                                if (!targetEntity) {
                                    gameState.buildings.forEach(bldg => {
                                        if (bldg.id === building.gatherPoint.target && bldg.isEnemy) {
                                            targetEntity = bldg;
                                        }
                                    });
                                }

                                // Highlight target if found
                                if (targetEntity && isInViewport(targetEntity)) {
                                    ctx.strokeStyle = '#00ff00';
                                    ctx.lineWidth = 2;
                                    ctx.strokeRect(
                                        targetEntity.x - gameState.camera.x,
                                        targetEntity.y - gameState.camera.y,
                                        targetEntity.width,
                                        targetEntity.height
                                    );
                                }
                            }
                        }
                    }

                    // Draw health bar if damaged
                    if (building.hp < building.maxHp) {
                        const healthPercent = building.hp / building.maxHp;
                        const barWidth = building.width * 0.8;

                        // Background
                        ctx.fillStyle = '#333';
                        ctx.fillRect(
                            building.x - gameState.camera.x + (building.width - barWidth) / 2,
                            building.y - gameState.camera.y - 10,
                            barWidth,
                            5
                        );

                        // Health
                        ctx.fillStyle = healthPercent > 0.5 ? '#0f0' : healthPercent > 0.25 ? '#ff0' : '#f00';
                        ctx.fillRect(
                            building.x - gameState.camera.x + (building.width - barWidth) / 2,
                            building.y - gameState.camera.y - 10,
                            barWidth * healthPercent,
                            5
                        );

                        // Add damage effect if building is under attack
                        if (building.isUnderAttack && Date.now() - building.lastDamageTime < 500) {
                            // Draw damage overlay
                            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                            ctx.fillRect(
                                building.x - gameState.camera.x,
                                building.y - gameState.camera.y,
                                building.width,
                                building.height
                            );

                            // Draw smoke/flame particles
                            if (!gameState.particles) gameState.particles = [];

                            if (Math.random() < 0.2) {
                                for (let i = 0; i < 3; i++) {
                                    gameState.particles.push({
                                        x: building.x + Math.random() * building.width,
                                        y: building.y + Math.random() * building.height/2,
                                        vx: Math.random() * 1 - 0.5,
                                        vy: -1 - Math.random(),
                                        life: 20 + Math.random() * 10,
                                        type: 'smoke',
                                        size: 5 + Math.random() * 5
                                    });
                                }
                            }
                        }
                    }
                }
            });
        }

        function drawUnits() {
            // Draw player units
            gameState.units.forEach(unit => {
                if (isInViewport(unit)) {
                    // Save context for rotation
                    ctx.save();

                    // Translate to unit center for rotation
                    ctx.translate(
                        unit.x - gameState.camera.x + unit.width / 2,
                        unit.y - gameState.camera.y + unit.height / 2
                    );

                    // Rotate with additional animation if applicable
                    const animationAngle = unit.gatherAngle || unit.buildAngle || unit.attackAngle || 0;
                    const rotationAngle = (unit.angle + animationAngle) * Math.PI / 180;
                    ctx.rotate(rotationAngle);

                    // Draw unit centered
                    ctx.drawImage(
                        gameState.images[unit.type],
                        -unit.width / 2,
                        -unit.height / 2,
                        unit.width,
                        unit.height
                    );

                    // Draw a simple tool if gathering
                    if (unit.isGathering && !unit.isMoving && unit.targetResource) {
                        ctx.save();

                        // Position the tool based on resource type
                        if (unit.targetResource === 'tree') {
                            // Draw axe for wood chopping
                            ctx.fillStyle = '#8B4513'; // Brown handle
                            ctx.fillRect(5, -15, 15, 5);

                            ctx.fillStyle = '#A9A9A9'; // Gray axe head
                            ctx.beginPath();
                            ctx.moveTo(20, -18);
                            ctx.lineTo(25, -15);
                            ctx.lineTo(25, -10);
                            ctx.lineTo(20, -7);
                            ctx.closePath();
                            ctx.fill();
                        } else if (unit.targetResource === 'gold' || unit.targetResource === 'stone') {
                            // Draw pickaxe for mining
                            ctx.fillStyle = '#8B4513'; // Brown handle
                            ctx.fillRect(5, -15, 15, 4);

                            ctx.fillStyle = '#A9A9A9'; // Gray pickaxe head
                            ctx.beginPath();
                            ctx.moveTo(20, -18);
                            ctx.lineTo(25, -13);
                            ctx.lineTo(20, -11);
                            ctx.moveTo(20, -11);
                            ctx.lineTo(25, -9);
                            ctx.lineTo(20, -4);
                            ctx.stroke();
                        } else if (unit.targetResource === 'berry') {
                            // Draw basket for berry picking
                            ctx.fillStyle = '#DEB887'; // Basket color
                            ctx.beginPath();
                            ctx.ellipse(10, -10, 8, 6, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#8B4513';
                            ctx.beginPath();
                            ctx.ellipse(10, -10, 8, 6, 0, 0, Math.PI * 2);
                            ctx.stroke();
                        }

                        ctx.restore();
                    }

                    // Draw hammer if building
                    if (unit.isBuilding && !unit.isMoving) {
                        ctx.save();

                        // Draw hammer for construction
                        ctx.fillStyle = '#8B4513'; // Brown handle
                        ctx.fillRect(5, -15, 15, 4);

                        ctx.fillStyle = '#A9A9A9'; // Gray hammer head
                        ctx.fillRect(20, -18, 10, 10);

                        ctx.restore();
                    }

                    // Draw resource being carried (if any)
                    if (unit.carrying && unit.carrying.amount > 0) {
                        ctx.save();

                        // Draw a small icon showing what's being carried
                        if (unit.carrying.type === 'wood') {
                            ctx.fillStyle = '#8B4513'; // Brown
                            ctx.fillRect(-5, -20, 10, 5);
                        } else if (unit.carrying.type === 'food') {
                            ctx.fillStyle = '#FF6347'; // Tomato red
                            ctx.beginPath();
                            ctx.arc(0, -18, 4, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (unit.carrying.type === 'gold') {
                            ctx.fillStyle = '#FFD700'; // Gold
                            ctx.beginPath();
                            ctx.arc(0, -18, 3, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (unit.carrying.type === 'stone') {
                            ctx.fillStyle = '#A9A9A9'; // Gray
                            ctx.beginPath();
                            ctx.arc(0, -18, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Show carrying amount as small text
                        ctx.fillStyle = '#FFF';
                        ctx.font = '6px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(unit.carrying.amount, 0, -10);

                        ctx.restore();
                    }

                    // Restore context
                    ctx.restore();

                    // Draw selection outline if selected
                    if (gameState.selectedEntities.includes(unit)) {
                        ctx.strokeStyle = '#00ff00';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(
                            unit.x - gameState.camera.x, 
                            unit.y - gameState.camera.y, 
                            unit.width, 
                            unit.height
                        );
                    }

                    // Draw health bar
                    const maxHp = unit.type === 'villager' ? 25 : 40;
                    const healthPercent = unit.hp / maxHp;
                    const barWidth = unit.width;

                    // Background
                    ctx.fillStyle = '#333';
                    ctx.fillRect(
                        unit.x - gameState.camera.x,
                        unit.y - gameState.camera.y - 8,
                        barWidth,
                        4
                    );

                    // Health
                    ctx.fillStyle = healthPercent > 0.5 ? '#0f0' : healthPercent > 0.25 ? '#ff0' : '#f00';
                    ctx.fillRect(
                        unit.x - gameState.camera.x,
                        unit.y - gameState.camera.y - 8,
                        barWidth * healthPercent,
                        4
                    );
                }
            });

            // Draw enemy units
            gameState.enemies.forEach(enemy => {
                if (isInViewport(enemy)) {
                    // Save context for rotation
                    ctx.save();

                    // Translate to unit center for rotation
                    ctx.translate(
                        enemy.x - gameState.camera.x + enemy.width / 2,
                        enemy.y - gameState.camera.y + enemy.height / 2
                    );

                    // Rotate with appropriate animation based on activity
                    const animationAngle = enemy.attackAngle || enemy.gatherAngle || enemy.buildAngle || 0;
                    const rotationAngle = (enemy.angle + animationAngle) * Math.PI / 180;
                    ctx.rotate(rotationAngle);

                    // Draw enemy unit centered with a red tint
                    ctx.drawImage(
                        gameState.images[enemy.type],
                        -enemy.width / 2,
                        -enemy.height / 2,
                        enemy.width,
                        enemy.height
                    );

                    // Apply red tint
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fillRect(
                        -enemy.width / 2,
                        -enemy.height / 2,
                        enemy.width,
                        enemy.height
                    );

                    // Draw resource being carried by enemy villagers (if any)
                    if (enemy.type === 'villager' && enemy.carrying && enemy.carrying.amount > 0) {
                        ctx.save();

                        // Draw a small icon showing what's being carried
                        if (enemy.carrying.type === 'wood') {
                            ctx.fillStyle = '#8B4513'; // Brown
                            ctx.fillRect(-5, -20, 10, 5);
                        } else if (enemy.carrying.type === 'food') {
                            ctx.fillStyle = '#FF6347'; // Tomato red
                            ctx.beginPath();
                            ctx.arc(0, -18, 4, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (enemy.carrying.type === 'gold') {
                            ctx.fillStyle = '#FFD700'; // Gold
                            ctx.beginPath();
                            ctx.arc(0, -18, 3, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (enemy.carrying.type === 'stone') {
                            ctx.fillStyle = '#A9A9A9'; // Gray
                            ctx.beginPath();
                            ctx.arc(0, -18, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Show carrying amount as small text
                        ctx.fillStyle = '#FFF';
                        ctx.font = '6px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(enemy.carrying.amount, 0, -10);

                        ctx.restore();
                    }

                    // Draw a simple tool if gathering
                    if (enemy.type === 'villager' && enemy.isGathering && !enemy.isMoving && enemy.targetResource) {
                        ctx.save();

                        // Position the tool based on resource type
                        if (enemy.targetResource === 'tree') {
                            // Draw axe for wood chopping
                            ctx.fillStyle = '#8B4513'; // Brown handle
                            ctx.fillRect(5, -15, 15, 5);

                            ctx.fillStyle = '#A9A9A9'; // Gray axe head
                            ctx.beginPath();
                            ctx.moveTo(20, -18);
                            ctx.lineTo(25, -15);
                            ctx.lineTo(25, -10);
                            ctx.lineTo(20, -7);
                            ctx.closePath();
                            ctx.fill();
                        } else if (enemy.targetResource === 'gold' || enemy.targetResource === 'stone') {
                            // Draw pickaxe for mining
                            ctx.fillStyle = '#8B4513'; // Brown handle
                            ctx.fillRect(5, -15, 15, 4);

                            ctx.fillStyle = '#A9A9A9'; // Gray pickaxe head
                            ctx.beginPath();
                            ctx.moveTo(20, -18);
                            ctx.lineTo(25, -13);
                            ctx.lineTo(20, -11);
                            ctx.moveTo(20, -11);
                            ctx.lineTo(25, -9);
                            ctx.lineTo(20, -4);
                            ctx.stroke();
                        } else if (enemy.targetResource === 'berry') {
                            // Draw basket for berry picking
                            ctx.fillStyle = '#DEB887'; // Basket color
                            ctx.beginPath();
                            ctx.ellipse(10, -10, 8, 6, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#8B4513';
                            ctx.beginPath();
                            ctx.ellipse(10, -10, 8, 6, 0, 0, Math.PI * 2);
                            ctx.stroke();
                        }

                        ctx.restore();
                    }

                    // Restore context
                    ctx.restore();

                    // Draw health bar
                    const maxHp = enemy.type === 'villager' ? 25 : 40;
                    const healthPercent = enemy.hp / maxHp;
                    const barWidth = enemy.width;

                    // Background
                    ctx.fillStyle = '#333';
                    ctx.fillRect(
                        enemy.x - gameState.camera.x,
                        enemy.y - gameState.camera.y - 8,
                        barWidth,
                        4
                    );

                    // Health
                    ctx.fillStyle = '#f00';
                    ctx.fillRect(
                        enemy.x - gameState.camera.x,
                        enemy.y - gameState.camera.y - 8,
                        barWidth * healthPercent,
                        4
                    );

                    // Draw role indicator above enemy units
                    if (enemy.aiRole) {
                        ctx.fillStyle = '#fff';
                        ctx.font = '8px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(
                            enemy.aiRole,
                            enemy.x - gameState.camera.x + enemy.width / 2,
                            enemy.y - gameState.camera.y - 12
                        );
                    }
                }
            });
        }

        function drawSelectionBox() {
            if (gameState.dragStart && gameState.selectionBox) {
                const left = Math.min(gameState.dragStart.x, gameState.selectionBox.x);
                const top = Math.min(gameState.dragStart.y, gameState.selectionBox.y);
                const width = Math.abs(gameState.selectionBox.x - gameState.dragStart.x);
                const height = Math.abs(gameState.selectionBox.y - gameState.dragStart.y);

                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(left, top, width, height);
                ctx.setLineDash([]);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(left, top, width, height);
            }
        }

        function drawMinimap() {
            // Clear minimap
            minimapCtx.fillStyle = '#225522';
            minimapCtx.fillRect(0, 0, 150, 100);

            // Calculate scale
            const scaleX = 150 / gameState.mapSize.width;
            const scaleY = 100 / gameState.mapSize.height;

            // Draw resources (yellow dots)
            minimapCtx.fillStyle = '#ffff00';
            gameState.resourceNodes.forEach(resource => {
                const x = resource.x * scaleX;
                const y = resource.y * scaleY;
                minimapCtx.fillRect(x, y, 1, 1);
            });

            // Draw buildings with different colors based on owner
            gameState.buildings.forEach(building => {
                const x = building.x * scaleX;
                const y = building.y * scaleY;
                const width = Math.max(3, building.width * scaleX);
                const height = Math.max(3, building.height * scaleY);

                if (building.isEnemy) {
                    // Enemy buildings (red)
                    minimapCtx.fillStyle = '#ff0000';
                } else {
                    // Player buildings (blue)
                    minimapCtx.fillStyle = '#0000ff';
                }
                minimapCtx.fillRect(x, y, width, height);
            });

            // Draw units (green dots)
            minimapCtx.fillStyle = '#00ff00';
            gameState.units.forEach(unit => {
                const x = unit.x * scaleX;
                const y = unit.y * scaleY;
                minimapCtx.fillRect(x, y, 2, 2);
            });

            // Draw enemies with different colors based on type
            gameState.enemies.forEach(enemy => {
                const x = enemy.x * scaleX;
                const y = enemy.y * scaleY;

                if (enemy.type === 'villager') {
                    // Enemy villagers (orange)
                    minimapCtx.fillStyle = '#ff8800';
                } else {
                    // Enemy soldiers (red)
                    minimapCtx.fillStyle = '#ff0000';
                }
                minimapCtx.fillRect(x, y, 2, 2);
            });

            // Draw viewport indicator
            minimapCtx.strokeStyle = '#ffffff';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                gameState.camera.x * scaleX,
                gameState.camera.y * scaleY,
                canvas.width * scaleX,
                canvas.height * scaleY
            );
        }

        function drawFPS() {
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.fillText(`FPS: ${gameState.fps.toFixed(1)}`, 10, 20);
        }

        function drawBuildingPreview() {
            if (gameState.buildingMode && gameState.buildingType && gameState.mousePosition) {
                const mouseX = gameState.mousePosition.x;
                const mouseY = gameState.mousePosition.y;

                let width, height;

                switch(gameState.buildingType) {
                    case 'town-center':
                        width = 100;
                        height = 100;
                        break;
                    case 'barracks':
                        width = 80;
                        height = 80;
                        break;
                    case 'house':
                        width = 60;
                        height = 60;
                        break;
                    default:
                        width = 60;
                        height = 60;
                }

                // Draw semi-transparent building preview
                ctx.globalAlpha = 0.5;
                ctx.drawImage(
                    gameState.images[gameState.buildingType],
                    mouseX - width / 2,
                    mouseY - height / 2,
                    width,
                    height
                );
                ctx.globalAlpha = 1.0;
            }
        }

        // Helper to check if entity is in viewport
        function isInViewport(entity) {
            return entity.x + entity.width > gameState.camera.x &&
                   entity.x < gameState.camera.x + canvas.width &&
                   entity.y + entity.height > gameState.camera.y &&
                   entity.y < gameState.camera.y + canvas.height;
        }

        // Update functions
        function updateUnits(deltaTime) {
            // Update buildings under construction
            gameState.buildings.forEach(building => {
                if (building.isFoundation && !building.isComplete) {
                    let activeBuilders = 0;

                    // Check all assigned builders
                    building.builders = building.builders.filter(builderId => {
                        const builder = gameState.units.find(unit => unit.id === builderId);
                        return builder && !builder.isEnemy; // Keep only valid builders
                    });

                    // Count active builders (those who are close enough)
                    building.builders.forEach(builderId => {
                        const builder = gameState.units.find(unit => unit.id === builderId);
                        if (builder && builder.isBuilding && !builder.isMoving) {
                            const distance = Math.sqrt(
                                Math.pow(building.x + building.width/2 - builder.x, 2) +
                                Math.pow(building.y + building.height/2 - builder.y, 2)
                            );

                            if (distance < 70) { // Close enough to build
                                activeBuilders++;

                                // Animate builder for construction
                                if (!builder.buildAngle) builder.buildAngle = 0;
                                builder.buildAngle = 15 * Math.sin(Date.now() / 200); // Hammering animation

                                // Create construction particles occasionally
                                if (Math.random() < 0.05) {
                                    if (!gameState.particles) gameState.particles = [];

                                    gameState.particles.push({
                                        x: building.x + Math.random() * building.width,
                                        y: building.y + Math.random() * building.height,
                                        vx: Math.random() * 1 - 0.5,
                                        vy: -1 - Math.random(),
                                        life: 20,
                                        type: 'construction',
                                        size: 2 + Math.random() * 2
                                    });
                                }

                                // Play construction sound occasionally
                                if (Math.random() < 0.01) {
                                    const constructionSounds = [
                                        'https://sounds.fuzzycode.dev/sound_effect?prompt=hammering%20wood%20construction&duration=0.5&ext=.mp3',
                                        'https://sounds.fuzzycode.dev/sound_effect?prompt=sawing%20wood%20construction&duration=0.5&ext=.mp3'
                                    ];

                                    const soundUrl = constructionSounds[Math.floor(Math.random() * constructionSounds.length)];
                                    playSound(soundUrl, {x: building.x, y: building.y});
                                }
                            }
                        }
                    });

                    // Update build progress based on number of active builders
                    if (activeBuilders > 0) {
                        // More builders = faster construction, but with diminishing returns
                        const builderMultiplier = Math.sqrt(activeBuilders);
                        building.buildProgress += (building.buildRate * builderMultiplier * deltaTime) / 1000;

                        // Check if construction is complete
                        if (building.buildProgress >= 1) {
                            completeBuilding(building);
                        }
                    }
                }
            });

            // Update player units
            gameState.units.forEach(unit => {
                if (gameState.debugLogging) {
                    console.log(`[${Date.now() - gameState.gameStartTime}ms] Player Unit ${unit.id} (${unit.type}) speed: ${unit.speed}`);
                }
                if (unit.isMoving) {
                    const speed = unit.speed;
                    const unitX = unit.x;
                    const unitY = unit.y;
                    const targetX = unit.targetX;
                    const targetY = unit.targetY;

                    // Calculate distance to target
                    const dx = targetX - unitX;
                    const dy = targetY - unitY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < speed) {
                        // Arrived at destination
                        unit.x = targetX;
                        unit.y = targetY;
                        unit.isMoving = false;

                        if (unit.isGathering) {
                            // Start gathering
                            // This will be handled in the resource gathering logic
                        } else if (unit.isBuilding) {
                            // Start building - handled in building update
                        }
                    } else {
                        // Move towards target
                        const moveX = dx / distance * speed;
                        const moveY = dy / distance * speed;

                        unit.x += moveX;
                        unit.y += moveY;

                        // Update angle for rotation
                        unit.angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    }
                }

                // Handle villagers returning resources to drop-off point
                if (unit.isReturningResources && !unit.isMoving) {
                    // We've reached the drop-off building
                    if (unit.dropOffBuilding) {
                        // Add resources to player's stockpile
                        if (unit.carrying.type && unit.carrying.amount > 0) {
                            gameState.resources[unit.carrying.type] += unit.carrying.amount;

                            // Play drop-off sound
                            playSound(gameState.buildingSounds.dropoff, {x: unit.x, y: unit.y});

                            // Reset carrying
                            unit.carrying.amount = 0;
                            unit.carrying.type = null;
                            unit.isReturningResources = false;

                            // Create small particle effect for resource drop-off
                            if (!gameState.particles) gameState.particles = [];
                            for (let i = 0; i < 5; i++) {
                                gameState.particles.push({
                                    x: unit.x + Math.random() * 20 - 10,
                                    y: unit.y + Math.random() * 20 - 10,
                                    vx: Math.random() * 2 - 1,
                                    vy: Math.random() * -2,
                                    life: 15,
                                    type: 'dropoff',
                                    size: 3 + Math.random() * 3
                                });
                            }

                            updateResourcesDisplay();

                            // Return to previous gathering location if it exists
                            if (unit.lastGatheringSpot && unit.targetResource) {
                                unit.targetX = unit.lastGatheringSpot.x;
                                unit.targetY = unit.lastGatheringSpot.y;
                                unit.isMoving = true;
                                unit.isGathering = true;
                            }
                        }
                    } else {
                        // No drop-off building available anymore, find a new one
                        const nearestDropOff = findNearestDropOffBuilding(unit);
                        if (nearestDropOff) {
                            unit.dropOffBuilding = nearestDropOff;
                            unit.targetX = nearestDropOff.x + nearestDropOff.width / 2;
                            unit.targetY = nearestDropOff.y + nearestDropOff.height / 2;
                            unit.isMoving = true;
                        } else {
                            // No drop-off buildings at all, just drop resources
                            showNotification("No drop-off buildings available. Resources lost!");
                            unit.carrying.amount = 0;
                            unit.carrying.type = null;
                            unit.isReturningResources = false;
                        }
                    }
                }

                // Handle gathering
                if (unit.isGathering && !unit.isMoving && !unit.isReturningResources) {
                    // Find the closest resource of the target type
                    const unitX = unit.x;
                    const unitY = unit.y;
                    const resourceType = unit.targetResource;

                    let closestResource = null;
                    let closestDistance = Infinity;

                    gameState.resourceNodes.forEach(resource => {
                        if (resource.type === resourceType && resource.amount > 0) {
                            const resourceX = resource.x;
                            const resourceY = resource.y;
                            const distance = Math.sqrt(Math.pow(resourceX - unitX, 2) + Math.pow(resourceY - unitY, 2));

                            if (distance < closestDistance) {
                                closestResource = resource;
                                closestDistance = distance;
                            }
                        }
                    });

                    if (closestResource && closestDistance < 60) {
                        // Save this spot for returning later
                        unit.lastGatheringSpot = {
                            x: unitX,
                            y: unitY
                        };

                        // We're close enough to gather
                        const resourceAmount = closestResource.amount;

                        if (resourceAmount > 0) {
                            // Check if we're already full and need to return resources
                            if (unit.carrying.amount >= gameState.villagerCapacity) {
                                // Find nearest drop-off point and return resources
                                const dropOffBuilding = findNearestDropOffBuilding(unit);
                                if (dropOffBuilding) {
                                    unit.isReturningResources = true;
                                    unit.isGathering = false;
                                    unit.dropOffBuilding = dropOffBuilding;
                                    unit.targetX = dropOffBuilding.x + dropOffBuilding.width / 2;
                                    unit.targetY = dropOffBuilding.y + dropOffBuilding.height / 2;
                                    unit.isMoving = true;
                                    unit.gatherAngle = 0;
                                    return; // Skip rest of gathering logic
                                } else {
                                    // No drop-off point found
                                    showNotification("No drop-off buildings available for " + mapResourceToName(unit.carrying.type));
                                    unit.carrying.amount = 0; // Just reset carrying
                                }
                            }

                            // Gather resource at a slower rate (once per 10 ticks)
                            if (!unit.gatherTicks) {
                                unit.gatherTicks = 0;
                                unit.gatherAngle = 0;
                            }

                            unit.gatherTicks++;

                            // Create gathering animation based on resource type
                            if (resourceType === 'tree') {
                                // Chopping animation - swing back and forth
                                unit.gatherAngle = 30 * Math.sin(unit.gatherTicks * 0.2);

                                // Face the resource
                                const angle = Math.atan2(closestResource.y - unitY, closestResource.x - unitX);
                                unit.angle = angle * 180 / Math.PI;

                                // Add visual particle effect on every 5th tick
                                if (unit.gatherTicks % 5 === 0) {
                                    if (!gameState.particles) gameState.particles = [];

                                    // Wood chips flying off
                                    for (let i = 0; i < 3; i++) {
                                        gameState.particles.push({
                                            x: closestResource.x + Math.random() * 20 - 10,
                                            y: closestResource.y + Math.random() * 20 - 10,
                                            vx: Math.random() * 2 - 1,
                                            vy: Math.random() * -2,
                                            life: 20,
                                            type: 'woodchip',
                                            size: 3 + Math.random() * 3
                                        });
                                    }
                                }
                            } else if (resourceType === 'gold' || resourceType === 'stone') {
                                // Mining animation - bobbing up and down
                                unit.gatherAngle = 15 * Math.sin(unit.gatherTicks * 0.3);

                                // Face the resource
                                const angle = Math.atan2(closestResource.y - unitY, closestResource.x - unitX);
                                unit.angle = angle * 180 / Math.PI;

                                // Add visual particle effect on every 7th tick
                                if (unit.gatherTicks % 7 === 0) {
                                    if (!gameState.particles) gameState.particles = [];

                                    // Dust/sparkle particles
                                    for (let i = 0; i < 2; i++) {
                                        gameState.particles.push({
                                            x: closestResource.x + Math.random() * 30 - 15,
                                            y: closestResource.y + Math.random() * 30 - 15,
                                            vx: Math.random() * 1 - 0.5,
                                            vy: Math.random() * -1,
                                            life: 15,
                                            type: resourceType === 'gold' ? 'goldspark' : 'dust',
                                            size: 2 + Math.random() * 2
                                        });
                                    }
                                }
                            } else if (resourceType === 'berry') {
                                // Picking animation - subtle movement
                                unit.gatherAngle = 5 * Math.sin(unit.gatherTicks * 0.4);

                                // Face the resource
                                const angle = Math.atan2(closestResource.y - unitY, closestResource.x - unitX);
                                unit.angle = angle * 180 / Math.PI;
                            }

                                // Play gather sound occasionally - increase frequency for better feedback
                                if (Math.random() < 0.05) { // Increased from 0.01 to 0.05
                                    let soundUrl;
                                    if (resourceType === 'tree') {
                                        soundUrl = 'https://sounds.fuzzycode.dev/sound_effect?prompt=axe%20chopping%20wood&duration=0.5&ext=.mp3';
                                    } else if (resourceType === 'gold' || resourceType === 'stone') {
                                        soundUrl = 'https://sounds.fuzzycode.dev/sound_effect?prompt=pickaxe%20hitting%20stone&duration=0.5&ext=.mp3';
                                    } else if (resourceType === 'berry') {
                                        soundUrl = 'https://sounds.fuzzycode.dev/sound_effect?prompt=picking%20berries%20rustle&duration=0.5&ext=.mp3';
                                    }

                                    // Preload sound if not already loaded
                                    if (soundUrl && !gameState.sounds[soundUrl]) {
                                        const audio = new Audio();
                                        audio.src = soundUrl;
                                        gameState.sounds[soundUrl] = audio;
                                    }

                                    // Play sound with appropriate volume
                                    playSound(soundUrl, {x: closestResource.x, y: closestResource.y});

                                    // Visual feedback when sound plays
                                    if (!gameState.particles) gameState.particles = [];
                                    for (let i = 0; i < 2; i++) {
                                        gameState.particles.push({
                                            x: closestResource.x + Math.random() * 30 - 15,
                                            y: closestResource.y + Math.random() * 30 - 15,
                                            vx: Math.random() * 1 - 0.5,
                                            vy: Math.random() * -1,
                                            life: 10,
                                            type: resourceType === 'tree' ? 'woodchip' : 
                                                  resourceType === 'gold' ? 'goldspark' : 
                                                  resourceType === 'stone' ? 'dust' : 'dropoff',
                                            size: 2 + Math.random() * 2
                                        });
                                    }
                                }
                            if (unit.gatherTicks >= 10) {
                                closestResource.amount -= 1;

                                // Add to villager's carrying amount
                                if (unit.carrying.type === null) {
                                    // Start carrying this resource type
                                    unit.carrying.type = mapResourceTypeToResource(resourceType);
                                    unit.carrying.amount = 1;
                                } else if (unit.carrying.type === mapResourceTypeToResource(resourceType)) {
                                    // Add to existing carried resource
                                    unit.carrying.amount += 1;
                                }

                                unit.gatherTicks = 0;
                            }

                            // If resource is depleted, remove it
                            if (closestResource.amount <= 0) {
                                gameState.resourceNodes = gameState.resourceNodes.filter(r => r !== closestResource);
                                unit.isGathering = false;
                                unit.gatherAngle = 0;

                                // If carrying resources, return to drop-off
                                if (unit.carrying.amount > 0) {
                                    const dropOffBuilding = findNearestDropOffBuilding(unit);
                                    if (dropOffBuilding) {
                                        unit.isReturningResources = true;
                                        unit.dropOffBuilding = dropOffBuilding;
                                        unit.targetX = dropOffBuilding.x + dropOffBuilding.width / 2;
                                        unit.targetY = dropOffBuilding.y + dropOffBuilding.height / 2;
                                        unit.isMoving = true;
                                    }
                                }
                            }
                        } else {
                            // Resource is depleted, stop gathering
                            unit.isGathering = false;
                            unit.gatherAngle = 0;

                            // If carrying resources, return to drop-off
                            if (unit.carrying.amount > 0) {
                                const dropOffBuilding = findNearestDropOffBuilding(unit);
                                if (dropOffBuilding) {
                                    unit.isReturningResources = true;
                                    unit.dropOffBuilding = dropOffBuilding;
                                    unit.targetX = dropOffBuilding.x + dropOffBuilding.width / 2;
                                    unit.targetY = dropOffBuilding.y + dropOffBuilding.height / 2;
                                    unit.isMoving = true;
                                }
                            }
                        }
                    } else if (closestResource) {
                        // Move closer to resource
                        unit.targetX = closestResource.x;
                        unit.targetY = closestResource.y;
                        unit.isMoving = true;
                    } else {
                        // No resources of this type left
                        unit.isGathering = false;
                        unit.gatherAngle = 0;
                        showNotification(`No more ${resourceType} resources available.`);

                        // If carrying resources, return to drop-off
                        if (unit.carrying.amount > 0) {
                            const dropOffBuilding = findNearestDropOffBuilding(unit);
                            if (dropOffBuilding) {
                                unit.isReturningResources = true;
                                unit.dropOffBuilding = dropOffBuilding;
                                unit.targetX = dropOffBuilding.x + dropOffBuilding.width / 2;
                                unit.targetY = dropOffBuilding.y + dropOffBuilding.height / 2;
                                unit.isMoving = true;
                            }
                        }
                    }
                }

                // Helper function to map resource node type to resource type
                function mapResourceTypeToResource(nodeType) {
                    if (nodeType === 'tree') return 'wood';
                    if (nodeType === 'berry') return 'food';
                    return nodeType; // gold and stone are the same
                }

                // Helper function to get friendly name for resource
                function mapResourceToName(resourceType) {
                    if (resourceType === 'wood') return 'Wood';
                    if (resourceType === 'food') return 'Food';
                    if (resourceType === 'gold') return 'Gold';
                    if (resourceType === 'stone') return 'Stone';
                    return 'Resources';
                }

                // Find the nearest building that can accept this resource type
                function findNearestDropOffBuilding(unit) {
                    if (!unit.carrying.type) return null;

                    const resourceType = unit.carrying.type;
                    let nearestBuilding = null;
                    let nearestDistance = Infinity;

                    gameState.buildings.forEach(building => {
                        if (building.isEnemy) return;

                        // Check if building accepts this resource type
                        if (building.acceptsResources && building.acceptsResources.includes(resourceType)) {
                            // For gold and stone, prioritize mining camps
                            if ((resourceType === 'gold' || resourceType === 'stone') && 
                                building.type !== 'mining-camp' && 
                                building.type !== 'town-center') {
                                // Skip non-mining buildings for gold/stone unless it's town center
                                return;
                            }

                            // For wood, prioritize lumber camps
                            if (resourceType === 'wood' && 
                                building.type !== 'lumber-camp' && 
                                building.type !== 'town-center') {
                                // Skip non-lumber buildings for wood unless it's town center
                                return;
                            }

                            // For food, prioritize mills
                            if (resourceType === 'food' && 
                                building.type !== 'mill' && 
                                building.type !== 'town-center') {
                                // Skip non-mill buildings for food unless it's town center
                                return;
                            }

                            const distance = Math.sqrt(
                                Math.pow(building.x + building.width/2 - unit.x, 2) + 
                                Math.pow(building.y + building.height/2 - unit.y, 2)
                            );

                            if (distance < nearestDistance) {
                                nearestBuilding = building;
                                nearestDistance = distance;
                            }
                        }
                    });

                    return nearestBuilding;
                }

                // Handle attacking
                if (unit.isAttacking) {
                    // Find the target enemy or building
                    let targetEnemy = null;
                    let targetBuilding = null;

                    if (unit.targetEnemy) {
                        targetEnemy = gameState.enemies.find(enemy => enemy.id === unit.targetEnemy);
                    } else if (unit.targetBuilding) {
                        targetBuilding = gameState.buildings.find(building => building.id === unit.targetBuilding);
                    }

                    if (targetEnemy) {
                        const distance = Math.sqrt(
                            Math.pow(targetEnemy.x - unit.x, 2) + 
                            Math.pow(targetEnemy.y - unit.y, 2)
                        );

                        // If close enough, attack
                        if (distance < 40) {
                            unit.isMoving = false;

                            // Attack once per second
                            if (!unit.lastAttackTime || Date.now() - unit.lastAttackTime > 1000) {
                                // Add attack animation
                                unit.attackAngle = 30; // Start the attack swing
                                unit.attackAnimationStart = Date.now();

                                // Play attack sound
                                playSound(gameState.unitSounds.sword, {x: unit.x, y: unit.y});

                                // Apply damage
                                targetEnemy.hp -= unit.attack;
                                unit.lastAttackTime = Date.now();

                                // Create hit particles
                                if (!gameState.particles) gameState.particles = [];
                                for (let i = 0; i < 5; i++) {
                                    gameState.particles.push({
                                        x: targetEnemy.x + targetEnemy.width/2 + (Math.random() * 20 - 10),
                                        y: targetEnemy.y + targetEnemy.height/2 + (Math.random() * 20 - 10),
                                        vx: Math.random() * 2 - 1,
                                        vy: Math.random() * 2 - 1,
                                        life: 10,
                                        type: 'hit',
                                        size: 3 + Math.random() * 2
                                    });
                                }

                                // If enemy is defeated
                                if (targetEnemy.hp <= 0) {
                                    gameState.enemies = gameState.enemies.filter(e => e !== targetEnemy);
                                    unit.isAttacking = false;
                                    unit.targetEnemy = null;

                                    // Check if all enemies are defeated
                                    checkVictoryCondition();
                                }
                            } else if (unit.attackAnimationStart) {
                                // Update attack animation
                                const animTime = Date.now() - unit.attackAnimationStart;
                                if (animTime < 500) { // Animation lasts 500ms
                                    // Swing animation: start at +30 degrees, end at -30 degrees
                                    unit.attackAngle = 30 - (animTime / 500 * 60);
                                } else {
                                    // Reset animation
                                    unit.attackAngle = 0;
                                    unit.attackAnimationStart = null;
                                }
                            }
                        } else {
                            // Move towards enemy
                            unit.targetX = targetEnemy.x;
                            unit.targetY = targetEnemy.y;
                            unit.isMoving = true;
                        }
                    } else if (targetBuilding) {
                        // Attacking a building (like enemy base)
                        const distance = Math.sqrt(
                            Math.pow((targetBuilding.x + targetBuilding.width/2) - unit.x, 2) + 
                            Math.pow((targetBuilding.y + targetBuilding.height/2) - unit.y, 2)
                        );

                        // If close enough, attack (use larger attack range for buildings)
                        const attackRange = Math.max(40, targetBuilding.width/4);
                        if (distance < attackRange) {
                            unit.isMoving = false;

                            // Attack once per second
                            if (!unit.lastAttackTime || Date.now() - unit.lastAttackTime > 1000) {
                                // Add attack animation
                                unit.attackAngle = 30; // Start the attack swing
                                unit.attackAnimationStart = Date.now();

                                // Play attack sound
                                playSound(gameState.unitSounds.sword, {x: unit.x, y: unit.y});

                                // Apply damage
                                targetBuilding.hp -= unit.attack;
                                unit.lastAttackTime = Date.now();

                                // Mark building as under attack
                                targetBuilding.isUnderAttack = true;
                                targetBuilding.lastDamageTime = Date.now();

                                // Create hit particles
                                if (!gameState.particles) gameState.particles = [];
                                for (let i = 0; i < 8; i++) {
                                    gameState.particles.push({
                                        x: targetBuilding.x + Math.random() * targetBuilding.width,
                                        y: targetBuilding.y + Math.random() * targetBuilding.height,
                                        vx: Math.random() * 3 - 1.5,
                                        vy: Math.random() * 3 - 1.5,
                                        life: 15,
                                        type: 'buildingDamage',
                                        size: 4 + Math.random() * 3
                                    });
                                }

                                // If building is destroyed
                                if (targetBuilding.hp <= 0) {
                                    // Create explosion effect
                                    if (!gameState.particles) gameState.particles = [];
                                    for (let i = 0; i < 30; i++) {
                                        gameState.particles.push({
                                            x: targetBuilding.x + Math.random() * targetBuilding.width,
                                            y: targetBuilding.y + Math.random() * targetBuilding.height,
                                            vx: Math.random() * 5 - 2.5,
                                            vy: Math.random() * 5 - 2.5,
                                            life: 30 + Math.random() * 20,
                                            type: 'explosion',
                                            size: 5 + Math.random() * 5
                                        });
                                    }

                                    // Remove the building
                                    gameState.buildings = gameState.buildings.filter(b => b !== targetBuilding);

                                    if (targetBuilding.type === 'enemy-base') {
                                        showNotification("Victory! Enemy base destroyed!");
                                    } else {
                                        showNotification(`${targetBuilding.type.charAt(0).toUpperCase() + targetBuilding.type.slice(1)} has been destroyed!`);
                                    }

                                    unit.isAttacking = false;
                                    unit.targetBuilding = null;

                                    // Check if all enemies are defeated
                                    checkVictoryCondition();
                                }
                            } else if (unit.attackAnimationStart) {
                                // Update attack animation
                                const animTime = Date.now() - unit.attackAnimationStart;
                                if (animTime < 500) { // Animation lasts 500ms
                                    // Swing animation: start at +30 degrees, end at -30 degrees
                                    unit.attackAngle = 30 - (animTime / 500 * 60);
                                } else {
                                    // Reset animation
                                    unit.attackAngle = 0;
                                    unit.attackAnimationStart = null;
                                }
                            }
                        } else {
                            // Move towards building
                            unit.targetX = targetBuilding.x + targetBuilding.width/2;
                            unit.targetY = targetBuilding.y + targetBuilding.height/2;
                            unit.isMoving = true;
                        }
                    } else {
                        // Target is gone, stop attacking
                        unit.isAttacking = false;
                        unit.targetEnemy = null;
                        unit.targetBuilding = null;
                    }
                }
            });

            // Advanced AI for enemy units
            updateEnemyAI(deltaTime);

            gameState.enemies.forEach(enemy => {
                if (gameState.debugLogging) {
                    console.log(`[${Date.now() - gameState.gameStartTime}ms] Enemy Unit ${enemy.id} (${enemy.type}) speed: ${enemy.speed}`);
                }
                // Handle different roles for enemy units
                if (!enemy.isMoving && !enemy.isAttacking) {
                    if (enemy.type === 'villager') {
                        // Villager AI based on assigned role
                        updateEnemyVillager(enemy);
                    } else if (enemy.type === 'soldier') {
                        // Military unit AI based on role
                        updateEnemySoldier(enemy);
                    }
                }

                // Update movement
                if (enemy.isMoving) {
                    const speed = enemy.speed;
                    const dx = enemy.targetX - enemy.x;
                    const dy = enemy.targetY - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < speed) {
                        enemy.x = enemy.targetX;
                        enemy.y = enemy.targetY;
                        enemy.isMoving = false;
                    } else {
                        const moveX = dx / distance * speed;
                        const moveY = dy / distance * speed;

                        enemy.x += moveX;
                        enemy.y += moveY;

                        // Update angle for rotation
                        enemy.angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    }
                }

                // Handle enemy gathering resources
                if (enemy.type === 'villager' && enemy.isGathering && !enemy.isMoving && !enemy.isReturningResources) {
                    processEnemyGathering(enemy);
                }

                // Handle enemy returning resources
                if (enemy.type === 'villager' && enemy.isReturningResources && !enemy.isMoving) {
                    // We've reached the drop-off building
                    if (enemy.dropOffBuilding) {
                        // Add resources to enemy's stockpile
                        if (enemy.carrying && enemy.carrying.type && enemy.carrying.amount > 0) {
                            gameState.enemyAI.resources[enemy.carrying.type] += enemy.carrying.amount;

                            // Create small particle effect for resource drop-off
                            if (!gameState.particles) gameState.particles = [];
                            for (let i = 0; i < 3; i++) {
                                gameState.particles.push({
                                    x: enemy.x + Math.random() * 20 - 10,
                                    y: enemy.y + Math.random() * 20 - 10,
                                    vx: Math.random() * 2 - 1,
                                    vy: Math.random() * -2,
                                    life: 15,
                                    type: 'dropoff',
                                    size: 3 + Math.random() * 3
                                });
                            }

                            // Reset carrying
                            enemy.carrying.amount = 0;
                            enemy.carrying.type = null;
                            enemy.isReturningResources = false;

                            // Return to previous gathering location if it exists
                            if (enemy.lastGatheringSpot && enemy.targetResource) {
                                enemy.targetX = enemy.lastGatheringSpot.x;
                                enemy.targetY = enemy.lastGatheringSpot.y;
                                enemy.isMoving = true;
                                enemy.isGathering = true;
                            }
                        }
                    } else {
                        // Find a new drop-off building
                        const nearestDropOff = findNearestEnemyDropOffBuilding(enemy);
                        if (nearestDropOff) {
                            enemy.dropOffBuilding = nearestDropOff;
                            enemy.targetX = nearestDropOff.x + nearestDropOff.width / 2;
                            enemy.targetY = nearestDropOff.y + nearestDropOff.height / 2;
                            enemy.isMoving = true;
                        } else {
                            // No drop-off buildings, just drop resources
                            enemy.carrying.amount = 0;
                            enemy.carrying.type = null;
                            enemy.isReturningResources = false;
                        }
                    }
                }

                // Handle enemy attacking
                if (enemy.isAttacking) {
                    let targetUnit = null;
                    let targetBuilding = null;
                    let targetDistance = Infinity;
                    let attackRange = 40;

                    // Check if targeting a unit
                    if (enemy.targetUnit) {
                        targetUnit = gameState.units.find(unit => unit.id === enemy.targetUnit);
                        if (targetUnit) {
                            targetDistance = Math.sqrt(
                                Math.pow(targetUnit.x - enemy.x, 2) + 
                                Math.pow(targetUnit.y - enemy.y, 2)
                            );
                        }
                    }

                    // Check if targeting a building
                    if (enemy.targetBuilding) {
                        targetBuilding = gameState.buildings.find(building => building.id === enemy.targetBuilding && !building.isEnemy);
                        if (targetBuilding) {
                            const centerX = targetBuilding.x + targetBuilding.width/2;
                            const centerY = targetBuilding.y + targetBuilding.height/2;
                            targetDistance = Math.sqrt(
                                Math.pow(centerX - enemy.x, 2) + 
                                Math.pow(centerY - enemy.y, 2)
                            );

                            // Buildings are larger, so use a longer attack range
                            attackRange = Math.max(40, targetBuilding.width/2);
                        }
                    }

                    // If we have a valid target and are close enough
                    if ((targetUnit || targetBuilding) && targetDistance < attackRange) {
                        enemy.isMoving = false;

                        // Attack once per second
                        if (!enemy.lastAttackTime || Date.now() - enemy.lastAttackTime > 1000) {
                            // Add attack animation
                            enemy.attackAngle = 30; // Start the attack swing
                            enemy.attackAnimationStart = Date.now();

                            // Play attack sound
                            playSound(gameState.unitSounds.sword, {x: enemy.x, y: enemy.y});

                            if (targetUnit) {
                                // Attacking a unit
                                targetUnit.hp -= enemy.attack;
                                enemy.lastAttackTime = Date.now();

                                // Create hit particles
                                if (!gameState.particles) gameState.particles = [];
                                for (let i = 0; i < 5; i++) {
                                    gameState.particles.push({
                                        x: targetUnit.x + targetUnit.width/2 + (Math.random() * 20 - 10),
                                        y: targetUnit.y + targetUnit.height/2 + (Math.random() * 20 - 10),
                                        vx: Math.random() * 2 - 1,
                                        vy: Math.random() * 2 - 1,
                                        life: 10,
                                        type: 'hit',
                                        size: 3 + Math.random() * 2
                                    });
                                }

                                // If unit is defeated
                                if (targetUnit.hp <= 0) {
                                    gameState.units = gameState.units.filter(u => u !== targetUnit);
                                    gameState.selectedEntities = gameState.selectedEntities.filter(e => e !== targetUnit);
                                    gameState.population--;
                                    populationElement.textContent = gameState.population;
                                    enemy.isAttacking = false;
                                    enemy.targetUnit = null;
                                }
                            } else if (targetBuilding) {
                                // Attacking a building
                                targetBuilding.hp -= enemy.attack;
                                enemy.lastAttackTime = Date.now();

                                // Mark building as under attack
                                targetBuilding.isUnderAttack = true;
                                targetBuilding.lastDamageTime = Date.now();

                                // Play building damage sound
                                playSound(gameState.unitSounds.buildingDamage, {x: targetBuilding.x, y: targetBuilding.y});

                                // Create hit particles
                                if (!gameState.particles) gameState.particles = [];
                                for (let i = 0; i < 8; i++) {
                                    gameState.particles.push({
                                        x: targetBuilding.x + Math.random() * targetBuilding.width,
                                        y: targetBuilding.y + Math.random() * targetBuilding.height,
                                        vx: Math.random() * 3 - 1.5,
                                        vy: Math.random() * 3 - 1.5,
                                        life: 15,
                                        type: 'buildingDamage',
                                        size: 4 + Math.random() * 3
                                    });
                                }

                                // If building is destroyed
                                if (targetBuilding.hp <= 0) {
                                    // If it's a house, reduce population cap
                                    if (targetBuilding.type === 'house') {
                                        gameState.populationCap -= 5;
                                        populationCapElement.textContent = gameState.populationCap;
                                    }

                                    // Create explosion effect
                                    for (let i = 0; i < 30; i++) {
                                        gameState.particles.push({
                                            x: targetBuilding.x + Math.random() * targetBuilding.width,
                                            y: targetBuilding.y + Math.random() * targetBuilding.height,
                                            vx: Math.random() * 5 - 2.5,
                                            vy: Math.random() * 5 - 2.5,
                                            life: 30 + Math.random() * 20,
                                            type: 'explosion',
                                            size: 5 + Math.random() * 5
                                        });
                                    }

                                    // Remove the building
                                    gameState.buildings = gameState.buildings.filter(b => b !== targetBuilding);
                                    gameState.selectedEntities = gameState.selectedEntities.filter(e => e !== targetBuilding);

                                    showNotification(`${targetBuilding.type.charAt(0).toUpperCase() + targetBuilding.type.slice(1)} has been destroyed!`);

                                    enemy.isAttacking = false;
                                    enemy.targetBuilding = null;

                                    // If enemy is in an attack force, report success
                                    if (enemy.aiRole === 'attacker') {
                                        // Potentially trigger more aggressive follow-up attack
                                        gameState.enemyAI.phase = 'attacking';
                                    }
                                }
                            }
                        } else if (enemy.attackAnimationStart) {
                            // Update attack animation
                            const animTime = Date.now() - enemy.attackAnimationStart;
                            if (animTime < 500) { // Animation lasts 500ms
                                // Swing animation: start at +30 degrees, end at -30 degrees
                                enemy.attackAngle = 30 - (animTime / 500 * 60);
                            } else {
                                // Reset animation
                                enemy.attackAngle = 0;
                                enemy.attackAnimationStart = null;
                            }
                        }
                    } else {
                        // Move towards target
                        if (targetUnit) {
                            enemy.targetX = targetUnit.x;
                            enemy.targetY = targetUnit.y;
                        } else if (targetBuilding) {
                            // Move towards building's center
                            enemy.targetX = targetBuilding.x + targetBuilding.width/2;
                            enemy.targetY = targetBuilding.y + targetBuilding.height/2;
                        } else {
                            // Target is gone, stop attacking
                            enemy.isAttacking = false;
                            enemy.targetUnit = null;
                            enemy.targetBuilding = null;
                        }
                        enemy.isMoving = true;
                    }
                }
            });

            // Update enemy AI decision making
            function updateEnemyAI(deltaTime) {
                const ai = gameState.enemyAI;

                // Only make decisions periodically to avoid excessive processing
                if (Date.now() - ai.lastDecisionTime < ai.decisionInterval) return;

                ai.lastDecisionTime = Date.now();

                // Update AI phase based on time
                if (ai.phase === 'gathering' && Date.now() > ai.nextPhaseTime) {
                    ai.phase = 'building';
                    ai.nextPhaseTime = Date.now() + 120000; // 2 minutes in building phase
                    console.log("Enemy AI phase change: building");
                } else if (ai.phase === 'building' && Date.now() > ai.nextPhaseTime) {
                    ai.phase = 'attacking';
                    console.log("Enemy AI phase change: attacking");
                }

                // Count current villagers and soldiers
                const villagerCount = gameState.enemies.filter(e => e.type === 'villager').length;
                const soldierCount = gameState.enemies.filter(e => e.type === 'soldier').length;

                // Determine if we need more units
                ai.needMoreVillagers = villagerCount < 8 && ai.population < ai.populationCap;
                ai.needMoreSoldiers = (ai.phase === 'building' || ai.phase === 'attacking') && 
                                     soldierCount < 10 && 
                                     ai.population < ai.populationCap;

                // Train new units if needed and resources allow
                if ((ai.needMoreVillagers || ai.needMoreSoldiers) && 
                    Date.now() - ai.lastTrainTime > 10000) { // Train at most every 10 seconds

                    const barracks = gameState.buildings.find(b => b.type === 'barracks' && b.isEnemy);

                    if (ai.needMoreVillagers && ai.resources.food >= 50) {
                        // Train villager at enemy base
                        const enemyBase = gameState.buildings.find(b => b.type === 'enemy-base');
                        if (enemyBase) {
                            ai.resources.food -= 50;
                            const villager = createUnit('villager', 
                                                      enemyBase.x + enemyBase.width + Math.random() * 50, 
                                                      enemyBase.y + enemyBase.height + Math.random() * 50, 
                                                      true);
                            gameState.enemies.push(villager);
                            ai.population++;

                            // Assign role based on current needs
                            const resourceCounts = Object.entries(ai.resources);
                            resourceCounts.sort((a, b) => a[1] - b[1]); // Sort by amount (ascending)
                            villager.aiRole = resourceCounts[0][0]; // Assign to gather the most needed resource

                            ai.lastTrainTime = Date.now();
                        }
                    } else if (ai.needMoreSoldiers && barracks && ai.resources.food >= 60 && ai.resources.gold >= 20) {
                        // Train soldier at barracks
                        ai.resources.food -= 60;
                        ai.resources.gold -= 20;
                        const soldier = createUnit('soldier',
                                                 barracks.x + barracks.width + Math.random() * 50,
                                                 barracks.y + barracks.height + Math.random() * 50,
                                                 true);
                        gameState.enemies.push(soldier);
                        ai.population++;

                        // Assign role based on current phase
                        if (ai.phase === 'attacking') {
                            soldier.aiRole = 'attacker';
                            ai.attackForce.push(soldier.id);
                        } else {
                            soldier.aiRole = 'defender';
                            ai.baseDefenders.push(soldier.id);
                        }

                        ai.lastTrainTime = Date.now();
                    }
                }

                // Execute attacks if in attack phase
                if (ai.phase === 'attacking') {
                    // Ensure we have a target
                    if (!ai.militaryTarget) {
                        // Find a player building to attack, prioritizing town center
                        const townCenter = gameState.buildings.find(b => b.type === 'town-center' && !b.isEnemy);
                        if (townCenter) {
                            ai.militaryTarget = {
                                id: townCenter.id,
                                x: townCenter.x + townCenter.width/2,
                                y: townCenter.y + townCenter.height/2,
                                isBuilding: true
                            };
                        } else {
                            // Find any player building
                            const playerBuilding = gameState.buildings.find(b => !b.isEnemy);
                            if (playerBuilding) {
                                ai.militaryTarget = {
                                    id: playerBuilding.id,
                                    x: playerBuilding.x + playerBuilding.width/2,
                                    y: playerBuilding.y + playerBuilding.height/2,
                                    isBuilding: true
                                };
                            } else {
                                // Fall back to attacking any player unit
                                const playerUnit = gameState.units[0];
                                if (playerUnit) {
                                    ai.militaryTarget = {
                                        id: playerUnit.id,
                                        x: playerUnit.x,
                                        y: playerUnit.y,
                                        isBuilding: false
                                    };
                                }
                            }
                        }
                    }

                    // If we have a target, send forces to attack
                    if (ai.militaryTarget) {
                        // Gather all soldiers and assign to attack force
                        gameState.enemies.forEach(enemy => {
                            if (enemy.type === 'soldier' && !enemy.isAttacking) {
                                enemy.aiRole = 'attacker';
                                if (!ai.attackForce.includes(enemy.id)) {
                                    ai.attackForce.push(enemy.id);
                                }
                            }
                        });

                        // Send attack force to target
                        ai.attackForce.forEach(soldierId => {
                            const soldier = gameState.enemies.find(e => e.id === soldierId);
                            if (soldier && !soldier.isAttacking) {
                                soldier.targetX = ai.militaryTarget.x;
                                soldier.targetY = ai.militaryTarget.y;
                                soldier.isMoving = true;

                                // Set attack target if close enough
                                const distance = Math.sqrt(
                                    Math.pow(soldier.x - ai.militaryTarget.x, 2) +
                                    Math.pow(soldier.y - ai.militaryTarget.y, 2)
                                );

                                if (distance < 300) { // If close enough to engage
                                    soldier.isAttacking = true;
                                    if (ai.militaryTarget.isBuilding) {
                                        soldier.targetBuilding = ai.militaryTarget.id;
                                    } else {
                                        soldier.targetUnit = ai.militaryTarget.id;
                                    }
                                }
                            }
                        });
                    }
                }
            }

            // Process enemy villager gathering
            function processEnemyGathering(villager) {
                // Find the closest resource of the target type
                const unitX = villager.x;
                const unitY = villager.y;
                const resourceType = villager.targetResource;

                let closestResource = null;
                let closestDistance = Infinity;

                gameState.resourceNodes.forEach(resource => {
                    if (resource.type === resourceType && resource.amount > 0) {
                        const resourceX = resource.x;
                        const resourceY = resource.y;
                        const distance = Math.sqrt(Math.pow(resourceX - unitX, 2) + Math.pow(resourceY - unitY, 2));

                        if (distance < closestDistance) {
                            closestResource = resource;
                            closestDistance = distance;
                        }
                    }
                });

                if (closestResource && closestDistance < 60) {
                    // Save this spot for returning later
                    villager.lastGatheringSpot = {
                        x: unitX,
                        y: unitY
                    };

                    // We're close enough to gather
                    const resourceAmount = closestResource.amount;

                    if (resourceAmount > 0) {
                        // Check if we're already full and need to return resources
                        if (villager.carrying && villager.carrying.amount >= gameState.villagerCapacity) {
                            // Find nearest drop-off point and return resources
                            const dropOffBuilding = findNearestEnemyDropOffBuilding(villager);
                            if (dropOffBuilding) {
                                villager.isReturningResources = true;
                                villager.isGathering = false;
                                villager.dropOffBuilding = dropOffBuilding;
                                villager.targetX = dropOffBuilding.x + dropOffBuilding.width / 2;
                                villager.targetY = dropOffBuilding.y + dropOffBuilding.height / 2;
                                villager.isMoving = true;
                                villager.gatherAngle = 0;
                                return; // Skip rest of gathering logic
                            } else {
                                villager.carrying.amount = 0; // Just reset carrying
                            }
                        }

                        // Gather resource at a slower rate (once per 10 ticks)
                        if (!villager.gatherTicks) {
                            villager.gatherTicks = 0;
                            villager.gatherAngle = 0;
                        }

                        villager.gatherTicks++;

                        // Create gathering animation based on resource type
                        if (resourceType === 'tree') {
                            villager.gatherAngle = 30 * Math.sin(villager.gatherTicks * 0.2);
                            const angle = Math.atan2(closestResource.y - unitY, closestResource.x - unitX);
                            villager.angle = angle * 180 / Math.PI;
                        } else if (resourceType === 'gold' || resourceType === 'stone') {
                            villager.gatherAngle = 15 * Math.sin(villager.gatherTicks * 0.3);
                            const angle = Math.atan2(closestResource.y - unitY, closestResource.x - unitX);
                            villager.angle = angle * 180 / Math.PI;
                        } else if (resourceType === 'berry') {
                            villager.gatherAngle = 5 * Math.sin(villager.gatherTicks * 0.4);
                            const angle = Math.atan2(closestResource.y - unitY, closestResource.x - unitX);
                            villager.angle = angle * 180 / Math.PI;
                        }

                        if (villager.gatherTicks >= 10) {
                            closestResource.amount -= 1;

                            // Add to villager's carrying amount
                            if (!villager.carrying) {
                                villager.carrying = {
                                    type: null,
                                    amount: 0
                                };
                            }

                            if (villager.carrying.type === null) {
                                // Start carrying this resource type
                                villager.carrying.type = mapResourceTypeToResource(resourceType);
                                villager.carrying.amount = 1;
                            } else if (villager.carrying.type === mapResourceTypeToResource(resourceType)) {
                                // Add to existing carried resource
                                villager.carrying.amount += 1;
                            }

                            villager.gatherTicks = 0;
                        }

                        // If resource is depleted, find a new one
                        if (closestResource.amount <= 0) {
                            gameState.resourceNodes = gameState.resourceNodes.filter(r => r !== closestResource);
                            villager.isGathering = false;
                            villager.gatherAngle = 0;

                            // If carrying resources, return to drop-off
                            if (villager.carrying && villager.carrying.amount > 0) {
                                const dropOffBuilding = findNearestEnemyDropOffBuilding(villager);
                                if (dropOffBuilding) {
                                    villager.isReturningResources = true;
                                    villager.dropOffBuilding = dropOffBuilding;
                                    villager.targetX = dropOffBuilding.x + dropOffBuilding.width / 2;
                                    villager.targetY = dropOffBuilding.y + dropOffBuilding.height / 2;
                                    villager.isMoving = true;
                                }
                            }
                        }
                    }
                } else if (closestResource) {
                    // Move closer to resource
                    villager.targetX = closestResource.x;
                    villager.targetY = closestResource.y;
                    villager.isMoving = true;
                } else {
                    // No resources of this type left, find a new resource type
                    villager.isGathering = false;
                    villager.gatherAngle = 0;

                    // Reassign to another resource
                    const resourceTypes = ['tree', 'berry', 'gold', 'stone'];
                    for (const type of resourceTypes) {
                        const resource = findNearestResourceOfType(villager, type, 1000);
                        if (resource) {
                            villager.targetResource = resource.type;
                            villager.targetX = resource.x;
                            villager.targetY = resource.y;
                            villager.isGathering = true;
                            villager.isMoving = true;
                            break;
                        }
                    }
                }
            }

            // Update enemy villager behavior
            function updateEnemyVillager(villager) {
                // If villager has a role but no task, assign one
                if (villager.aiRole && !villager.isGathering && !villager.isReturningResources) {
                    // Determine what resource to gather based on role
                    let resourceType;
                    switch(villager.aiRole) {
                        case 'food': resourceType = 'berry'; break;
                        case 'wood': resourceType = 'tree'; break;
                        case 'gold': resourceType = 'gold'; break;
                        case 'stone': resourceType = 'stone'; break;
                        default: resourceType = 'tree'; // Default to wood
                    }

                    // Find nearest resource of that type
                    const resource = findNearestResourceOfType(villager, resourceType, 1000);
                    if (resource) {
                        villager.targetResource = resource.type;
                        villager.targetX = resource.x;
                        villager.targetY = resource.y;
                        villager.isGathering = true;
                        villager.isMoving = true;
                    } else {
                        // If preferred resource not found, try any resource
                        const anyResource = findNearestResourceOfAnyType(villager, 1000);
                        if (anyResource) {
                            villager.targetResource = anyResource.type;
                            villager.targetX = anyResource.x;
                            villager.targetY = anyResource.y;
                            villager.isGathering = true;
                            villager.isMoving = true;
                        } else {
                            // No resources in range, move to a random point
                            villager.targetX = 2500 + (Math.random() * 400 - 200);
                            villager.targetY = 2500 + (Math.random() * 400 - 200);
                            villager.isMoving = true;
                        }
                    }
                }

                // Enemy villagers should defend themselves if attacked
                const nearbyPlayerUnit = findNearestPlayerUnit(villager, 100);
                if (nearbyPlayerUnit) {
                    villager.isGathering = false;
                    villager.isReturningResources = false;
                    villager.isAttacking = true;
                    // Only update the target position if the change is significant
                    if (Math.abs(nearbyPlayerUnit.x - villager.targetX) > 2 || Math.abs(nearbyPlayerUnit.y - villager.targetY) > 2) {
                        villager.targetUnit = nearbyPlayerUnit.id;
                        villager.targetX = nearbyPlayerUnit.x;
                        villager.targetY = nearbyPlayerUnit.y;
                    }
                    villager.isMoving = true;
                }
            }

            // Update enemy soldier behavior
            function updateEnemySoldier(soldier) {
                // Different behavior based on role
                if (soldier.aiRole === 'defender') {
                    // Defenders patrol around the base
                    if (Math.random() < 0.05) {
                        // Pick a random point near the enemy base to patrol
                        soldier.targetX = 2500 + (Math.random() * 300 - 150);
                        soldier.targetY = 2500 + (Math.random() * 300 - 150);
                        soldier.isMoving = true;
                    }

                    // Check for nearby player units to attack
                    const nearbyPlayerUnit = findNearestPlayerUnit(soldier, 200);
                    if (nearbyPlayerUnit) {
                        soldier.isAttacking = true;
                        soldier.targetUnit = nearbyPlayerUnit.id;
                        soldier.targetX = nearbyPlayerUnit.x;
                        soldier.targetY = nearbyPlayerUnit.y;
                        soldier.isMoving = true;
                    }
                } 
                else if (soldier.aiRole === 'attacker') {
                    // Attackers focus on attacking player buildings/units
                    if (!soldier.isAttacking) {
                        // If not already attacking, find a target
                        const target = findPlayerTarget(soldier);
                        if (target) {
                            if (target.type === 'unit') {
                                soldier.targetUnit = target.id;
                                soldier.targetBuilding = null;
                            } else {
                                soldier.targetBuilding = target.id;
                                soldier.targetUnit = null;
                            }
                            soldier.isAttacking = true;
                            soldier.targetX = target.x;
                            soldier.targetY = target.y;
                            soldier.isMoving = true;
                        } else {
                            // No target found, move toward player base
                            const townCenter = gameState.buildings.find(b => b.type === 'town-center' && !b.isEnemy);
                            if (townCenter) {
                                soldier.targetX = townCenter.x + townCenter.width/2;
                                soldier.targetY = townCenter.y + townCenter.height/2;
                                soldier.isMoving = true;
                            } else {
                                // Random movement if no town center
                                soldier.targetX = 1500 + (Math.random() * 400 - 200);
                                soldier.targetY = 1500 + (Math.random() * 400 - 200);
                                soldier.isMoving = true;
                            }
                        }
                    }
                }
                else if (soldier.aiRole === 'scout') {
                    // Scouts explore the map
                    if (!soldier.isMoving) {
                        // Move toward player base area
                        soldier.targetX = 1500 + (Math.random() * 600 - 300);
                        soldier.targetY = 1500 + (Math.random() * 600 - 300);
                        soldier.isMoving = true;
                    }

                    // If scout finds player buildings, report back
                    const playerBuilding = findNearestPlayerBuilding(soldier, 300);
                    if (playerBuilding && !gameState.enemyAI.discoveredPlayerBase) {
                        gameState.enemyAI.discoveredPlayerBase = true;
                        gameState.enemyAI.militaryTarget = {
                            id: playerBuilding.id,
                            x: playerBuilding.x + playerBuilding.width/2,
                            y: playerBuilding.y + playerBuilding.height/2,
                            isBuilding: true
                        };

                        // Accelerate attack phase
                        if (gameState.enemyAI.phase !== 'attacking') {
                            gameState.enemyAI.phase = 'building';
                            gameState.enemyAI.nextPhaseTime = Date.now() + 60000; // Attack in 1 minute
                        }
                    }
                }
            }

            // Helper functions for enemy AI
            function findNearestEnemyDropOffBuilding(unit) {
                if (!unit.carrying || !unit.carrying.type) return null;

                const resourceType = unit.carrying.type;
                let nearestBuilding = null;
                let nearestDistance = Infinity;

                gameState.buildings.forEach(building => {
                    if (!building.isEnemy) return;

                    // Check if building accepts this resource type
                    if (building.acceptsResources && building.acceptsResources.includes(resourceType)) {
                        const distance = Math.sqrt(
                            Math.pow(building.x + building.width/2 - unit.x, 2) + 
                            Math.pow(building.y + building.height/2 - unit.y, 2)
                        );

                        if (distance < nearestDistance) {
                            nearestBuilding = building;
                            nearestDistance = distance;
                        }
                    }
                });

                return nearestBuilding;
            }

            function findNearestResourceOfAnyType(unit, radius) {
                let nearestResource = null;
                let nearestDistance = radius;

                gameState.resourceNodes.forEach(resource => {
                    if (resource.amount > 0) {
                        const distance = Math.sqrt(
                            Math.pow(resource.x + resource.width/2 - unit.x, 2) + 
                            Math.pow(resource.y + resource.height/2 - unit.y, 2)
                        );

                        if (distance < nearestDistance) {
                            nearestResource = resource;
                            nearestDistance = distance;
                        }
                    }
                });

                return nearestResource;
            }

            function findNearestPlayerUnit(unit, radius) {
                let nearestUnit = null;
                let nearestDistance = radius;

                gameState.units.forEach(playerUnit => {
                    const distance = Math.sqrt(
                        Math.pow(playerUnit.x - unit.x, 2) + 
                        Math.pow(playerUnit.y - unit.y, 2)
                    );

                    if (distance < nearestDistance) {
                        nearestUnit = playerUnit;
                        nearestDistance = distance;
                    }
                });

                return nearestUnit;
            }

            function findNearestPlayerBuilding(unit, radius) {
                let nearestBuilding = null;
                let nearestDistance = radius;

                gameState.buildings.forEach(building => {
                    if (!building.isEnemy) {
                        const distance = Math.sqrt(
                            Math.pow(building.x + building.width/2 - unit.x, 2) + 
                            Math.pow(building.y + building.height/2 - unit.y, 2)
                        );

                        if (distance < nearestDistance) {
                            nearestBuilding = building;
                            nearestDistance = distance;
                        }
                    }
                });

                return nearestBuilding;
            }

            function findPlayerTarget(unit) {
                // First check for nearby player units
                const playerUnit = findNearestPlayerUnit(unit, 300);
                if (playerUnit) {
                    return {
                        id: playerUnit.id,
                        x: playerUnit.x,
                        y: playerUnit.y,
                        type: 'unit'
                    };
                }

                // Then check for player buildings
                const playerBuilding = findNearestPlayerBuilding(unit, 500);
                if (playerBuilding) {
                    return {
                        id: playerBuilding.id,
                        x: playerBuilding.x + playerBuilding.width/2,
                        y: playerBuilding.y + playerBuilding.height/2,
                        type: 'building'
                    };
                }

                return null;
            }
        }

        function updateResourcesDisplay() {
            foodCount.textContent = gameState.resources.food;
            woodCount.textContent = gameState.resources.wood;
            goldCount.textContent = gameState.resources.gold;
            stoneCount.textContent = gameState.resources.stone;
        }

        function updateActionPanel() {
            actionsPanel.innerHTML = '';

            if (gameState.selectedEntities.length === 0) {
                return;
            }

            const entity = gameState.selectedEntities[0];

            if (entity.type === 'villager') {
                // Villager actions
                const buildButton = document.createElement('div');
                buildButton.className = 'action-button';
                buildButton.textContent = `Build (${HOTKEYS.BUILD})`;
                buildButton.onclick = () => {
                    buildMenu.style.display = 'block';
                    trainMenu.style.display = 'none';
                };
                actionsPanel.appendChild(buildButton);
            } else if (entity.type === 'town-center') {
                // Town center actions
                const trainVillagerButton = document.createElement('div');
                trainVillagerButton.className = 'action-button';
                trainVillagerButton.textContent = `Train (${HOTKEYS.TRAIN})`;
                trainVillagerButton.onclick = () => {
                    buildMenu.style.display = 'none';
                    trainMenu.style.display = 'block';
                };
                actionsPanel.appendChild(trainVillagerButton);
            } else if (entity.type === 'barracks') {
                // Barracks actions
                const trainSoldierButton = document.createElement('div');
                trainSoldierButton.className = 'action-button';
                trainSoldierButton.textContent = `Train (${HOTKEYS.TRAIN})`;
                trainSoldierButton.onclick = () => {
                    handleTrainSoldier();
                };
                actionsPanel.appendChild(trainSoldierButton);
            }
        }

        function selectEntity(entity, addToSelection = false) {
            // If not adding to selection, clear previous selection
            if (!addToSelection) {
                gameState.selectedEntities = [];
            }

            // Add to selection if not already selected
            if (!gameState.selectedEntities.includes(entity)) {
                gameState.selectedEntities.push(entity);

                // Play selection sound for units
                if (entity.type === 'villager' || entity.type === 'soldier') {
                    playSound(gameState.unitSounds.select, {x: entity.x, y: entity.y});
                }
            }

            updateActionPanel();
        }

        function deselectAll() {
            gameState.selectedEntities = [];
            updateActionPanel();
            buildMenu.style.display = 'none';
            trainMenu.style.display = 'none';
        }

        function moveUnits(units, targetX, targetY) {
            units.forEach(unit => {
                if ((unit.type === 'villager' || unit.type === 'soldier') && !unit.isEnemy) {
                    // Skip if the unit was just created and the command is coming from gather point logic
                    // This prevents conflicts with the gather point system which uses setTimeout
                    if (unit.justCreated && !unit._fromUserCommand) {
                        // For debugging
                        console.log("Skipping move command for just created unit", unit.id);
                        return;
                    }

                    unit.targetX = targetX;
                    unit.targetY = targetY;
                    unit.isMoving = true;
                    unit.isGathering = false;
                    unit.targetResource = null;
                    unit.isAttacking = false;
                    unit.targetEnemy = null;
                    unit.isReturningResources = false; // Cancel any returns in progress
                    unit.pendingGatherResource = null; // Cancel any pending gathering

                    // Calculate angle for rotation
                    const dx = targetX - unit.x;
                    const dy = targetY - unit.y;
                    unit.angle = Math.atan2(dy, dx) * 180 / Math.PI;

                    // If carrying resources and moved far away, check if we should drop off first
                    if (unit.carrying && unit.carrying.amount > 0) {
                        // Find nearest drop-off point
                        const dropOffBuilding = findNearestDropOffBuilding(unit);
                        if (dropOffBuilding) {
                            // If drop-off is closer than the target, go there first
                            const distanceToDropOff = Math.sqrt(
                                Math.pow(dropOffBuilding.x + dropOffBuilding.width/2 - unit.x, 2) + 
                                Math.pow(dropOffBuilding.y + dropOffBuilding.height/2 - unit.y, 2)
                            );

                            const distanceToTarget = Math.sqrt(
                                Math.pow(targetX - unit.x, 2) + 
                                Math.pow(targetY - unit.y, 2)
                            );

                            // If the drop-off is significantly closer or we're at capacity
                            if (distanceToDropOff < distanceToTarget * 0.5 || unit.carrying.amount >= gameState.villagerCapacity) {
                                unit.isReturningResources = true;
                                unit.dropOffBuilding = dropOffBuilding;
                                unit.targetX = dropOffBuilding.x + dropOffBuilding.width / 2;
                                unit.targetY = dropOffBuilding.y + dropOffBuilding.height / 2;

                                // Remember where we wanted to go after dropping off
                                unit.afterDropOffTarget = {
                                    x: targetX,
                                    y: targetY
                                };
                            }
                        }
                    }
                }
            });

            // Play movement sound
            if (units.length > 0 && units[0]._fromUserCommand !== false) {
                // Use the position of the first unit as the sound source
                playSound(gameState.unitSounds.move, {x: units[0].x, y: units[0].y});
            }
        }

        function gatherResource(unit, resource, fromGatherPoint = false) {
            if (unit.type === 'villager') {
                // Skip if the unit was just created and the command is coming from gather point logic
                if (unit.justCreated && !fromGatherPoint) {
                    // For debugging
                    console.log("Skipping gather command for just created unit", unit.id);
                    return;
                }

                // Check if we're carrying a different resource type
                if (unit.carrying.amount > 0 && 
                    unit.carrying.type !== mapResourceTypeToResource(resource.type)) {
                    // Discard current resources when switching to a different resource type
                    showNotification(`Villager discarded ${unit.carrying.amount} ${unit.carrying.type}`);

                    // Create small particle effect for resource dropping
                    if (!gameState.particles) gameState.particles = [];
                    for (let i = 0; i < 5; i++) {
                        gameState.particles.push({
                            x: unit.x + Math.random() * 20 - 10,
                            y: unit.y + Math.random() * 20 - 10,
                            vx: Math.random() * 2 - 1,
                            vy: Math.random() * -2,
                            life: 15,
                            type: 'dropoff',
                            size: 3 + Math.random() * 3
                        });
                    }

                    // Reset carrying
                    unit.carrying.amount = 0;
                    unit.carrying.type = null;

                    // Play drop sound
                    playSound(gameState.buildingSounds.dropoff, {x: unit.x, y: unit.y});
                }

                unit.isGathering = true;
                unit.targetResource = resource.type;
                unit.resourceId = resource.id;
                unit.isReturningResources = false; // Cancel any returns in progress

                // Move to resource first
                unit.targetX = resource.x;
                unit.targetY = resource.y;
                unit.isMoving = true;

                // Flag for the move command to know if this came from user or system
                unit._fromUserCommand = !fromGatherPoint;

                // Create temporary highlight effect on the target
                if (!gameState.particles) gameState.particles = [];
                for (let i = 0; i < 8; i++) {
                    gameState.particles.push({
                        x: resource.x + Math.random() * resource.width,
                        y: resource.y + Math.random() * resource.height,
                        vx: Math.random() * 2 - 1,
                        vy: Math.random() * 2 - 1,
                        life: 20,
                        type: 'targetHighlight',
                        size: 3 + Math.random() * 3
                    });
                }

                // Play sound for user commands only
                if (!fromGatherPoint) {
                    playSound(gameState.unitSounds.move, {x: unit.x, y: unit.y});
                }
            }
        }

        // Helper function to map resource node type to resource type
        function mapResourceTypeToResource(nodeType) {
            if (nodeType === 'tree') return 'wood';
            if (nodeType === 'berry') return 'food';
            return nodeType; // gold and stone are the same
        }

        // Find the nearest building that can accept this resource type
        function findNearestDropOffBuilding(unit) {
            if (!unit.carrying.type) return null;

            const resourceType = unit.carrying.type;
            let nearestBuilding = null;
            let nearestDistance = Infinity;

            gameState.buildings.forEach(building => {
                if (building.isEnemy) return;

                // Check if building accepts this resource type
                if (building.acceptsResources && building.acceptsResources.includes(resourceType)) {
                    const distance = Math.sqrt(
                        Math.pow(building.x + building.width/2 - unit.x, 2) + 
                        Math.pow(building.y + building.height/2 - unit.y, 2)
                    );

                    if (distance < nearestDistance) {
                        nearestBuilding = building;
                        nearestDistance = distance;
                    }
                }
            });

            return nearestBuilding;
        }

        function attackEnemy(units, enemy, fromGatherPoint = false) {
            units.forEach(unit => {
                if ((unit.type === 'villager' || unit.type === 'soldier') && !unit.isEnemy) {
                    // Skip if the unit was just created and the command is coming from gather point logic
                    if (unit.justCreated && !fromGatherPoint) {
                        // For debugging
                        console.log("Skipping attack command for just created unit", unit.id);
                        return;
                    }

                    // Clear previous tasks
                    unit.isGathering = false;
                    unit.isBuilding = false;
                    unit.isReturningResources = false;

                    // Set attack properties
                    unit.targetX = enemy.x + (enemy.width ? enemy.width/2 : 0);
                    unit.targetY = enemy.y + (enemy.height ? enemy.height/2 : 0);
                    unit.isMoving = true;
                    unit.isAttacking = true;

                    // Flag for the move command to know if this came from user or system
                    unit._fromUserCommand = !fromGatherPoint;

                    // Determine if attacking a unit or building
                    if (enemy.type === 'soldier' || enemy.type === 'villager') {
                        unit.targetEnemy = enemy.id;
                        unit.targetBuilding = null;
                    } else {
                        // Attacking a building (including enemy base)
                        unit.targetBuilding = enemy.id;
                        unit.targetEnemy = null;

                        // Debug log for enemy base attack
                        console.log("Attacking building: ", enemy.type, enemy.id);
                    }
                }
            });

            // Play attack sound only for user commands
            if (units.length > 0 && !fromGatherPoint) {
                playSound(gameState.unitSounds.attack, {x: units[0].x, y: units[0].y});
                if (enemy.type === 'enemy-base') {
                    showNotification("Attacking enemy base!");
                }
            }
        }

        function buildStructure(type, x, y) {
            // Check if we have enough resources
            let canBuild = false;
            let cost = 0;

            if (type === 'house' && gameState.resources.wood >= 30) {
                gameState.resources.wood -= 30;
                cost = 30;
                canBuild = true;
            } else if (type === 'barracks' && gameState.resources.wood >= 125) {
                gameState.resources.wood -= 125;
                cost = 125;
                canBuild = true;
            } else if ((type === 'lumber-camp' || type === 'mining-camp' || type === 'mill') && gameState.resources.wood >= 70) {
                gameState.resources.wood -= 70;
                cost = 70;
                canBuild = true;
            } else if (type === 'guard-tower' && gameState.resources.wood >= 50 && gameState.resources.stone >= 100) {
                gameState.resources.wood -= 50;
                gameState.resources.stone -= 100;
                cost = { wood: 50, stone: 100 };
                canBuild = true;
            }

            if (canBuild) {
                // Create a foundation that needs to be built
                const foundation = createBuildingFoundation(type, x, y, cost);

                // Assign all selected villagers to build it
                let buildersAssigned = 0;
                const selectedVillagers = gameState.selectedEntities.filter(entity => entity.type === 'villager');

                if (selectedVillagers.length > 0) {
                    // Assign all selected villagers to build
                    selectedVillagers.forEach(villager => {
                        assignVillagerToBuild(villager, foundation);
                        buildersAssigned++;
                    });

                    if (buildersAssigned > 0) {
                        showNotification(`${buildersAssigned} villagers assigned to construction`);
                    }
                }

                if (buildersAssigned === 0) {
                    // Find the closest idle villager if no villagers were selected
                    let closestVillager = null;
                    let closestDistance = 300; // Max distance to auto-assign

                    for (const villager of gameState.units) {
                        if (villager.type === 'villager' && !villager.isGathering && !villager.isBuilding) {
                            const distance = Math.sqrt(
                                Math.pow(villager.x - (x + 30), 2) + 
                                Math.pow(villager.y - (y + 30), 2)
                            );

                            if (distance < closestDistance) {
                                closestVillager = villager;
                                closestDistance = distance;
                            }
                        }
                    }

                    if (closestVillager) {
                        assignVillagerToBuild(closestVillager, foundation);
                        showNotification("Closest idle villager assigned to construction");
                    } else {
                        showNotification("No villagers available to build. Select a villager and right-click on the foundation.");
                    }
                }

                updateResourcesDisplay();

                // Play building sound
                playSound(gameState.buildingSounds.start, {x: x, y: y});

                return true;
            } else {
                showNotification("Not enough resources to build " + type);
                return false;
            }
        }

        function playSound(soundUrl, position = null) {
            if (gameState.sounds[soundUrl]) {
                try {
                    // Clone the audio to allow overlapping sounds
                    const sound = gameState.sounds[soundUrl].cloneNode();

                    // Base volume - increased for gathering sounds to be more noticeable
                    let volume = 0.4;

                    // Apply distance-based volume if position is provided
                    if (position) {
                        // Check if sound source is in or near viewport
                        const isInView = 
                            position.x + 200 > gameState.camera.x && 
                            position.x - 200 < gameState.camera.x + canvas.width && 
                            position.y + 200 > gameState.camera.y && 
                            position.y - 200 < gameState.camera.y + canvas.height;

                        if (isInView) {
                            // Calculate distance from center of viewport
                            const viewportCenterX = gameState.camera.x + canvas.width / 2;
                            const viewportCenterY = gameState.camera.y + canvas.height / 2;
                            const distance = Math.sqrt(
                                Math.pow(position.x - viewportCenterX, 2) + 
                                Math.pow(position.y - viewportCenterY, 2)
                            );

                            // Normalize distance (0-1 range where 0 is center, 1 is edge of view)
                            const maxDistance = Math.sqrt(Math.pow(canvas.width/2, 2) + Math.pow(canvas.height/2, 2));
                            const normalizedDistance = Math.min(1, distance / maxDistance);

                            // Adjust volume based on distance (closer = louder)
                            // Reduced distance falloff to make sounds more audible
                            volume = 0.6 * (1 - normalizedDistance * 0.5);

                            // Special case for gathering sounds - make them louder
                            if (soundUrl.includes('chopping') || 
                                soundUrl.includes('pickaxe') || 
                                soundUrl.includes('berries')) {
                                volume *= 1.5; // Boost gathering sounds
                            }
                        } else {
                            // If not in view, make very quiet but not silent
                            volume = 0.1;
                        }
                    }

                    sound.volume = Math.min(1.0, volume); // Cap at 1.0

                    // Only play sounds that are audible
                    if (volume > 0.05) {
                        sound.play().catch(e => {
                            console.log("Sound play prevented:", e);
                            // Create silent audio as fallback when sound fails to play
                            if (window.AudioContext || window.webkitAudioContext) {
                                try {
                                    const context = new (window.AudioContext || window.webkitAudioContext)();
                                    const source = context.createBufferSource();
                                    source.connect(context.destination);
                                    source.start(0);
                                } catch (err) {
                                    console.log("Silent audio fallback failed:", err);
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.log("Error playing sound:", error);
                }
            } else if (soundUrl) {
                // If sound isn't loaded yet, try to load it
                const audio = new Audio();
                audio.src = soundUrl;
                gameState.sounds[soundUrl] = audio;

                // Try to play after loading
                audio.addEventListener('canplaythrough', () => {
                    playSound(soundUrl, position);
                });

                // Force load attempt
                audio.load();
            }
        }

        // Convert screen coordinates to world coordinates
        function screenToWorld(screenX, screenY) {
            return {
                x: screenX + gameState.camera.x,
                y: screenY + gameState.camera.y
            };
        }

        // Check if a point is inside an entity
        function isPointInEntity(x, y, entity) {
            return x >= entity.x && 
                   x <= entity.x + entity.width && 
                   y >= entity.y && 
                   y <= entity.y + entity.height;
        }

        // Find entity at point
        function getEntityAtPoint(x, y) {
            // Check units first (they're on top)
            for (const unit of gameState.units) {
                if (isPointInEntity(x, y, unit)) {
                    return unit;
                }
            }

            // Check enemy units
            for (const enemy of gameState.enemies) {
                if (isPointInEntity(x, y, enemy)) {
                    return enemy;
                }
            }

            // Check buildings
            for (const building of gameState.buildings) {
                if (isPointInEntity(x, y, building)) {
                    return building;
                }
            }

            // Check resources
            for (const resource of gameState.resourceNodes) {
                if (isPointInEntity(x, y, resource)) {
                    return resource;
                }
            }

            return null;
        }

        // Find the nearest incomplete building within a certain radius
        function findNearestIncompleteBuilding(unit, radius) {
            let nearestBuilding = null;
            let nearestDistance = radius;

            gameState.buildings.forEach(building => {
                if (!building.isEnemy && building.isFoundation && !building.isComplete) {
                    const distance = Math.sqrt(
                        Math.pow(building.x + building.width/2 - unit.x, 2) + 
                        Math.pow(building.y + building.height/2 - unit.y, 2)
                    );

                    if (distance < nearestDistance) {
                        nearestBuilding = building;
                        nearestDistance = distance;
                    }
                }
            });

            return nearestBuilding;
        }

        // Find the nearest resource of a specific type within a certain radius
        function findNearestResourceOfType(unit, resourceType, radius) {
            let nearestResource = null;
            let nearestDistance = radius;

            gameState.resourceNodes.forEach(resource => {
                if (resource.type === resourceType && resource.amount > 0) {
                    const distance = Math.sqrt(
                        Math.pow(resource.x + resource.width/2 - unit.x, 2) + 
                        Math.pow(resource.y + resource.height/2 - unit.y, 2)
                    );

                    if (distance < nearestDistance) {
                        nearestResource = resource;
                        nearestDistance = distance;
                    }
                }
            });

            return nearestResource;
        }

        // Function to apply gather point to a soldier
        function applyGatherPointToSoldier(building, soldier) {
            const gatherX = building.gatherPoint.x;
            const gatherY = building.gatherPoint.y;

            // Check if gather point has a target
            if (building.gatherPoint.target) {
                // Find the target entity
                let targetEntity = null;

                // Check enemy units
                gameState.enemies.forEach(enemy => {
                    if (enemy.id === building.gatherPoint.target) {
                        targetEntity = enemy;
                    }
                });

                // Check enemy buildings
                if (!targetEntity) {
                    gameState.buildings.forEach(bldg => {
                        if (bldg.id === building.gatherPoint.target && bldg.isEnemy) {
                            targetEntity = bldg;
                        }
                    });
                }

                if (targetEntity) {
                    // Send soldier to attack target - use setTimeout to ensure unit is fully created first
                    setTimeout(() => {
                        soldier._fromUserCommand = false;
                        attackEnemy([soldier], targetEntity, true);
                    }, 50);
                } else {
                    // Target may have been destroyed, just move to gather point
                    setTimeout(() => {
                        soldier._fromUserCommand = true;
                        moveUnits([soldier], gatherX, gatherY);
                    }, 50);
                }
            } else {
                // No target, just move to gather point
                setTimeout(() => {
                    soldier._fromUserCommand = true;
                    moveUnits([soldier], gatherX, gatherY);
                }, 50);
            }
        }

        // Function to apply gather point to a villager
        function applyGatherPointToVillager(building, villager) {
            const gatherX = building.gatherPoint.x;
            const gatherY = building.gatherPoint.y;

            // Check if gather point has a target
            if (building.gatherPoint.target) {
                // Find the target entity
                let targetEntity = null;

                // Check resources
                gameState.resourceNodes.forEach(resource => {
                    if (resource.id === building.gatherPoint.target) {
                        targetEntity = resource;
                    }
                });

                if (targetEntity) {
                    // Send villager to gather resource - use setTimeout to ensure unit is fully created first
                    setTimeout(() => {
                        gatherResource(villager, targetEntity, true);
                    }, 50);
                } else {
                    // Target may have been destroyed, just move to gather point
                    setTimeout(() => {
                        villager._fromUserCommand = true;
                        moveUnits([villager], gatherX, gatherY);
                    }, 50);
                }
            } else {
                // No target, just move to gather point
                setTimeout(() => {
                    villager._fromUserCommand = true;
                    moveUnits([villager], gatherX, gatherY);
                }, 50);
            }
        }

        function completeBuilding(building) {
            // Mark as complete
            building.isComplete = true;
            building.isFoundation = false;

            // Update building properties
            building.acceptsResources = getAcceptedResources(building.type);

            // Get list of builders before reassigning them
            const builders = building.builders.map(builderId => 
                gameState.units.find(unit => unit.id === builderId)
            ).filter(builder => builder !== undefined);

            // Clear builder list
            building.builders = [];

            // Update population cap for houses
            if (building.type === 'house') {
                gameState.populationCap += 5;
                populationCapElement.textContent = gameState.populationCap;
            }

            // Play building completion sound
            playSound(gameState.buildingSounds.complete, {x: building.x, y: building.y});

            // Show notification
            showNotification(`${building.type.charAt(0).toUpperCase() + building.type.slice(1)} construction complete!`);

            // Create completion particles
            if (!gameState.particles) gameState.particles = [];
            for (let i = 0; i < 15; i++) {
                gameState.particles.push({
                    x: building.x + Math.random() * building.width,
                    y: building.y + Math.random() * building.height,
                    vx: Math.random() * 2 - 1,
                    vy: -Math.random() * 2 - 1,
                    life: 30,
                    type: 'completion',
                    size: 3 + Math.random() * 3
                });
            }

            // Reassign builders to new tasks
            builders.forEach(builder => {
                if (builder) {
                    // Reset building state
                    builder.isBuilding = false;
                    builder.targetBuilding = null;
                    builder.buildAngle = 0;

                    // Find next incomplete building within 300px radius
                    const nearbyIncompleteBuilding = findNearestIncompleteBuilding(builder, 300);

                    if (nearbyIncompleteBuilding) {
                        // Assign to next building
                        assignVillagerToBuild(builder, nearbyIncompleteBuilding);
                    } else {
                        // No more buildings to construct, try to gather resources based on completed building type
                        const completedBuildingType = building.type;
                        let resourceToGather = null;

                        // Determine what resource to gather based on the building type
                        if (completedBuildingType === 'lumber-camp') {
                            resourceToGather = 'tree';
                        } else if (completedBuildingType === 'mining-camp') {
                            resourceToGather = Math.random() < 0.5 ? 'gold' : 'stone';
                        } else if (completedBuildingType === 'mill') {
                            resourceToGather = 'berry';
                        }

                        // If we determined a resource type, find the nearest of that type
                        if (resourceToGather) {
                            const nearestResource = findNearestResourceOfType(builder, resourceToGather, 200);
                            if (nearestResource) {
                                gatherResource(builder, nearestResource);
                            }
                        }
                    }
                }
            });
        }

        // Get entities in selection box
        function getEntitiesInBox(left, top, right, bottom) {
            const entities = [];

            // Convert screen to world coordinates
            const worldLeft = left + gameState.camera.x;
            const worldTop = top + gameState.camera.y;
            const worldRight = right + gameState.camera.x;
            const worldBottom = bottom + gameState.camera.y;

            // Check units
            for (const unit of gameState.units) {
                if (unit.x + unit.width > worldLeft && 
                    unit.x < worldRight && 
                    unit.y + unit.height > worldTop && 
                    unit.y < worldBottom) {
                    entities.push(unit);
                }
            }

            // Check buildings (only if no units selected)
            if (entities.length === 0) {
                for (const building of gameState.buildings) {
                    if (!building.isEnemy &&
                        building.x + building.width > worldLeft && 
                        building.x < worldRight && 
                        building.y + building.height > worldTop && 
                        building.y < worldBottom) {
                        entities.push(building);
                    }
                }
            }

            return entities;
        }

        // Function to select all units of the same type visible on screen
        function selectAllUnitsOfType(type) {
            // Clear current selection
            deselectAll();

            // Get visible area in world coordinates
            const visibleLeft = gameState.camera.x;
            const visibleTop = gameState.camera.y;
            const visibleRight = visibleLeft + canvas.width;
            const visibleBottom = visibleTop + canvas.height;

            // Find all visible units of the specified type
            const unitsToSelect = gameState.units.filter(unit => 
                unit.type === type && 
                !unit.isEnemy &&
                unit.x + unit.width > visibleLeft && 
                unit.x < visibleRight && 
                unit.y + unit.height > visibleTop && 
                unit.y < visibleBottom
            );

            // Select all matching units
            unitsToSelect.forEach(unit => {
                gameState.selectedEntities.push(unit);
            });

            // Play selection sound if any units were selected
            if (unitsToSelect.length > 0) {
                playSound(gameState.unitSounds.select);
                showNotification(`Selected ${unitsToSelect.length} ${type}s`);
            }

            updateActionPanel();
        }

        // Function to update tower attacks
        function updateTowers(deltaTime) {
            // Process all guard towers
            gameState.buildings.forEach(building => {
                if (building.type === 'guard-tower' && building.isComplete && !building.isEnemy) {
                    // Only attack when cooldown is complete
                    const cooldown = building.attackCooldown || 2000;
                    if (!building.lastAttackTime || Date.now() - building.lastAttackTime > cooldown) {
                        // Find closest enemy within range
                        let closestEnemy = null;
                        let closestDistance = building.attackRange;

                        // Check both enemy units and buildings
                        gameState.enemies.forEach(enemy => {
                            const distance = Math.sqrt(
                                Math.pow((building.x + building.width/2) - (enemy.x + enemy.width/2), 2) + 
                                Math.pow((building.y + building.height/2) - (enemy.y + enemy.height/2), 2)
                            );

                            if (distance < closestDistance) {
                                closestEnemy = enemy;
                                closestDistance = distance;
                            }
                        });

                        // Also check enemy buildings
                        gameState.buildings.forEach(enemyBuilding => {
                            if (enemyBuilding.isEnemy) {
                                const distance = Math.sqrt(
                                    Math.pow((building.x + building.width/2) - (enemyBuilding.x + enemyBuilding.width/2), 2) + 
                                    Math.pow((building.y + building.height/2) - (enemyBuilding.y + enemyBuilding.height/2), 2)
                                );

                                if (distance < closestDistance) {
                                    closestEnemy = enemyBuilding;
                                    closestDistance = distance;
                                }
                            }
                        });

                        // If enemy found, shoot an arrow
                        if (closestEnemy) {
                            console.log("Tower shooting at enemy:", closestEnemy.type);

                            // Create arrow projectile
                            const startX = building.x + building.width/2;
                            const startY = building.y + building.height/2;
                            const targetX = closestEnemy.x + closestEnemy.width/2;
                            const targetY = closestEnemy.y + closestEnemy.height/2;

                            // Calculate angle for arrow rotation
                            const angle = Math.atan2(targetY - startY, targetX - startX);

                            // Create projectile
                            gameState.projectiles.push({
                                id: generateEntityId(),
                                type: 'arrow',
                                x: startX,
                                y: startY,
                                targetX: targetX,
                                targetY: targetY,
                                angle: angle,
                                speed: 8,
                                damage: building.attackDamage,
                                width: 20,
                                height: 10,
                                sourceId: building.id,
                                targetId: closestEnemy.id,
                                sourceX: startX,
                                sourceY: startY
                            });

                            // Play arrow sound
                            playSound('https://sounds.fuzzycode.dev/sound_effect?prompt=bow%20arrow%20shot&duration=0.5&ext=.mp3', {x: startX, y: startY});

                            building.lastAttackTime = Date.now();
                        }
                    }
                }
            });
        }

        // Function to update projectiles
        function updateProjectiles(deltaTime) {
            // Update each projectile
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const projectile = gameState.projectiles[i];

                // Move projectile
                const dx = Math.cos(projectile.angle) * projectile.speed;
                const dy = Math.sin(projectile.angle) * projectile.speed;

                projectile.x += dx;
                projectile.y += dy;

                // Check if target still exists
                let targetEntity = null;

                // Check enemy units
                for (const enemy of gameState.enemies) {
                    if (enemy.id === projectile.targetId) {
                        targetEntity = enemy;
                        break;
                    }
                }

                // Check enemy buildings if not found
                if (!targetEntity) {
                    for (const building of gameState.buildings) {
                        if (building.id === projectile.targetId && building.isEnemy) {
                            targetEntity = building;
                            break;
                        }
                    }
                }

                // Check for collision with target
                if (targetEntity) {
                    const hitBoxX = targetEntity.x;
                    const hitBoxY = targetEntity.y;
                    const hitBoxWidth = targetEntity.width || 30;
                    const hitBoxHeight = targetEntity.height || 30;

                    if (projectile.x >= hitBoxX && 
                        projectile.x <= hitBoxX + hitBoxWidth && 
                        projectile.y >= hitBoxY && 
                        projectile.y <= hitBoxY + hitBoxHeight) {

                        // Apply damage to target
                        targetEntity.hp -= projectile.damage;

                        // Mark building as under attack if applicable
                        if (targetEntity.type !== 'soldier' && targetEntity.type !== 'villager') {
                            targetEntity.isUnderAttack = true;
                            targetEntity.lastDamageTime = Date.now();
                        }

                        // Create hit particles
                        if (!gameState.particles) gameState.particles = [];
                        for (let j = 0; j < 5; j++) {
                            gameState.particles.push({
                                x: projectile.x,
                                y: projectile.y,
                                vx: Math.random() * 2 - 1,
                                vy: Math.random() * 2 - 1,
                                life: 10,
                                type: 'hit',
                                size: 3 + Math.random() * 2
                            });
                        }

                        // Play hit sound
                        playSound('https://sounds.fuzzycode.dev/sound_effect?prompt=arrow%20hit%20impact&duration=0.5&ext=.mp3', {x: projectile.x, y: projectile.y});

                        // Check if target is defeated
                        if (targetEntity.hp <= 0) {
                            if (targetEntity.type === 'soldier' || targetEntity.type === 'villager') {
                                gameState.enemies = gameState.enemies.filter(e => e !== targetEntity);
                                console.log("Enemy unit killed by tower arrow");

                                // Check if all enemies are defeated
                                checkVictoryCondition();
                            } else {
                                // Handle building destruction
                                gameState.buildings = gameState.buildings.filter(b => b !== targetEntity);
                                console.log("Enemy building destroyed by tower arrow");

                                // Create explosion effect
                                for (let i = 0; i < 30; i++) {
                                    gameState.particles.push({
                                        x: targetEntity.x + Math.random() * targetEntity.width,
                                        y: targetEntity.y + Math.random() * targetEntity.height,
                                        vx: Math.random() * 5 - 2.5,
                                        vy: Math.random() * 5 - 2.5,
                                        life: 30 + Math.random() * 20,
                                        type: 'explosion',
                                        size: 5 + Math.random() * 5
                                    });
                                }

                                if (targetEntity.type === 'enemy-base') {
                                    showNotification("Victory! Enemy base destroyed!");

                                    // Check if all enemies are defeated
                                    checkVictoryCondition();
                                }
                            }
                        }

                        // Remove the projectile
                        gameState.projectiles.splice(i, 1);
                        continue;
                    }
                }

                // Check if projectile is out of bounds or too far
                const maxDistance = 1000; // Maximum travel distance
                const distanceTraveled = Math.sqrt(
                    Math.pow(projectile.x - (projectile.sourceX || 0), 2) + 
                    Math.pow(projectile.y - (projectile.sourceY || 0), 2)
                );

                if (projectile.x < 0 || projectile.x > gameState.mapSize.width || 
                    projectile.y < 0 || projectile.y > gameState.mapSize.height ||
                    distanceTraveled > maxDistance) {
                    gameState.projectiles.splice(i, 1);
                }
            }
        }

        // Function to draw projectiles
        function drawProjectiles() {
            gameState.projectiles.forEach(projectile => {
                if (isInViewport({
                    x: projectile.x - 10,
                    y: projectile.y - 10,
                    width: 20,
                    height: 20
                })) {
                    // Save context for rotation
                    ctx.save();

                    // Translate to projectile position
                    ctx.translate(
                        projectile.x - gameState.camera.x,
                        projectile.y - gameState.camera.y
                    );

                    // Rotate to match projectile angle
                    ctx.rotate(projectile.angle);

                    // Draw projectile
                    ctx.drawImage(
                        gameState.images['arrow'],
                        -projectile.width/2,
                        -projectile.height/2,
                        projectile.width,
                        projectile.height
                    );

                    // Restore context
                    ctx.restore();
                }
            });
        }

        // Draw particles for resource gathering effects
        function drawParticles() {
            if (!gameState.particles) return;

            ctx.save();
            gameState.particles.forEach((particle, index) => {
                // Update particle position
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;

                // Apply gravity to some particle types
                if (particle.type === 'woodchip' || particle.type === 'dust' || particle.type === 'construction') {
                    particle.vy += 0.1;
                }

                // Only draw if in viewport and still alive
                if (particle.life > 0 && 
                    particle.x > gameState.camera.x && 
                    particle.x < gameState.camera.x + canvas.width &&
                    particle.y > gameState.camera.y && 
                    particle.y < gameState.camera.y + canvas.height) {

                    // Fade out as life decreases
                    const alpha = Math.min(1, particle.life / 10);

                    if (particle.type === 'woodchip') {
                        ctx.fillStyle = `rgba(139, 69, 19, ${alpha})`;
                        ctx.fillRect(
                            particle.x - gameState.camera.x, 
                            particle.y - gameState.camera.y, 
                            particle.size, 
                            particle.size
                        );
                    } else if (particle.type === 'goldspark') {
                        ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(
                            particle.x - gameState.camera.x,
                            particle.y - gameState.camera.y,
                            particle.size / 2,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (particle.type === 'dust') {
                        ctx.fillStyle = `rgba(169, 169, 169, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(
                            particle.x - gameState.camera.x,
                            particle.y - gameState.camera.y,
                            particle.size / 2,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (particle.type === 'dropoff') {
                        // Resource dropoff particles
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(
                            particle.x - gameState.camera.x,
                            particle.y - gameState.camera.y,
                            particle.size / 2,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (particle.type === 'construction') {
                        // Construction dust particles
                        ctx.fillStyle = `rgba(222, 184, 135, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(
                            particle.x - gameState.camera.x,
                            particle.y - gameState.camera.y,
                            particle.size / 2,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (particle.type === 'hit') {
                        // Combat hit particles
                        ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(
                            particle.x - gameState.camera.x,
                            particle.y - gameState.camera.y,
                            particle.size / 2,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (particle.type === 'buildingDamage') {
                        // Building damage particles (chunks)
                        ctx.fillStyle = `rgba(150, 75, 0, ${alpha})`;
                        ctx.fillRect(
                            particle.x - gameState.camera.x, 
                            particle.y - gameState.camera.y, 
                            particle.size, 
                            particle.size
                        );
                    } else if (particle.type === 'smoke') {
                        // Smoke particles for building damage
                        const smokeAlpha = alpha * 0.7;
                        ctx.fillStyle = `rgba(100, 100, 100, ${smokeAlpha})`;
                        ctx.beginPath();
                        // Ensure radius is always positive by using Math.max
                        const radius = Math.max(0.5, particle.size * Math.max(0, 20 - particle.life) / 15);
                        ctx.arc(
                            particle.x - gameState.camera.x,
                            particle.y - gameState.camera.y,
                            radius, // Use calculated radius with safeguard
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (particle.type === 'explosion') {
                        // Explosion particles for building destruction
                        const explosionColor = particle.life > 20 ? 
                            `rgba(255, ${100 + Math.floor(Math.random() * 155)}, 0, ${alpha})` : 
                            `rgba(100, 100, 100, ${alpha * 0.8})`;

                        ctx.fillStyle = explosionColor;
                        ctx.beginPath();
                        ctx.arc(
                            particle.x - gameState.camera.x,
                            particle.y - gameState.camera.y,
                            particle.size * (1 + (30 - particle.life) / 30), // Grow as they dissipate
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (particle.type === 'completion') {
                        // Building completion particles (sparkles)
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;

                        // Draw a star/sparkle
                        const size = particle.size;
                        const x = particle.x - gameState.camera.x;
                        const y = particle.y - gameState.camera.y;

                        ctx.beginPath();
                        ctx.moveTo(x, y - size);
                        ctx.lineTo(x + size/4, y - size/4);
                        ctx.lineTo(x + size, y);
                        ctx.lineTo(x + size/4, y + size/4);
                        ctx.lineTo(x, y + size);
                        ctx.lineTo(x - size/4, y + size/4);
                        ctx.lineTo(x - size, y);
                        ctx.lineTo(x - size/4, y - size/4);
                        ctx.closePath();
                        ctx.fill();
                    } else if (particle.type === 'targetHighlight') {
                        // Target highlight effect (pulsing circle)
                        const pulseSize = particle.size * (1 + Math.sin(particle.life * 0.3) * 0.3);
                        ctx.strokeStyle = `rgba(255, 255, 100, ${alpha})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(
                            particle.x - gameState.camera.x,
                            particle.y - gameState.camera.y,
                            pulseSize,
                            0,
                            Math.PI * 2
                        );
                        ctx.stroke();
                    }
                }

                // Remove dead particles
                if (particle.life <= 0) {
                    gameState.particles.splice(index, 1);
                }
            });
            ctx.restore();
        }

        // Game loop
        function gameLoop(timestamp) {
            if (!gameState.gameStarted) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // Calculate delta time
            if (!gameState.lastFrameTime) {
                gameState.lastFrameTime = timestamp;
            }
            const deltaTime = timestamp - gameState.lastFrameTime;
            gameState.lastFrameTime = timestamp;

            // Calculate FPS
            gameState.fps = 1000 / deltaTime;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Ensure projectiles array exists
            if (!gameState.projectiles) {
                gameState.projectiles = [];
            }

            // Update game state
            updateUnits(deltaTime);
            updateTowers(deltaTime);
            updateProjectiles(deltaTime);

            // Handle edge scrolling
            if (gameState.edgeScrolling && gameState.mousePosition && !gameState.buildingMode && !gameState.minimapDragging) {
                const margin = gameState.edgeScrollMargin;
                const speed = gameState.edgeScrollSpeed;

                // Check if mouse is near minimap area (with buffer)
                const minimapRect = document.getElementById('minimap').getBoundingClientRect();
                const minimapBuffer = 30; // Buffer zone around minimap in pixels
                const isNearMinimap = 
                    gameState.mousePosition.x >= minimapRect.left - minimapBuffer && 
                    gameState.mousePosition.x <= minimapRect.right + minimapBuffer && 
                    gameState.mousePosition.y >= minimapRect.top - minimapBuffer && 
                    gameState.mousePosition.y <= minimapRect.bottom + minimapBuffer;

                // Get HUD position
                const hudRect = document.getElementById('hud').getBoundingClientRect();
                const isInHudArea = 
                    gameState.mousePosition.y >= hudRect.top && 
                    gameState.mousePosition.y <= hudRect.bottom;

                // Only apply edge scrolling if not near minimap and not in HUD
                if (!isNearMinimap && !isInHudArea) {
                    // Check if mouse is near any edge
                    if (gameState.mousePosition.x < margin) {
                        // Left edge - scroll left
                        gameState.camera.x = Math.max(0, gameState.camera.x - speed * deltaTime / 16);
                    } else if (gameState.mousePosition.x > canvas.width - margin) {
                        // Right edge - scroll right
                        gameState.camera.x = Math.min(gameState.mapSize.width - canvas.width, gameState.camera.x + speed * deltaTime / 16);
                    }

                    if (gameState.mousePosition.y < margin) {
                        // Top edge - scroll up
                        gameState.camera.y = Math.max(0, gameState.camera.y - speed * deltaTime / 16);
                    } else if (gameState.mousePosition.y > canvas.height - margin) {
                        // Bottom edge - scroll down (only if below the HUD area)
                        if (gameState.mousePosition.y > hudRect.bottom) {
                            gameState.camera.y = Math.min(gameState.mapSize.height - canvas.height, gameState.camera.y + speed * deltaTime / 16);
                        }
                    }
                }
            }

            // Continue any camera animations if needed
            if (!gameState.minimapDragging && gameState.cameraLerpTarget) {
                const lerpSpeed = 0.1;
                const dx = gameState.cameraLerpTarget.x - gameState.camera.x;
                const dy = gameState.cameraLerpTarget.y - gameState.camera.y;

                // If we're close enough to target, snap to it and end animation
                if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) {
                    gameState.camera.x = gameState.cameraLerpTarget.x;
                    gameState.camera.y = gameState.cameraLerpTarget.y;
                    gameState.cameraLerpTarget = null;
                    gameState.cameraLerpStart = null;
                } else {
                    // Otherwise continue smooth movement
                    gameState.camera.x += dx * lerpSpeed;
                    gameState.camera.y += dy * lerpSpeed;
                }
            }

            // Draw game elements
            drawMap();
            drawResources();
            drawBuildings();
            drawUnits();
            drawProjectiles();
            drawParticles();
            drawSelectionBox();
            drawBuildingPreview();
            drawFPS();

            // Update minimap
            drawMinimap();

            // Schedule next frame
            requestAnimationFrame(gameLoop);
        }

        // Event Listeners
        canvas.addEventListener('mousedown', (e) => {
            if (!gameState.gameStarted) return;

            if (e.button === 0) { // Left mouse button
                const mouseX = e.clientX;
                const mouseY = e.clientY;
                const worldPos = screenToWorld(mouseX, mouseY);

                if (gameState.buildingMode) {
                    // Place building
                    if (buildStructure(gameState.buildingType, worldPos.x - 30, worldPos.y - 30)) {
                        // If ctrl key is held, stay in building mode, otherwise exit
                        if (!e.ctrlKey) {
                            gameState.buildingMode = false;
                            gameState.buildingType = null;
                            document.body.style.cursor = 'default';
                        } else {
                            // Stay in building mode with the same building type
                            document.body.style.cursor = 'crosshair';
                        }
                    }
                } else {
                    // Check if clicked on an entity
                    const clickedEntity = getEntityAtPoint(worldPos.x, worldPos.y);

                    if (clickedEntity) {
                        // Track double clicks
                        const now = Date.now();
                        if (gameState.lastClickTime && 
                            now - gameState.lastClickTime < 300 && // 300ms for double-click
                            gameState.lastClickedEntity && 
                            gameState.lastClickedEntity.id === clickedEntity.id) {

                            // Double click detected - select all units of the same type visible on screen
                            selectAllUnitsOfType(clickedEntity.type);
                        } else {
                            // Normal selection
                            selectEntity(clickedEntity, e.shiftKey);

                            // Save for double-click detection
                            gameState.lastClickTime = now;
                            gameState.lastClickedEntity = clickedEntity;
                        }
                    } else {
                        // Start selection box
                        gameState.dragStart = {
                            x: mouseX,
                            y: mouseY
                        };
                        gameState.selectionBox = {
                            x: mouseX,
                            y: mouseY
                        };

                        if (!e.shiftKey) {
                            deselectAll();
                        }
                    }
                }
            } else if (e.button === 2) { // Right mouse button
                // Issue command to selected units
                if (gameState.selectedEntities.length > 0) {
                    const mouseX = e.clientX;
                    const mouseY = e.clientY;
                    const worldPos = screenToWorld(mouseX, mouseY);

                    // Check if clicked on an entity
                    const clickedEntity = getEntityAtPoint(worldPos.x, worldPos.y);

                    // Check if a building with training capability is selected
                    const selectedBuilding = gameState.selectedEntities.find(entity => 
                        entity.canTrain && entity.isComplete && !entity.isEnemy);

                    if (selectedBuilding) {
                        // Set gather point for the building
                        selectedBuilding.gatherPoint.x = worldPos.x;
                        selectedBuilding.gatherPoint.y = worldPos.y;

                        // If clicked on a resource or enemy, set as target
                        if (clickedEntity) {
                            if (clickedEntity.type === 'tree' || clickedEntity.type === 'gold' || 
                                clickedEntity.type === 'stone' || clickedEntity.type === 'berry' ||
                                clickedEntity.isEnemy || clickedEntity.type === 'enemy-base') {
                                selectedBuilding.gatherPoint.target = clickedEntity.id;
                                // Play sound for setting rally point
                                playSound('https://sounds.fuzzycode.dev/sound_effect?prompt=setting%20rally%20point%20click&duration=0.5&ext=.mp3');
                            } else {
                                // If not a valid target, just set location
                                selectedBuilding.gatherPoint.target = null;
                                // Play sound for setting rally point
                                playSound('https://sounds.fuzzycode.dev/sound_effect?prompt=setting%20rally%20point%20click&duration=0.5&ext=.mp3');
                            }
                        } else {
                            // Clear target if no entity clicked
                            selectedBuilding.gatherPoint.target = null;
                            // Play sound for setting rally point
                            playSound('https://sounds.fuzzycode.dev/sound_effect?prompt=setting%20rally%20point%20click&duration=0.5&ext=.mp3');
                        }
                    } else {
                        // Normal unit commands
                        if (clickedEntity) {
                            // Create visual highlight effect on the target entity
                            if (!gameState.particles) gameState.particles = [];
                            for (let i = 0; i < 10; i++) {
                                gameState.particles.push({
                                    x: clickedEntity.x + Math.random() * clickedEntity.width,
                                    y: clickedEntity.y + Math.random() * clickedEntity.height,
                                    vx: Math.random() * 2 - 1,
                                    vy: Math.random() * 2 - 1,
                                    life: 20,
                                    type: 'targetHighlight',
                                    size: 3 + Math.random() * 3
                                });
                            }

                            if (clickedEntity.type === 'tree' || clickedEntity.type === 'gold' || 
                                clickedEntity.type === 'stone' || clickedEntity.type === 'berry') {
                                // Gather resource
                                gameState.selectedEntities.forEach(unit => {
                                    if (unit.type === 'villager') {
                                        gatherResource(unit, clickedEntity);
                                    }
                                });
                            } else if (clickedEntity.isEnemy || clickedEntity.type === 'enemy-base') {
                                // Attack enemy (unit or building)
                                attackEnemy(gameState.selectedEntities, clickedEntity);
                                console.log("Attack command issued for: ", clickedEntity.type, clickedEntity.id);
                            } else if (clickedEntity.isFoundation && !clickedEntity.isComplete) {
                                // Assign villagers to build
                                gameState.selectedEntities.forEach(unit => {
                                    if (unit.type === 'villager') {
                                        assignVillagerToBuild(unit, clickedEntity);
                                    }
                                });
                            } else {
                                // Move units
                                moveUnits(gameState.selectedEntities, worldPos.x, worldPos.y);
                            }
                        } else {
                            // Move units
                            moveUnits(gameState.selectedEntities, worldPos.x, worldPos.y);
                        }
                    }
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!gameState.gameStarted) return;

            // Update mouse position for building placement
            gameState.mousePosition = {
                x: e.clientX,
                y: e.clientY
            };

            if (gameState.dragStart) {
                // Update selection box
                gameState.selectionBox = {
                    x: e.clientX,
                    y: e.clientY
                };
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!gameState.gameStarted) return;

            if (e.button === 0 && gameState.dragStart) { // Left mouse button up after drag
                // Select units within selection box
                const left = Math.min(gameState.dragStart.x, gameState.selectionBox.x);
                const top = Math.min(gameState.dragStart.y, gameState.selectionBox.y);
                const right = Math.max(gameState.dragStart.x, gameState.selectionBox.x);
                const bottom = Math.max(gameState.dragStart.y, gameState.selectionBox.y);

                // Only process selection if box is big enough (to avoid accidental selections)
                if (Math.abs(right - left) > 5 && Math.abs(bottom - top) > 5) {
                    const entitiesInBox = getEntitiesInBox(left, top, right, bottom);

                    entitiesInBox.forEach(entity => {
                        selectEntity(entity, e.shiftKey || gameState.selectedEntities.length > 0);
                    });
                }

                // Clean up selection box
                gameState.dragStart = null;
                gameState.selectionBox = null;
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!gameState.gameStarted) return;
            const entity = gameState.selectedEntities[0];

            // Arrow keys for camera movement
            if (e.key === 'ArrowUp' || e.key === 'w') {
                gameState.camera.y = Math.max(0, gameState.camera.y - 20);
            } else if (e.key === 'ArrowDown' || e.key === 's') {
                gameState.camera.y = Math.min(gameState.mapSize.height - canvas.height, gameState.camera.y + 20);
            } else if (e.key === 'ArrowLeft' || e.key === 'a') {
                gameState.camera.x = Math.max(0, gameState.camera.x - 20);
            } else if (e.key === 'ArrowRight' || e.key === 'd') {
                gameState.camera.x = Math.min(gameState.mapSize.width - canvas.width, gameState.camera.x + 20);
            } else if (e.key === 'e') {
                // Toggle edge scrolling
                gameState.edgeScrolling = !gameState.edgeScrolling;
                showNotification(gameState.edgeScrolling ? "Edge scrolling enabled" : "Edge scrolling disabled");
            } else if (e.key === 'Control') {
                // Indicate ctrl key is being held for multiple building placement
                if (gameState.buildingMode) {
                    showNotification("Multiple building mode: ON (hold Ctrl while placing)");
                }
            } else if (e.key === 'Escape') {
                // Cancel building mode or deselect all
                if (gameState.buildingMode) {
                    gameState.buildingMode = false;
                    gameState.buildingType = null;
                    document.body.style.cursor = 'default';
                } else {
                    deselectAll();
                }

                buildMenu.style.display = 'none';
                trainMenu.style.display = 'none';
            } else if (e.key === '.') {
                // Find idle villager
                findIdleVillager();
            } else if (e.key === ',') {
                // Find idle military unit
                findIdleMilitary();
            } else if (buildMenu.style.display === 'block') {
                // Check if pressed key matches any building option hotkey
                const buildOption = document.querySelector(`#build-menu .menu-option[data-hotkey="${e.key.toLowerCase()}"]`);
                if (buildOption) {
                    const buildingType = buildOption.dataset.building;
                    const costData = buildOption.dataset.cost;

                    // Check if we have enough resources
                    let canBuild = false;

                    if (buildingType === 'house' && gameState.resources.wood >= 30) {
                        canBuild = true;
                    } else if (buildingType === 'barracks' && gameState.resources.wood >= 125) {
                        canBuild = true;
                    } else if ((buildingType === 'lumber-camp' || buildingType === 'mining-camp' || buildingType === 'mill') && gameState.resources.wood >= 70) {
                        canBuild = true;
                    } else if (buildingType === 'guard-tower' && gameState.resources.wood >= 50 && gameState.resources.stone >= 100) {
                        canBuild = true;
                    }

                    if (canBuild) {
                        handleStartBuilding(buildingType);
                    } else {
                        showNotification("Not enough resources to build " + buildingType);
                    }
                }
            } else if (trainMenu.style.display === 'block') {
                // Check if pressed key matches any training option hotkey
                const trainOption = document.querySelector(`#train-menu .menu-option[data-hotkey="${e.key.toLowerCase()}"]`);
                if (trainOption) {
                    const unitType = trainOption.dataset.unit;

                    // Check if we have enough resources and population cap
                    if (unitType === 'villager')
                    {
                        handleTrainVillager();
                    }
                }
            } else if (e.key.toLowerCase() === HOTKEYS.BUILD && gameState.selectedEntities.length > 0 && entity && entity.type === 'villager') {
                // Handle build hotkey for villager
                // Open build menu
                buildMenu.style.display = 'block';
                trainMenu.style.display = 'none';
            } else if (e.key.toLowerCase() === HOTKEYS.TRAIN && gameState.selectedEntities.length > 0 && entity && (entity.type === 'town-center' || entity.type === 'barracks')) {
                if (entity.type === 'town-center') {
                    buildMenu.style.display = 'none';
                    trainMenu.style.display = 'block';
                } else if (entity.type === 'barracks') {
                    handleTrainSoldier();
                }
            } else if (e.key.toLowerCase() === 'l') {
                gameState.debugLogging = !gameState.debugLogging;
                showNotification("Debug logging " + (gameState.debugLogging ? "enabled" : "disabled"));
            }
        });

        // Prevent context menu
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Mouse wheel for zooming (not implemented in this version)
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
        });
        // Stop edge scrolling when the mouse leaves the canvas
        canvas.addEventListener('mouseleave', () => {
            gameState.mousePosition = null;
        });

        // Handle minimap interactions
        minimapCanvas.addEventListener('mousedown', (e) => {
            if (!gameState.gameStarted) return;

            // Start tracking minimap drag
            gameState.minimapDragging = true;

            // Handle the initial position update
            updateCameraFromMinimap(e);

            // Show/hide gather points
            gameState.showGatherPoints = e.ctrlKey;
        });

        document.addEventListener('mousemove', (e) => {
            if (!gameState.gameStarted || !gameState.minimapDragging) return;

            // Update camera position based on minimap drag
            updateCameraFromMinimap(e);
        });

        document.addEventListener('mouseup', (e) => {
            // Stop tracking minimap drag
            gameState.minimapDragging = false;
            gameState.cameraLerpStart = null;
            gameState.cameraLerpTarget = null;
        });

        function updateCameraFromMinimap(e) {
            const rect = minimapCanvas.getBoundingClientRect();

            // Check if the mouse is within or close to the minimap bounds
            if (e.clientX >= rect.left - 10 && e.clientX <= rect.right + 10 && 
                e.clientY >= rect.top - 10 && e.clientY <= rect.bottom + 10) {

                // Clamp coordinates to minimap bounds
                const x = Math.max(0, Math.min(150, e.clientX - rect.left));
                const y = Math.max(0, Math.min(100, e.clientY - rect.top));

                // Calculate map position
                const mapX = (x / 150) * gameState.mapSize.width;
                const mapY = (y / 100) * gameState.mapSize.height;

                // Get target camera position
                const targetX = Math.max(0, Math.min(gameState.mapSize.width - canvas.width, mapX - canvas.width / 2));
                const targetY = Math.max(0, Math.min(gameState.mapSize.height - canvas.height, mapY - canvas.height / 2));

                // Store current position if not already stored
                if (!gameState.cameraLerpStart) {
                    gameState.cameraLerpStart = {
                        x: gameState.camera.x,
                        y: gameState.camera.y,
                        time: performance.now()
                    };
                }

                // Store target position
                gameState.cameraLerpTarget = {
                    x: targetX,
                    y: targetY
                };

                // Immediate update for responsive feel but with damping
                const lerpFactor = 0.3; // Adjust for desired smoothness (0-1)
                gameState.camera.x += (targetX - gameState.camera.x) * lerpFactor;
                gameState.camera.y += (targetY - gameState.camera.y) * lerpFactor;
            }
        }

        // Handle build menu clicks
        document.querySelectorAll('#build-menu .menu-option').forEach(option => {
            option.addEventListener('click', () => {
                const buildingType = option.dataset.building;
                const costData = option.dataset.cost;
                handleStartBuilding(buildingType);
            });
        });

        function handleStartBuilding(buildingType) {
            let canBuild = false;

            switch(buildingType) {
                case 'house':
                    canBuild = gameState.resources.wood >= 30;
                    break;
                case 'barracks':
                    canBuild = gameState.resources.wood >= 125;
                    break;
                case 'lumber-camp':
                case 'mining-camp':
                case 'mill':
                    canBuild = gameState.resources.wood >= 70;
                    break;
                case 'guard-tower':
                    canBuild = gameState.resources.wood >= 50 && gameState.resources.stone >= 100;
                    break;
            }

            if (canBuild) {
                gameState.buildingMode = true;
                gameState.buildingType = buildingType;
                buildMenu.style.display = 'none';
                document.body.style.cursor = 'crosshair';
                showNotification("Hold Ctrl to place multiple buildings of the same type");
            } else {
                showNotification("Not enough resources to build " + buildingType);
            }
        }      
        // Handle train menu clicks
        document.querySelectorAll('#train-menu .menu-option').forEach(option => {
            option.addEventListener('click', () => {
                const unitType = option.dataset.unit;
                handleTrainUnit(unitType);
            });
        });

        function handleTrainUnit(unitType) {
            if (unitType === 'villager') {
                handleTrainVillager();
            } else if (unitType === 'soldier') {
                handleTrainSoldier();
            }
        }

        function handleTrainVillager() {
            if (gameState.resources.food >= 50 && gameState.population < gameState.populationCap) {
                gameState.resources.food -= 50;
                updateResourcesDisplay();

                const townCenter = gameState.selectedEntities.find(e => e.type === 'town-center');
                if (townCenter) {
                    const tcX = townCenter.x;
                    const tcY = townCenter.y;
                    const villager = createUnit('villager', tcX + 120, tcY + 70);

                    if (townCenter.gatherPoint) {
                        applyGatherPointToVillager(townCenter, villager);
                    }

                    playSound(gameState.unitSounds.select, {x: tcX, y: tcY});
                    showNotification("Villager trained successfully");
                } else {
                    showNotification("No town center selected to train villager");
                }
                trainMenu.style.display = 'none';
            } else {
                if (gameState.population >= gameState.populationCap) {
                    showNotification("Not enough population capacity. Build more houses.");
                } else {
                    showNotification("Not enough food to train villager (50 Food)");
                }
            }
        }

        function handleTrainSoldier() {
            if (gameState.resources.food >= 60 && gameState.resources.gold >= 20 && gameState.population < gameState.populationCap) {
                gameState.resources.food -= 60;
                gameState.resources.gold -= 20;
                updateResourcesDisplay();

                const barracks = gameState.selectedEntities.find(e => e.type === 'barracks');
                if (barracks) {
                    const soldier = createUnit('soldier', barracks.x + 100, barracks.y + 50);
                    if (barracks.gatherPoint) {
                        applyGatherPointToSoldier(barracks, soldier);
                    }
                    playSound(gameState.unitSounds.select, {x: barracks.x + 100, y: barracks.y + 50});
                    showNotification("Soldier trained successfully");
                } else {
                    showNotification("No barracks selected to train soldier");
                }
                trainMenu.style.display = 'none';
            } else {
                if (gameState.population >= gameState.populationCap) {
                    showNotification("Not enough population capacity. Build more houses.");
                } else {
                    showNotification("Not enough resources to train soldier (60 Food, 20 Gold)");
                }
            }
        }

        // Function to find and select idle villagers
        function findIdleVillager() {
            // Get all idle villagers (not gathering, building, or moving)
            const idleVillagers = gameState.units.filter(unit => 
                unit.type === 'villager' && 
                !unit.isGathering && 
                !unit.isBuilding && 
                !unit.isMoving && 
                !unit.isAttacking &&
                !unit.isReturningResources
            );

            if (idleVillagers.length === 0) {
                showNotification("No idle villagers found");
                return;
            }

            // Clear selection and select the next idle villager
            if (idleVillagers.length > 0) {
                // Make sure index is in bounds
                if (gameState.idleVillagerIndex >= idleVillagers.length) {
                    gameState.idleVillagerIndex = 0;
                }

                const villager = idleVillagers[gameState.idleVillagerIndex];
                deselectAll();
                selectEntity(villager);

                // Center camera on the villager
                gameState.cameraLerpTarget = {
                    x: Math.max(0, Math.min(gameState.mapSize.width - canvas.width, villager.x - canvas.width / 2)),
                    y: Math.max(0, Math.min(gameState.mapSize.height - canvas.height, villager.y - canvas.height / 2))
                };

                // Play a sound to indicate selection
                playSound(gameState.unitSounds.select, {x: soldier.x, y: soldier.y});

                // Show notification
                showNotification(`Idle villager found (${gameState.idleVillagerIndex + 1}/${idleVillagers.length})`);

                // Increment index for next time
                gameState.idleVillagerIndex = (gameState.idleVillagerIndex + 1) % idleVillagers.length;
            }
        }

        // Function to find and select idle military units
        function findIdleMilitary() {
            // Get all idle military units (soldiers not moving or attacking)
            const idleMilitary = gameState.units.filter(unit => 
                unit.type === 'soldier' && 
                !unit.isMoving && 
                !unit.isAttacking
            );

            if (idleMilitary.length === 0) {
                showNotification("No idle military units found");
                return;
            }

            // Clear selection and select the next idle military unit
            if (idleMilitary.length > 0) {
                // Make sure index is in bounds
                if (gameState.idleMilitaryIndex >= idleMilitary.length) {
                    gameState.idleMilitaryIndex = 0;
                }

                const soldier = idleMilitary[gameState.idleMilitaryIndex];
                deselectAll();
                selectEntity(soldier);

                // Center camera on the soldier
                gameState.cameraLerpTarget = {
                    x: Math.max(0, Math.min(gameState.mapSize.width - canvas.width, soldier.x - canvas.width / 2)),
                    y: Math.max(0, Math.min(gameState.mapSize.height - canvas.height, soldier.y - canvas.height / 2))
                };

                // Play a sound to indicate selection
                playSound(gameState.unitSounds.select, {x: soldier.x, y: soldier.y});

                // Show notification
                showNotification(`Idle military unit found (${gameState.idleMilitaryIndex + 1}/${idleMilitary.length})`);

                // Increment index for next time
                gameState.idleMilitaryIndex = (gameState.idleMilitaryIndex + 1) % idleMilitary.length;
            }
        }

        // Debug feature: Add 10k resources on double click
        document.getElementById('food-display').addEventListener('dblclick', () => {
            if (gameState.gameStarted) {
                gameState.resources.food += 10000;
                updateResourcesDisplay();
                showNotification("Added 10,000 Food (debug)");
            }
        });

        document.getElementById('wood-display').addEventListener('dblclick', () => {
            if (gameState.gameStarted) {
                gameState.resources.wood += 10000;
                updateResourcesDisplay();
                showNotification("Added 10,000 Wood (debug)");
            }
        });

        document.getElementById('gold-display').addEventListener('dblclick', () => {
            if (gameState.gameStarted) {
                gameState.resources.gold += 10000;
                updateResourcesDisplay();
                showNotification("Added 10,000 Gold (debug)");
            }
        });

        document.getElementById('stone-display').addEventListener('dblclick', () => {
            if (gameState.gameStarted) {
                gameState.resources.stone += 10000;
                updateResourcesDisplay();
                showNotification("Added 10,000 Stone (debug)");
            }
        });

        // Function to check if all enemies are defeated
        function checkVictoryCondition() {
            // If game is already over, don't check again
            if (gameState.gameOver) return;

            // Check if there are any enemy units or buildings left
            const hasEnemyUnits = gameState.enemies.length > 0;

            // Check for enemy buildings (those with isEnemy flag)
            const hasEnemyBuildings = gameState.buildings.some(building => building.isEnemy);

            // If no enemies remain, show victory screen
            if (!hasEnemyUnits && !hasEnemyBuildings) {
                showVictoryScreen();
            }

            // Check for player defeat condition (no town center and no villagers)
            const hasTownCenter = gameState.buildings.some(building => building.type === 'town-center' && !building.isEnemy);
            const hasVillagers = gameState.units.some(unit => unit.type === 'villager');

            if (!hasTownCenter && !hasVillagers) {
                showDefeatScreen();
            }
        }

        // Function to show defeat screen
        function showDefeatScreen() {
            // Set game over flag
            gameState.gameOver = true;

            // Play defeat sound
            const sound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=defeat%20sad%20game%20over&duration=5&ext=.mp3');
            sound.volume = 0.5;
            sound.play().catch(e => console.log("Defeat sound play prevented:", e));

            // Modify the victory screen for defeat
            const victoryScreen = document.getElementById('victory-screen');
            const victoryTitle = victoryScreen.querySelector('h1');
            const victoryText = victoryScreen.querySelector('p');

            victoryTitle.textContent = "Defeat!";
            victoryTitle.style.color = "#ff4444";
            victoryText.textContent = "Your civilization has been defeated. Better luck next time!";

            victoryScreen.style.display = 'flex';

            // Create defeat particles (dark, falling ash)
            if (!gameState.particles) gameState.particles = [];

            // Create sad/defeat particles across the screen
            const particleInterval = setInterval(() => {
                if (gameState.gameOver) {
                    for (let i = 0; i < 10; i++) {
                        gameState.particles.push({
                            x: Math.random() * gameState.mapSize.width,
                            y: Math.random() * gameState.mapSize.height,
                            vx: Math.random() * 1 - 0.5,
                            vy: 1 + Math.random(),
                            life: 60 + Math.random() * 40,
                            type: 'smoke',
                            size: 5 + Math.random() * 5
                        });
                    }
                } else {
                    clearInterval(particleInterval);
                }
            }, 200);
        }

        // Function to show victory screen
        function showVictoryScreen() {
            // Set game over flag
            gameState.gameOver = true;

            // Play victory fanfare - play at full volume regardless of position
            const sound = gameState.sounds['https://sounds.fuzzycode.dev/sound_effect?prompt=victory%20fanfare%20triumphant&duration=5&ext=.mp3'];
            if (sound) {
                const clone = sound.cloneNode();
                clone.volume = 0.5;
                clone.play().catch(e => console.log("Victory sound play prevented:", e));
            } else {
                const audio = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=victory%20fanfare%20triumphant&duration=5&ext=.mp3');
                audio.volume = 0.5;
                audio.play().catch(e => console.log("Victory sound play prevented:", e));
                gameState.sounds['https://sounds.fuzzycode.dev/sound_effect?prompt=victory%20fanfare%20triumphant&duration=5&ext=.mp3'] = audio;
            }

            // Show the victory screen with animation
            const victoryScreen = document.getElementById('victory-screen');
            victoryScreen.style.display = 'flex';

            // Create victory particles
            if (!gameState.particles) gameState.particles = [];

            // Create celebratory particles across the screen
            const particleInterval = setInterval(() => {
                if (gameState.gameOver) {
                    for (let i = 0; i < 10; i++) {
                        gameState.particles.push({
                            x: Math.random() * gameState.mapSize.width,
                            y: Math.random() * gameState.mapSize.height,
                            vx: Math.random() * 3 - 1.5,
                            vy: -3 - Math.random() * 2,
                            life: 60 + Math.random() * 40,
                            type: 'completion',
                            size: 5 + Math.random() * 5
                        });
                    }
                } else {
                    clearInterval(particleInterval);
                }
            }, 200);
        }

        // Event listener for restart button
        document.getElementById('restart-game-button').addEventListener('click', () => {
            startGame();
        });

        // Initialize the game
        initGame();
    </script>
</body>
</html>