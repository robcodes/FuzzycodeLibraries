<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubblebound!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Press Start 2P', cursive, sans-serif;
            background-color: #0c1445;
            overflow: hidden;
            color: #fff;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            margin: 0 auto;
            background-color: #0c1445;
            border: 4px solid #6a4bc4;
            border-radius: 10px;
            overflow: hidden;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(12, 20, 69, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #title {
            font-size: 48px;
            color: #f8d800;
            text-shadow: 3px 3px 0 #ff4081, 6px 6px 0 #6a4bc4;
            margin-bottom: 20px;
            animation: float 2s infinite ease-in-out;
        }

        #start-button {
            background-color: #ff4081;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-family: 'Press Start 2P', cursive, sans-serif;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
            box-shadow: 0 4px 0 #c60055;
        }

        #start-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 9px 0 #c60055;
        }

        #start-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #c60055;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 5;
            display: none;
        }

        #score, #lives {
            font-size: 14px;
            margin-bottom: 5px;
            color: #f8d800;
            text-shadow: 1px 1px 0 #6a4bc4;
        }

        #pause-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: transparent;
            border: none;
            color: #f8d800;
            font-size: 20px;
            cursor: pointer;
            z-index: 5;
            display: none;
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(12, 20, 69, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #game-over-text {
            font-size: 36px;
            color: #ff4081;
            text-shadow: 2px 2px 0 #6a4bc4;
            margin-bottom: 20px;
        }

        #final-score {
            font-size: 24px;
            color: #f8d800;
            margin-bottom: 20px;
        }

        #restart-button {
            background-color: #6a4bc4;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-family: 'Press Start 2P', cursive, sans-serif;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 0 #3a2380;
        }

        #restart-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 9px 0 #3a2380;
        }

        #restart-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #3a2380;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        .bubble {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.1));
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: float-bubble 3s infinite ease-in-out;
            opacity: 0.6;
            z-index: 0;
        }

        @keyframes float-bubble {
            0%, 100% {
                transform: translateY(0) translateX(0);
            }
            25% {
                transform: translateY(-10px) translateX(5px);
            }
            50% {
                transform: translateY(-20px) translateX(0);
            }
            75% {
                transform: translateY(-10px) translateX(-5px);
            }
        }

        #tagline {
            font-size: 16px;
            color: #fff;
            text-align: center;
            margin-bottom: 30px;
            max-width: 80%;
        }

        .instructions {
            font-size: 12px;
            color: #f8d800;
            margin-top: 20px;
            text-align: center;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="800" height="600"></canvas>

        <div id="title-screen">
            <h1 id="title">Bubblebound!</h1>
            <p id="tagline">"Join Pip, the plucky bubble sprite, on a bouncy, bubbly adventure to restore the flow of magic before it's too late!"</p>
            <button id="start-button">Start Game</button>
            <p class="instructions">Use Arrow Keys to move, Space to bounce, Z to shift bubble state</p>
        </div>

        <div id="hud">
            <div id="score">Score: 0</div>
            <div id="lives">Lives: 3</div>
        </div>

        <button id="pause-button">II</button>

        <div id="game-over">
            <h2 id="game-over-text">Game Over</h2>
            <p id="final-score">Final Score: 0</p>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <script>
        // Game state
        const gameState = {
            score: 0,
            lives: 3,
            level: 1,
            gameActive: false,
            gamePaused: false,
            bubbleState: 'solid', // 'solid' or 'airy'
            powerUp: null,
            bubblesCollected: 0,
            bubblesNeeded: 20, // Bubbles needed to complete a level
            worldIndex: 0, // Current world (0-4)
            levelIndex: 0, // Current level within world (0-5)
            showingBoss: false, // Whether a boss is currently active
            rainbowBubblesFound: 0, // Special rainbow bubbles for secret ending
            keyState: {
                left: false,
                right: false,
                up: false,
                down: false,
                space: false,
                shift: false
            }
        };

        // Game elements
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const titleScreen = document.getElementById('title-screen');
        const startButton = document.getElementById('start-button');
        const hud = document.getElementById('hud');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const pauseButton = document.getElementById('pause-button');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');

        // Game constants
        const GRAVITY = 0.5;
        const JUMP_FORCE = -12;
        const BOUNCE_FACTOR = 0.7;
        const PLAYER_SPEED = 5;
        const PLAYER_SIZE = 40;
        const PLATFORM_HEIGHT = 20;
        const BUBBLE_TYPES = ['blue', 'red', 'yellow', 'green', 'purple'];
        
        // Bubble type descriptions (based on the game premise)
        const BUBBLE_DESCRIPTIONS = {
            'blue': 'Zippy Zap Bubble - Allows Pip to burst upwards',
            'red': 'Explosive Bubble - Turns Pip into a bouncing bomb',
            'yellow': 'Feather Float Bubble - Slows descent for controlled platforming',
            'green': 'Echo Bounce Bubble - Creates a temporary platform',
            'purple': 'Magnet Bubble - Slows down enemies'
        };
        
        // Game worlds data
        const GAME_WORLDS = [
            {
                name: "Cloudspout Heights",
                background: 'https://images.fuzzycode.dev/fast_ai?search=magical%20sky%20kingdom%20pixel%20art%20background%20with%20floating%20islands&resize=800x600',
                music: 'https://sounds.fuzzycode.dev/music?prompt=airy%20upbeat%20chiptune%20platformer%20music&duration=30&ext=.mp3',
                platformColor: '#a8d0ff',
                specialFeature: 'windTunnels', // Upward air currents that boost Pip
                boss: {
                    name: "Gustfang the Tempest Serpent",
                    health: 5,
                    attackPattern: 'wind',
                    sprite: 'https://images.fuzzycode.dev/fast_ai?search=sky%20dragon%20serpent%20pixel%20art&resize=120x120&transparency=true'
                }
            },
            {
                name: "Bubble Grotto",
                background: 'https://images.fuzzycode.dev/fast_ai?search=underground%20cavern%20with%20glowing%20bubbles%20pixel%20art&resize=800x600',
                music: 'https://sounds.fuzzycode.dev/music?prompt=mysterious%20cave%20chiptune%20platformer%20music&duration=30&ext=.mp3',
                platformColor: '#7d92c2',
                specialFeature: 'geysers', // Periodic bursts that launch Pip upward
                boss: {
                    name: "The Ooze Conductor",
                    health: 6,
                    attackPattern: 'slime',
                    sprite: 'https://images.fuzzycode.dev/fast_ai?search=sludge%20monster%20conductor%20pixel%20art&resize=120x120&transparency=true'
                }
            },
            {
                name: "Stormy Skylines",
                background: 'https://images.fuzzycode.dev/fast_ai?search=stormy%20sky%20with%20lightning%20pixel%20art&resize=800x600',
                music: 'https://sounds.fuzzycode.dev/music?prompt=intense%20stormy%20chiptune%20platformer%20music&duration=30&ext=.mp3',
                platformColor: '#9e77c9',
                specialFeature: 'lightning', // Random lightning strikes to avoid
                boss: {
                    name: "General Splotch",
                    health: 7,
                    attackPattern: 'inflate',
                    sprite: 'https://images.fuzzycode.dev/fast_ai?search=inflatable%20bubble%20general%20pixel%20art&resize=120x120&transparency=true'
                }
            },
            {
                name: "Misty Marshlands",
                background: 'https://images.fuzzycode.dev/fast_ai?search=dark%20misty%20swamp%20pixel%20art&resize=800x600',
                music: 'https://sounds.fuzzycode.dev/music?prompt=eerie%20swamp%20chiptune%20platformer%20music&duration=30&ext=.mp3',
                platformColor: '#548a54',
                specialFeature: 'fog', // Reduced visibility, sound-based navigation
                boss: {
                    name: "The Fog Maw",
                    health: 8,
                    attackPattern: 'swallow',
                    sprite: 'https://images.fuzzycode.dev/fast_ai?search=giant%20mist%20monster%20with%20huge%20mouth%20pixel%20art&resize=120x120&transparency=true'
                }
            },
            {
                name: "The Hollow Core",
                background: 'https://images.fuzzycode.dev/fast_ai?search=dark%20void%20with%20reversed%20gravity%20pixel%20art&resize=800x600',
                music: 'https://sounds.fuzzycode.dev/music?prompt=ominous%20final%20boss%20chiptune%20platformer%20music&duration=30&ext=.mp3',
                platformColor: '#5e3a64',
                specialFeature: 'reverseGravity', // Gravity pulls upward
                boss: {
                    name: "Mistweaver, the Final Corruptor",
                    health: 10,
                    attackPattern: 'chaos',
                    sprite: 'https://images.fuzzycode.dev/fast_ai?search=dark%20entity%20corrupting%20bubbles%20pixel%20art&resize=120x120&transparency=true'
                }
            }
        ];

        // Game objects
        let player;
        let platforms = [];
        let bubbles = [];
        let enemies = [];
        let particles = [];
        let specialFeatures = []; // Wind tunnels, geysers, etc.
        let rainbowBubbles = []; // Special collectibles
        let currentBoss = null;
        let lastTime = 0;
        let animationId;
        let worldBackgroundImage = new Image();

        // Sprite images (using AI generated placeholder URLs - in a real game you'd use your own sprite sheets)
        const playerImage = new Image();
        playerImage.src = 'https://images.fuzzycode.dev/fast_ai?search=cute%20round%20blue%20sprite%20character%20with%20glowing%20core%20pixel%20art&resize=40x40&transparency=true';
        
        const bubbleImages = {};
        BUBBLE_TYPES.forEach(type => {
            bubbleImages[type] = new Image();
            bubbleImages[type].src = `https://images.fuzzycode.dev/fast_ai?search=${type}%20bubble%20pixel%20art&resize=30x30&transparency=true`;
        });

        const enemyImage = new Image();
        enemyImage.src = 'https://images.fuzzycode.dev/fast_ai?search=spiky%20dark%20bubble%20enemy%20pixel%20art&resize=40x40&transparency=true';

        const platformImage = new Image();
        platformImage.src = 'https://images.fuzzycode.dev/fast_ai?search=floating%20cloud%20platform%20pixel%20art&resize=150x30&transparency=true';

        const backgroundImage = new Image();
        backgroundImage.src = 'https://images.fuzzycode.dev/fast_ai?search=magical%20sky%20kingdom%20pixel%20art%20background&resize=800x600';

        // Sound effects
        const sounds = {
            bounce: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=bubble%20bounce%20sound&duration=0.5&ext=.mp3'),
            collect: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=bubble%20pop%20collect%20sound&duration=0.5&ext=.mp3'),
            hurt: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=character%20hurt%20sound&duration=0.5&ext=.mp3'),
            gameOver: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=game%20over%20sad%20sound&duration=1&ext=.mp3'),
            shift: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=bubble%20shift%20sound&duration=0.5&ext=.mp3')
        };

        // Background music
        const bgMusic = new Audio('https://sounds.fuzzycode.dev/music?prompt=upbeat%20chiptune%20platformer%20music&duration=30&ext=.mp3');
        bgMusic.loop = true;
        bgMusic.volume = 0.5;

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = PLAYER_SIZE;
                this.height = PLAYER_SIZE;
                this.velocity = {
                    x: 0,
                    y: 0
                };
                this.color = '#64c5ff';
                this.isGrounded = false;
                this.canBounce = true;
                this.bubbleState = 'solid'; // 'solid' or 'airy'
                this.powerUp = null;
                this.powerUpTimer = 0;
                this.flickerTimer = 0;
                this.isInvulnerable = false;
                this.isBouncing = false;
                this.frame = 0;
                this.frameCount = 0;
                this.hue = 0;
                this.collisionDebounce = 0; // Add debounce for collision detection
                this.consecutiveBounces = 0; // Track consecutive bounces for momentum-based movement
                this.name = "Pip"; // The protagonist's name
            }

            update(deltaTime) {
                // Movement
                if (gameState.keyState.left) this.velocity.x = -PLAYER_SPEED;
                else if (gameState.keyState.right) this.velocity.x = PLAYER_SPEED;
                else this.velocity.x *= 0.9; // Friction

                // Reset grounded state at the beginning of update
                if (this.collisionDebounce > 0) {
                    this.collisionDebounce--;
                } else {
                    this.isGrounded = false;
                }

                // Reset consecutive bounces if landed
                if (this.isGrounded && this.consecutiveBounces > 0) {
                    // Don't reset immediately to allow for rhythmic bouncing
                    if (!gameState.keyState.space) {
                        this.consecutiveBounces = 0;
                    }
                }

                // Gravity depends on bubble state and power-ups
                let gravityModifier = 1;
                
                if (this.bubbleState === 'airy') {
                    gravityModifier = 0.5; // 50% gravity in airy state
                }
                
                // Feather Float power-up (yellow) effect
                if (this.slowDescent) {
                    gravityModifier *= 0.7; // Further reduce gravity
                }
                
                this.velocity.y += GRAVITY * gravityModifier;

                // Apply velocity
                this.x += this.velocity.x;
                this.y += this.velocity.y;

                // Boundary collisions
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
                
                // Bottom boundary - lose a life
                if (this.y > canvas.height) {
                    this.reset();
                    gameState.lives--;
                    livesDisplay.textContent = `Lives: ${gameState.lives}`;
                    sounds.hurt.play();
                    
                    if (gameState.lives <= 0) {
                        gameOver();
                    }
                }

                // Power-up timer
                if (this.powerUp && this.powerUpTimer > 0) {
                    this.powerUpTimer -= deltaTime;
                    if (this.powerUpTimer <= 0) {
                        this.powerUp = null;
                        this.slowDescent = false; // Make sure to reset any power-up effects
                    }
                }

                // Invulnerability flicker
                if (this.isInvulnerable) {
                    this.flickerTimer -= deltaTime;
                    if (this.flickerTimer <= 0) {
                        this.isInvulnerable = false;
                    }
                }

                // Animation
                this.frameCount++;
                if (this.frameCount >= 5) {
                    this.frame = (this.frame + 1) % 4;
                    this.frameCount = 0;
                }

                // Color cycling for visual effect - changes based on state and power-up
                this.hue = (this.hue + 1) % 360;
            }

            draw() {
                if (this.isInvulnerable && Math.floor(this.flickerTimer / 100) % 2 === 0) {
                    return; // Skip drawing to create flicker effect
                }

                // Create glowing effect
                const glow = this.powerUp ? 20 : 10;
                ctx.shadowBlur = glow;
                ctx.shadowColor = this.getColor();

                // Draw the player
                ctx.fillStyle = this.getColor();
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();

                // Inner glow
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2 - 5, this.y + this.height / 2 - 5, this.width / 4, 0, Math.PI * 2);
                ctx.fill();

                // Reset shadow
                ctx.shadowBlur = 0;

                // Indicate bubble state
                const stateBubbles = this.bubbleState === 'airy' ? 3 : 0;
                if (stateBubbles > 0) {
                    for (let i = 0; i < stateBubbles; i++) {
                        const angle = (i / stateBubbles) * Math.PI * 2 + this.frame * 0.2;
                        const distance = this.width * 0.7;
                        const bubbleX = this.x + this.width / 2 + Math.cos(angle) * distance;
                        const bubbleY = this.y + this.height / 2 + Math.sin(angle) * distance;
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Show power-up effect
                if (this.powerUp) {
                    const pulseSize = 5 + Math.sin(Date.now() * 0.01) * 3;
                    ctx.strokeStyle = this.getPowerUpColor();
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2 + pulseSize, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            getColor() {
                if (this.powerUp) {
                    return this.getPowerUpColor();
                }
                
                if (this.bubbleState === 'airy') {
                    return `hsl(${this.hue}, 80%, 70%)`;
                } else {
                    return `hsl(210, 80%, 60%)`;
                }
            }

            getPowerUpColor() {
                switch (this.powerUp) {
                    case 'blue': return '#1e90ff';
                    case 'red': return '#ff4500';
                    case 'yellow': return '#ffd700';
                    case 'green': return '#32cd32';
                    case 'purple': return '#9370db';
                    default: return '#ffffff';
                }
            }

            bounce() {
                if (this.canBounce) {
                    // Momentum-based bouncing - consecutive bounces get higher
                    this.consecutiveBounces++;
                    let bounceForce = JUMP_FORCE;
                    
                    // Increase bounce height for consecutive bounces (up to a limit)
                    if (this.consecutiveBounces > 1) {
                        const bonusFactor = Math.min(this.consecutiveBounces * 0.2, 1.0);
                        bounceForce *= (1 + bonusFactor);
                    }
                    
                    this.velocity.y = bounceForce;
                    this.isGrounded = false;
                    this.canBounce = false;
                    this.isBouncing = true;
                    this.collisionDebounce = 0; // Reset collision debounce on bounce
                    sounds.bounce.play();
                    
                    // Create bounce particles
                    for (let i = 0; i < 8; i++) {
                        particles.push(new Particle(
                            this.x + this.width / 2,
                            this.y + this.height,
                            Math.random() * 4 - 2,
                            -Math.random() * 2 - 1,
                            Math.random() * 5 + 3,
                            this.getColor()
                        ));
                    }

                    // Apply power-up effects on bounce
                    if (this.powerUp) {
                        switch (this.powerUp) {
                            case 'blue': // Zippy Zap Bubble - Higher jump
                                this.velocity.y *= 1.5;
                                break;
                            case 'red': // Explosive Bubble
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        this.x + this.width / 2,
                                        this.y + this.height,
                                        Math.random() * 8 - 4,
                                        -Math.random() * 4 - 2,
                                        Math.random() * 8 + 5,
                                        '#ff4500'
                                    ));
                                }
                                // Damage nearby enemies
                                enemies.forEach(enemy => {
                                    const dx = enemy.x + enemy.width/2 - (this.x + this.width/2);
                                    const dy = enemy.y + enemy.height/2 - (this.y + this.height/2);
                                    const distance = Math.sqrt(dx*dx + dy*dy);
                                    if (distance < 150) {
                                        enemy.velocity.x += dx/distance * 10;
                                        enemy.velocity.y += dy/distance * 10;
                                    }
                                });
                                break;
                            case 'yellow': // Feather Float Bubble - Slow descent
                                this.velocity.x *= 1.5;
                                // Set a flag for slower descent
                                this.slowDescent = true;
                                setTimeout(() => this.slowDescent = false, 3000);
                                break;
                            case 'green': // Echo Bounce Bubble - Create platform
                                platforms.push(new Platform(
                                    this.x - 50 + Math.random() * 100,
                                    this.y + 100,
                                    100,
                                    PLATFORM_HEIGHT
                                ));
                                break;
                            case 'purple': // Magnet Bubble - Time slow effect
                                // Visual effect to show time slowing
                                for (let i = 0; i < 30; i++) {
                                    particles.push(new Particle(
                                        this.x + this.width/2,
                                        this.y + this.height/2,
                                        Math.random() * 8 - 4,
                                        Math.random() * 8 - 4,
                                        Math.random() * 5 + 2,
                                        '#9370db'
                                    ));
                                }
                                // Slow down enemies
                                enemies.forEach(enemy => {
                                    enemy.slowTimer = 3000; // Slow for 3 seconds
                                });
                                break;
                        }
                    }
                }
            }

            toggleBubbleState() {
                this.bubbleState = this.bubbleState === 'solid' ? 'airy' : 'solid';
                sounds.shift.play();
                
                // Create shift particles
                for (let i = 0; i < 12; i++) {
                    particles.push(new Particle(
                        this.x + this.width / 2,
                        this.y + this.height / 2,
                        Math.random() * 6 - 3,
                        Math.random() * 6 - 3,
                        Math.random() * 5 + 5,
                        this.bubbleState === 'airy' ? '#aff' : '#88f'
                    ));
                }
            }

            reset() {
                this.x = canvas.width / 2 - this.width / 2;
                this.y = canvas.height / 2;
                this.velocity.x = 0;
                this.velocity.y = 0;
                this.isInvulnerable = true;
                this.flickerTimer = 2000; // 2 seconds of invulnerability
                this.powerUp = null;
            }

            collectBubble(bubble) {
                gameState.score += bubble.isRainbow ? 50 : 10;
                scoreDisplay.textContent = `Score: ${gameState.score}`;
                sounds.collect.play();
                
                // Track bubbles collected for level progression
                gameState.bubblesCollected++;
                
                // Track rainbow bubbles for secret ending
                if (bubble.isRainbow) {
                    gameState.rainbowBubblesFound++;
                    // Special rainbow collection sound
                    const rainbowSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=magical%20chime%20special%20item%20collect&duration=1&ext=.mp3');
                    rainbowSound.volume = 0.7;
                    rainbowSound.play();
                }
                
                // Apply power-up
                if (bubble.type !== 'normal') {
                    this.powerUp = bubble.type;
                    this.powerUpTimer = 5000; // 5 seconds
                }
                
                // Create collection particles
                const particleCount = bubble.isRainbow ? 20 : 10;
                for (let i = 0; i < particleCount; i++) {
                    particles.push(new Particle(
                        bubble.x + bubble.radius,
                        bubble.y + bubble.radius,
                        Math.random() * 4 - 2,
                        Math.random() * 4 - 2,
                        Math.random() * 5 + 3,
                        bubble.color
                    ));
                }
                
                // Check if level is complete
                if (gameState.bubblesCollected >= gameState.bubblesNeeded && !gameState.showingBoss) {
                    showLevelComplete();
                }
            }

            hitEnemy() {
                if (!this.isInvulnerable) {
                    gameState.lives--;
                    livesDisplay.textContent = `Lives: ${gameState.lives}`;
                    sounds.hurt.play();
                    this.isInvulnerable = true;
                    this.flickerTimer = 2000; // 2 seconds of invulnerability
                    
                    if (gameState.lives <= 0) {
                        gameOver();
                    }
                }
            }
        }

        // Platform class
        class Platform {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = '#a67df8';
                this.velocity = {
                    x: 0,
                    y: 0
                };
                this.isMoving = Math.random() > 0.7;
                if (this.isMoving) {
                    this.velocity.x = Math.random() * 2 - 1;
                    this.originalX = x;
                    this.movementRange = Math.random() * 100 + 50;
                }
            }

            update() {
                if (this.isMoving) {
                    this.x += this.velocity.x;
                    
                    // Reverse direction at movement limits
                    if (this.x < this.originalX - this.movementRange || 
                        this.x > this.originalX + this.movementRange) {
                        this.velocity.x *= -1;
                    }
                }
            }

            draw() {
                // Platform shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(this.x + 5, this.y + 5, this.width, this.height);
                
                // Platform
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Platform top highlight
                ctx.fillStyle = '#c4a9ff';
                ctx.fillRect(this.x, this.y, this.width, 5);
            }
        }

        // Bubble class
        class Bubble {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 15 + 15;
                this.velocity = {
                    x: Math.random() * 2 - 1,
                    y: -Math.random() * 2 - 1
                };
                this.type = Math.random() > 0.7 ? BUBBLE_TYPES[Math.floor(Math.random() * BUBBLE_TYPES.length)] : 'normal';
                this.isRainbow = Math.random() > 0.95; // Very rare rainbow bubbles
                this.color = this.getBubbleColor();
                this.opacity = 0.8;
                this.collected = false;
                this.animationOffset = Math.random() * Math.PI * 2;
            }

            getBubbleColor() {
                if (this.isRainbow) {
                    // Rainbow effect for special bubbles
                    const hue = (Date.now() * 0.1) % 360;
                    return `hsl(${hue}, 100%, 70%)`;
                }
                
                switch (this.type) {
                    case 'blue': return '#1e90ff';
                    case 'red': return '#ff4500';
                    case 'yellow': return '#ffd700';
                    case 'green': return '#32cd32';
                    case 'purple': return '#9370db';
                    default: return '#64c5ff';
                }
            }

            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                
                // Bubble float effect
                this.y += Math.sin(Date.now() * 0.002 + this.animationOffset) * 0.5;
                
                // Boundary checks with bounce
                if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                    this.velocity.x *= -1;
                }
                
                if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) {
                    this.velocity.y *= -1;
                }
                
                // Slow down over time
                this.velocity.x *= 0.99;
                this.velocity.y *= 0.99;
            }

            draw() {
                ctx.globalAlpha = this.opacity;
                
                // Outer bubble
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // Bubble shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.radius * 0.8, this.radius * 0.5, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 1;
            }
        }

        // Enemy class
        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.velocity = {
                    x: Math.random() * 4 - 2,
                    y: Math.random() * 2 - 1
                };
                this.color = '#ff5252';
                this.frame = 0;
                this.frameCount = 0;
                this.type = this.getRandomType();
                this.slowTimer = 0; // For purple bubble effect
            }
            
            getRandomType() {
                const types = ['popper', 'goop', 'vacublow', 'mimic'];
                return types[Math.floor(Math.random() * types.length)];
            }

            update() {
                // Apply slow effect from purple bubble
                let speedModifier = 1;
                if (this.slowTimer > 0) {
                    this.slowTimer -= 16; // Assuming ~60fps
                    speedModifier = 0.3; // 30% normal speed when slowed
                }
                
                this.x += this.velocity.x * speedModifier;
                this.y += this.velocity.y * speedModifier;
                
                // Boundary checks with bounce
                if (this.x < 0 || this.x + this.width > canvas.width) {
                    this.velocity.x *= -1;
                }
                
                if (this.y < 0 || this.y + this.height > canvas.height) {
                    this.velocity.y *= -1;
                }
                
                // Type-specific behavior
                switch(this.type) {
                    case 'popper':
                        // Popper Patrol - seeks out bubbles to pop them
                        this.popperBehavior();
                        break;
                    case 'goop':
                        // Goop Gliders - occasionally drops slime
                        this.goopBehavior();
                        break;
                    case 'vacublow':
                        // Vacublow Fish - sucks and blows bubbles
                        this.vacublowBehavior();
                        break;
                    case 'mimic':
                        // Bubble Mimics - pretends to be power-ups
                        this.mimicBehavior();
                        break;
                }
                
                // Animation
                this.frameCount++;
                if (this.frameCount >= 10) {
                    this.frame = (this.frame + 1) % 4;
                    this.frameCount = 0;
                }
            }
            
            // Enemy-specific behaviors
            popperBehavior() {
                // Find the nearest bubble and move toward it
                let nearestBubble = null;
                let nearestDistance = Infinity;
                
                bubbles.forEach(bubble => {
                    const dx = bubble.x - (this.x + this.width/2);
                    const dy = bubble.y - (this.y + this.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestBubble = bubble;
                    }
                });
                
                // If a bubble is nearby, seek it
                if (nearestBubble && nearestDistance < 200) {
                    const dx = nearestBubble.x - (this.x + this.width/2);
                    const dy = nearestBubble.y - (this.y + this.height/2);
                    const angle = Math.atan2(dy, dx);
                    
                    this.velocity.x = Math.cos(angle) * 2;
                    this.velocity.y = Math.sin(angle) * 2;
                }
            }
            
            goopBehavior() {
                // Occasionally drop slime particles
                if (Math.random() < 0.02) {
                    particles.push(new Particle(
                        this.x + this.width/2,
                        this.y + this.height,
                        Math.random() * 2 - 1,
                        Math.random() * 2 + 1,
                        Math.random() * 5 + 5,
                        '#8A9A5B'
                    ));
                }
            }
            
            vacublowBehavior() {
                // Suck in and blow out - change direction more frequently
                if (Math.random() < 0.05) {
                    this.velocity.x = Math.random() * 6 - 3;
                    this.velocity.y = Math.random() * 6 - 3;
                }
            }
            
            mimicBehavior() {
                // Change color to look like power-ups
                this.color = BUBBLE_TYPES[Math.floor(Math.random() * BUBBLE_TYPES.length)];
                // Move more erratically
                if (Math.random() < 0.03) {
                    this.velocity.x = Math.random() * 4 - 2;
                    this.velocity.y = Math.random() * 4 - 2;
                }
            }

            draw() {
                // Enemy shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2 + 3, this.y + this.height / 2 + 3, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Enemy body - different appearance based on type
                ctx.fillStyle = this.slowTimer > 0 ? '#9370db' : this.color;
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Type-specific visual elements
                switch(this.type) {
                    case 'popper':
                        // Popper Patrol - many small spikes
                        const popperSpikes = 12;
                        for (let i = 0; i < popperSpikes; i++) {
                            const angle = (i / popperSpikes) * Math.PI * 2 + this.frame * 0.1;
                            const spikeLength = 8;
                            
                            ctx.strokeStyle = '#800000';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(
                                this.x + this.width / 2 + Math.cos(angle) * (this.width / 2),
                                this.y + this.height / 2 + Math.sin(angle) * (this.height / 2)
                            );
                            ctx.lineTo(
                                this.x + this.width / 2 + Math.cos(angle) * (this.width / 2 + spikeLength),
                                this.y + this.height / 2 + Math.sin(angle) * (this.height / 2 + spikeLength)
                            );
                            ctx.stroke();
                        }
                        break;
                        
                    case 'goop':
                        // Goop Gliders - dripping slime
                        ctx.fillStyle = '#8A9A5B';
                        for (let i = 0; i < 5; i++) {
                            const dropX = this.x + this.width/2 + Math.sin(this.frame * 0.2 + i) * 15;
                            const dropHeight = 5 + Math.sin(this.frame * 0.1 + i) * 3;
                            
                            ctx.beginPath();
                            ctx.ellipse(
                                dropX, 
                                this.y + this.height,
                                5, dropHeight,
                                0, 0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                        break;
                        
                    case 'vacublow':
                        // Vacublow Fish - suction-cup mouth
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(
                            this.x + this.width/2 + Math.cos(this.frame * 0.2) * 10,
                            this.y + this.height/2 + Math.sin(this.frame * 0.2) * 10,
                            10, 0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        // Concentric circles for suction effect
                        ctx.strokeStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(
                            this.x + this.width/2 + Math.cos(this.frame * 0.2) * 10,
                            this.y + this.height/2 + Math.sin(this.frame * 0.2) * 10,
                            6, 0, Math.PI * 2
                        );
                        ctx.stroke();
                        break;
                        
                    case 'mimic':
                        // Bubble Mimics - looks like a power-up
                        // Inner highlight to mimic bubbles
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.arc(this.x + this.width/2 - 5, this.y + this.height/2 - 5, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Subtle tell - creepy smile
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(
                            this.x + this.width/2,
                            this.y + this.height/2 + 5,
                            10, 0, Math.PI
                        );
                        ctx.stroke();
                        break;
                        
                    default:
                        // Generic enemy - spikes
                        const spikes = 8;
                        for (let i = 0; i < spikes; i++) {
                            const angle = (i / spikes) * Math.PI * 2 + this.frame * 0.1;
                            const spikeLength = 10;
                            
                            ctx.strokeStyle = '#800000';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(
                                this.x + this.width / 2 + Math.cos(angle) * (this.width / 2),
                                this.y + this.height / 2 + Math.sin(angle) * (this.height / 2)
                            );
                            ctx.lineTo(
                                this.x + this.width / 2 + Math.cos(angle) * (this.width / 2 + spikeLength),
                                this.y + this.height / 2 + Math.sin(angle) * (this.height / 2 + spikeLength)
                            );
                            ctx.stroke();
                        }
                }
                
                // Enemy eyes (all types have eyes)
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2 - 8, this.y + this.height / 2 - 5, 5, 0, Math.PI * 2);
                ctx.arc(this.x + this.width / 2 + 8, this.y + this.height / 2 - 5, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2 - 8, this.y + this.height / 2 - 5, 2, 0, Math.PI * 2);
                ctx.arc(this.x + this.width / 2 + 8, this.y + this.height / 2 - 5, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Show slowed effect
                if (this.slowTimer > 0) {
                    ctx.strokeStyle = '#9370db';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2 + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, velocityX, velocityY, radius, color) {
                this.x = x;
                this.y = y;
                this.velocity = {
                    x: velocityX,
                    y: velocityY
                };
                this.radius = radius;
                this.color = color;
                this.opacity = 1;
                this.gravity = 0.1;
            }

            update() {
                this.velocity.y += this.gravity;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.opacity -= 0.02;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Boss class
        class Boss {
            constructor(bossData) {
                this.name = bossData.name;
                this.health = bossData.health;
                this.maxHealth = bossData.health;
                this.attackPattern = bossData.attackPattern;
                this.x = canvas.width / 2 - 60;
                this.y = 100;
                this.width = 120;
                this.height = 120;
                this.velocity = { x: 2, y: 0 };
                this.attackTimer = 0;
                this.attackCooldown = 3000; // ms between attacks
                this.vulnerable = false;
                this.vulnerableTimer = 0;
                this.sprite = new Image();
                this.sprite.src = bossData.sprite;
                this.frame = 0;
                this.frameCount = 0;
                this.attackProjectiles = [];
            }
            
            update(deltaTime) {
                // Basic movement
                this.x += this.velocity.x;
                if (this.x <= 0 || this.x + this.width >= canvas.width) {
                    this.velocity.x *= -1;
                }
                
                // Animation
                this.frameCount++;
                if (this.frameCount >= 10) {
                    this.frame = (this.frame + 1) % 4;
                    this.frameCount = 0;
                }
                
                // Attack logic
                this.attackTimer += deltaTime;
                if (this.attackTimer >= this.attackCooldown) {
                    this.attack();
                    this.attackTimer = 0;
                }
                
                // Vulnerability period
                if (this.vulnerable) {
                    this.vulnerableTimer -= deltaTime;
                    if (this.vulnerableTimer <= 0) {
                        this.vulnerable = false;
                    }
                }
                
                // Update attack projectiles
                this.attackProjectiles = this.attackProjectiles.filter(proj => {
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    
                    // Check collision with player
                    const dx = player.x + player.width/2 - proj.x;
                    const dy = player.y + player.height/2 - proj.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < player.width/2 + proj.radius) {
                        player.hitEnemy();
                        return false;
                    }
                    
                    // Remove if off-screen
                    return proj.x > 0 && proj.x < canvas.width && 
                           proj.y > 0 && proj.y < canvas.height;
                });
            }
            
            draw() {
                // Draw boss
                ctx.save();
                
                // Flash when vulnerable
                if (this.vulnerable && Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.globalAlpha = 0.7;
                }
                
                // Draw the boss sprite
                ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height);
                
                // Health bar
                const healthBarWidth = 100;
                const healthBarHeight = 10;
                const healthPercentage = this.health / this.maxHealth;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(this.x + this.width/2 - healthBarWidth/2, this.y - 20, healthBarWidth, healthBarHeight);
                
                ctx.fillStyle = this.vulnerable ? '#ffff00' : '#ff3333';
                ctx.fillRect(
                    this.x + this.width/2 - healthBarWidth/2, 
                    this.y - 20, 
                    healthBarWidth * healthPercentage, 
                    healthBarHeight
                );
                
                // Boss name
                ctx.font = '12px "Press Start 2P"';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, this.x + this.width/2, this.y - 30);
                
                ctx.restore();
                
                // Draw attack projectiles
                this.attackProjectiles.forEach(proj => {
                    ctx.fillStyle = proj.color;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            attack() {
                const attackSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=boss%20attack%20sound&duration=1&ext=.mp3');
                attackSound.volume = 0.6;
                attackSound.play();
                
                switch(this.attackPattern) {
                    case 'wind':
                        // Wind attack - pushes player
                        for (let i = 0; i < 5; i++) {
                            this.attackProjectiles.push({
                                x: this.x + this.width/2,
                                y: this.y + this.height/2,
                                vx: Math.cos(i * Math.PI/2.5) * 5,
                                vy: Math.sin(i * Math.PI/2.5) * 5,
                                radius: 15,
                                color: 'rgba(200, 230, 255, 0.7)'
                            });
                        }
                        break;
                        
                    case 'slime':
                        // Slime attack - creates sticky areas
                        for (let i = 0; i < 3; i++) {
                            this.attackProjectiles.push({
                                x: this.x + this.width/2,
                                y: this.y + this.height/2,
                                vx: (Math.random() - 0.5) * 8,
                                vy: Math.random() * 5 + 2,
                                radius: 20,
                                color: '#8A9A5B'
                            });
                        }
                        break;
                        
                    case 'inflate':
                        // Inflate attack - expands and contracts
                        this.width = 150;
                        this.height = 150;
                        setTimeout(() => {
                            this.width = 120;
                            this.height = 120;
                            
                            // Release projectiles in all directions
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                this.attackProjectiles.push({
                                    x: this.x + this.width/2,
                                    y: this.y + this.height/2,
                                    vx: Math.cos(angle) * 6,
                                    vy: Math.sin(angle) * 6,
                                    radius: 10,
                                    color: '#ff5252'
                                });
                            }
                        }, 1000);
                        break;
                        
                    case 'swallow':
                        // Swallow attack - tries to pull player in
                        const dx = player.x - (this.x + this.width/2);
                        const dy = player.y - (this.y + this.height/2);
                        const angle = Math.atan2(dy, dx);
                        
                        for (let i = 0; i < 3; i++) {
                            this.attackProjectiles.push({
                                x: this.x + this.width/2 + Math.cos(angle) * 50,
                                y: this.y + this.height/2 + Math.sin(angle) * 50,
                                vx: Math.cos(angle) * 7,
                                vy: Math.sin(angle) * 7,
                                radius: 25,
                                color: 'rgba(100, 100, 100, 0.7)'
                            });
                        }
                        break;
                        
                    case 'chaos':
                        // Chaos attack - mix of all previous attacks
                        const attackType = Math.floor(Math.random() * 4);
                        this.attackPattern = ['wind', 'slime', 'inflate', 'swallow'][attackType];
                        this.attack();
                        this.attackPattern = 'chaos';
                        break;
                }
                
                // Become vulnerable after attacking
                this.vulnerable = true;
                this.vulnerableTimer = 2000;
            }
            
            hit() {
                if (this.vulnerable) {
                    this.health--;
                    this.vulnerable = false;
                    
                    // Hit effect
                    for (let i = 0; i < 15; i++) {
                        particles.push(new Particle(
                            this.x + this.width/2,
                            this.y + this.height/2,
                            Math.random() * 8 - 4,
                            Math.random() * 8 - 4,
                            Math.random() * 5 + 5,
                            '#ffff00'
                        ));
                    }
                    
                    const hitSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=boss%20hurt%20sound&duration=0.5&ext=.mp3');
                    hitSound.play();
                    
                    if (this.health <= 0) {
                        this.defeat();
                    }
                }
            }
            
            defeat() {
                // Boss defeat explosion
                for (let i = 0; i < 50; i++) {
                    particles.push(new Particle(
                        this.x + this.width/2,
                        this.y + this.height/2,
                        Math.random() * 10 - 5,
                        Math.random() * 10 - 5,
                        Math.random() * 8 + 5,
                        '#ffff00'
                    ));
                }
                
                const defeatSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=boss%20defeat%20explosion&duration=2&ext=.mp3');
                defeatSound.play();
                
                // Advance to next world
                setTimeout(() => {
                    advanceWorld();
                }, 2000);
            }
        }
        
        // Special feature classes
        class WindTunnel {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.strength = 0.5;
                this.particleTimer = 0;
            }
            
            update(deltaTime) {
                // Check if player is in wind tunnel
                if (player.x + player.width > this.x && 
                    player.x < this.x + this.width && 
                    player.y + player.height > this.y && 
                    player.y < this.y + this.height) {
                    // Apply upward force
                    player.velocity.y -= this.strength;
                }
                
                // Create wind particles
                this.particleTimer += deltaTime;
                if (this.particleTimer > 100) {
                    particles.push(new Particle(
                        this.x + Math.random() * this.width,
                        this.y + this.height,
                        (Math.random() - 0.5) * 2,
                        -Math.random() * 3 - 2,
                        Math.random() * 3 + 2,
                        'rgba(255, 255, 255, 0.5)'
                    ));
                    this.particleTimer = 0;
                }
            }
            
            draw() {
                ctx.fillStyle = 'rgba(200, 230, 255, 0.3)';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Wind direction indicators
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
                
                for (let y = this.y + this.height - 10; y > this.y; y -= 20) {
                    ctx.beginPath();
                    ctx.moveTo(this.x + 10, y);
                    ctx.lineTo(this.x + this.width/2, y - 15);
                    ctx.lineTo(this.x + this.width - 10, y);
                    ctx.stroke();
                }
            }
        }
        
        class Geyser {
            constructor(x, width) {
                this.x = x;
                this.width = width;
                this.y = canvas.height - 30; // Bottom of the screen
                this.height = 0; // Starts hidden
                this.maxHeight = 200;
                this.active = false;
                this.timer = Math.random() * 5000; // Random start time
                this.burstStrength = 20;
            }
            
            update(deltaTime) {
                this.timer -= deltaTime;
                
                if (this.timer <= 0) {
                    if (!this.active) {
                        // Start eruption
                        this.active = true;
                        this.timer = 2000; // Eruption lasts 2 seconds
                        const warningSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=geyser%20rumble%20warning&duration=1&ext=.mp3');
                        warningSound.volume = 0.5;
                        warningSound.play();
                    } else {
                        // End eruption
                        this.active = false;
                        this.timer = Math.random() * 3000 + 2000; // Random cooldown
                    }
                }
                
                if (this.active) {
                    // Grow geyser
                    this.height = Math.min(this.height + 10, this.maxHeight);
                    
                    // Check player collision
                    if (player.x + player.width > this.x && 
                        player.x < this.x + this.width && 
                        player.y + player.height > canvas.height - 30 - this.height) {
                        // Launch player upward
                        player.velocity.y = -this.burstStrength;
                        
                        // Create burst particles
                        for (let i = 0; i < 10; i++) {
                            particles.push(new Particle(
                                player.x + player.width/2,
                                player.y + player.height,
                                Math.random() * 6 - 3,
                                -Math.random() * 4 - 2,
                                Math.random() * 5 + 3,
                                '#7de2ff'
                            ));
                        }
                    }
                    
                    // Create geyser particles
                    if (Math.random() > 0.7) {
                        particles.push(new Particle(
                            this.x + Math.random() * this.width,
                            canvas.height - 30 - Math.random() * this.height,
                            Math.random() * 4 - 2,
                            -Math.random() * 2 - 1,
                            Math.random() * 4 + 2,
                            '#7de2ff'
                        ));
                    }
                } else {
                    // Shrink geyser
                    this.height = Math.max(0, this.height - 15);
                }
            }
            
            draw() {
                if (this.height <= 0) return;
                
                // Draw geyser
                ctx.fillStyle = 'rgba(125, 226, 255, 0.7)';
                ctx.fillRect(this.x, canvas.height - 30 - this.height, this.width, this.height);
                
                // Draw geyser edges
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(this.x, canvas.height - 30 - this.height, 3, this.height);
                ctx.fillRect(this.x + this.width - 3, canvas.height - 30 - this.height, 3, this.height);
            }
        }
        
        class Lightning {
            constructor() {
                this.active = false;
                this.warningX = 0;
                this.warningY = 0;
                this.warningRadius = 0;
                this.timer = Math.random() * 5000 + 2000; // Random initial delay
                this.warningTime = 1000; // Warning duration
                this.strikeWidth = 100;
            }
            
            update(deltaTime) {
                this.timer -= deltaTime;
                
                if (this.timer <= 0) {
                    if (!this.active) {
                        // Start warning
                        this.active = true;
                        this.warningX = Math.random() * canvas.width;
                        this.warningY = Math.random() * (canvas.height - 100);
                        this.warningRadius = 0;
                        this.timer = this.warningTime;
                        
                        const warningSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=electricity%20charging%20warning&duration=1&ext=.mp3');
                        warningSound.volume = 0.5;
                        warningSound.play();
                    } else {
                        // Strike lightning
                        this.strike();
                        this.active = false;
                        this.timer = Math.random() * 5000 + 3000; // Random cooldown
                    }
                }
                
                if (this.active) {
                    // Grow warning indicator
                    this.warningRadius = (1 - (this.timer / this.warningTime)) * this.strikeWidth/2;
                }
            }
            
            strike() {
                // Lightning strike effect
                const strikeSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=lightning%20strike%20thunder&duration=1&ext=.mp3');
                strikeSound.volume = 0.7;
                strikeSound.play();
                
                // Create lightning particles
                for (let i = 0; i < 30; i++) {
                    particles.push(new Particle(
                        this.warningX + (Math.random() - 0.5) * this.strikeWidth,
                        this.warningY + (Math.random() - 0.5) * 20,
                        Math.random() * 6 - 3,
                        Math.random() * 10 + 5,
                        Math.random() * 5 + 3,
                        '#f8f8ff'
                    ));
                }
                
                // Check if player is hit
                const dx = player.x + player.width/2 - this.warningX;
                const dy = player.y + player.height/2 - this.warningY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < this.strikeWidth/2 + player.width/2) {
                    player.hitEnemy();
                }
            }
            
            draw() {
                if (!this.active) return;
                
                // Draw warning circle
                ctx.beginPath();
                ctx.arc(this.warningX, this.warningY, this.warningRadius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 0, ${0.3 + Math.sin(Date.now() * 0.01) * 0.2})`;
                ctx.fill();
                
                // Draw warning text
                ctx.font = '12px "Press Start 2P"';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.fillText('!', this.warningX, this.warningY + 5);
            }
        }
        
        class Fog {
            constructor() {
                this.fogPatches = [];
                this.visibility = 200; // Visible radius around player
                
                // Create initial fog patches
                for (let i = 0; i < 10; i++) {
                    this.fogPatches.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: Math.random() * 100 + 50,
                        opacity: Math.random() * 0.5 + 0.3
                    });
                }
            }
            
            update() {
                // Move fog patches slowly
                this.fogPatches.forEach(patch => {
                    patch.x += Math.sin(Date.now() * 0.001 + patch.y) * 0.5;
                    patch.y += Math.cos(Date.now() * 0.001 + patch.x) * 0.3;
                    
                    // Wrap around screen
                    if (patch.x < -patch.radius) patch.x = canvas.width + patch.radius;
                    if (patch.x > canvas.width + patch.radius) patch.x = -patch.radius;
                    if (patch.y < -patch.radius) patch.y = canvas.height + patch.radius;
                    if (patch.y > canvas.height + patch.radius) patch.y = -patch.radius;
                });
            }
            
            draw() {
                // Draw fog overlay
                ctx.fillStyle = 'rgba(200, 200, 210, 0.4)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw fog patches
                this.fogPatches.forEach(patch => {
                    ctx.fillStyle = `rgba(220, 220, 230, ${patch.opacity})`;
                    ctx.beginPath();
                    ctx.arc(patch.x, patch.y, patch.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Create visibility circle around player
                ctx.globalCompositeOperation = 'destination-out';
                const gradient = ctx.createRadialGradient(
                    player.x + player.width/2, player.y + player.height/2, 0,
                    player.x + player.width/2, player.y + player.height/2, this.visibility
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, player.y + player.height/2, this.visibility, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }
        }
        
        // Initialize game objects
        function initGame() {
            // Reset game state values
            gameState.bubblesCollected = 0;
            gameState.showingBoss = false;
            
            // Set world-specific difficulty
            gameState.bubblesNeeded = 15 + (gameState.worldIndex * 5);
            
            // Load world-specific background
            worldBackgroundImage.src = GAME_WORLDS[gameState.worldIndex].background;
            
            // Load world-specific music
            bgMusic.pause();
            bgMusic.src = GAME_WORLDS[gameState.worldIndex].music;
            bgMusic.play();
            
            // Create ground platform first to ensure it's available immediately
            platforms = [];
            platforms.push(new Platform(0, canvas.height - 30, canvas.width, 30));
            
            // Initialize player above the ground platform
            player = new Player(canvas.width / 2 - PLAYER_SIZE / 2, canvas.height - 100);
            
            bubbles = [];
            enemies = [];
            particles = [];
            specialFeatures = [];
            rainbowBubbles = [];
            currentBoss = null;
            
            // Create initial platforms with world-specific color
            const platformColor = GAME_WORLDS[gameState.worldIndex].platformColor;
            for (let i = 0; i < 8; i++) {
                const platform = new Platform(
                    Math.random() * (canvas.width - 150),
                    Math.random() * (canvas.height - 200) + 100, // Adjusted height range
                    Math.random() * 50 + 100,
                    PLATFORM_HEIGHT
                );
                platform.color = platformColor;
                platforms.push(platform);
            }
            
            // Create initial bubbles
            for (let i = 0; i < 15; i++) {
                bubbles.push(new Bubble(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                ));
            }
            
            // Create initial enemies - more enemies in higher worlds
            for (let i = 0; i < 2 + gameState.worldIndex; i++) {
                enemies.push(new Enemy(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (canvas.height - 200) + 50
                ));
            }
            
            // Add world-specific special features
            const feature = GAME_WORLDS[gameState.worldIndex].specialFeature;
            switch(feature) {
                case 'windTunnels':
                    for (let i = 0; i < 3; i++) {
                        specialFeatures.push(new WindTunnel(
                            Math.random() * (canvas.width - 200) + 100,
                            Math.random() * (canvas.height - 300) + 150,
                            100,
                            200
                        ));
                    }
                    break;
                    
                case 'geysers':
                    for (let i = 0; i < 3; i++) {
                        specialFeatures.push(new Geyser(
                            Math.random() * (canvas.width - 100) + 50,
                            80
                        ));
                    }
                    break;
                    
                case 'lightning':
                    specialFeatures.push(new Lightning());
                    break;
                    
                case 'fog':
                    specialFeatures.push(new Fog());
                    break;
                    
                case 'reverseGravity':
                    // Reverse gravity is handled in the player update function
                    GRAVITY = -0.5; // Reverse gravity
                    break;
            }
            
            // Add rainbow bubble (1 per level)
            const rainbowBubble = new Bubble(
                Math.random() * (canvas.width - 100) + 50,
                Math.random() * (canvas.height - 200) + 100
            );
            rainbowBubble.isRainbow = true;
            bubbles.push(rainbowBubble);
        }

        // Game loop
        // Show level complete UI
        function showLevelComplete() {
            gameState.gamePaused = true;
            
            // Create level complete overlay
            const levelComplete = document.createElement('div');
            levelComplete.style.position = 'absolute';
            levelComplete.style.top = '0';
            levelComplete.style.left = '0';
            levelComplete.style.width = '100%';
            levelComplete.style.height = '100%';
            levelComplete.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            levelComplete.style.display = 'flex';
            levelComplete.style.flexDirection = 'column';
            levelComplete.style.justifyContent = 'center';
            levelComplete.style.alignItems = 'center';
            levelComplete.style.zIndex = '20';
            
            // Add level complete text
            const completeText = document.createElement('h2');
            completeText.textContent = 'Level Complete!';
            completeText.style.color = '#f8d800';
            completeText.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            completeText.style.fontSize = '32px';
            completeText.style.marginBottom = '20px';
            levelComplete.appendChild(completeText);
            
            // Add score
            const scoreText = document.createElement('p');
            scoreText.textContent = `Score: ${gameState.score}`;
            scoreText.style.color = '#ffffff';
            scoreText.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            scoreText.style.fontSize = '18px';
            scoreText.style.marginBottom = '10px';
            levelComplete.appendChild(scoreText);
            
            // Add rainbow bubbles found
            if (gameState.rainbowBubblesFound > 0) {
                const rainbowText = document.createElement('p');
                rainbowText.textContent = `Rainbow Bubbles: ${gameState.rainbowBubblesFound}/${(gameState.worldIndex * 6) + gameState.levelIndex + 1}`;
                rainbowText.style.color = '#ff44ff';
                rainbowText.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
                rainbowText.style.fontSize = '14px';
                rainbowText.style.marginBottom = '20px';
                levelComplete.appendChild(rainbowText);
            }
            
            // Add boss battle button
            const bossButton = document.createElement('button');
            bossButton.textContent = 'Boss Battle!';
            bossButton.style.backgroundColor = '#ff4081';
            bossButton.style.color = 'white';
            bossButton.style.border = 'none';
            bossButton.style.padding = '15px 30px';
            bossButton.style.fontSize = '18px';
            bossButton.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            bossButton.style.borderRadius = '10px';
            bossButton.style.cursor = 'pointer';
            bossButton.style.transition = 'all 0.3s';
            bossButton.style.boxShadow = '0 4px 0 #c60055';
            bossButton.style.marginTop = '20px';
            
            bossButton.addEventListener('mouseover', () => {
                bossButton.style.transform = 'translateY(-5px)';
                bossButton.style.boxShadow = '0 9px 0 #c60055';
            });
            
            bossButton.addEventListener('mouseout', () => {
                bossButton.style.transform = 'translateY(0)';
                bossButton.style.boxShadow = '0 4px 0 #c60055';
            });
            
            bossButton.addEventListener('click', () => {
                document.getElementById('game-container').removeChild(levelComplete);
                startBossBattle();
            });
            
            levelComplete.appendChild(bossButton);
            
            // Add to container
            document.getElementById('game-container').appendChild(levelComplete);
            
            // Play completion sound
            const completionSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=level%20complete%20fanfare&duration=2&ext=.mp3');
            completionSound.play();
        }
        
        // Start boss battle
        function startBossBattle() {
            gameState.showingBoss = true;
            gameState.gamePaused = false;
            
            // Clear most existing entities
            bubbles = [];
            enemies = [];
            
            // Create boss
            currentBoss = new Boss(GAME_WORLDS[gameState.worldIndex].boss);
            
            // Change music for boss battle
            bgMusic.pause();
            bgMusic.src = 'https://sounds.fuzzycode.dev/music?prompt=intense%20boss%20battle%20chiptune&duration=30&ext=.mp3';
            bgMusic.play();
            
            // Show boss introduction
            const bossIntro = document.createElement('div');
            bossIntro.style.position = 'absolute';
            bossIntro.style.top = '50%';
            bossIntro.style.left = '0';
            bossIntro.style.width = '100%';
            bossIntro.style.textAlign = 'center';
            bossIntro.style.color = '#ff4081';
            bossIntro.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            bossIntro.style.fontSize = '24px';
            bossIntro.style.textShadow = '2px 2px 0 #000';
            bossIntro.style.zIndex = '15';
            bossIntro.style.transform = 'translateY(-50%)';
            bossIntro.textContent = currentBoss.name;
            
            document.getElementById('game-container').appendChild(bossIntro);
            
            // Remove intro after 3 seconds
            setTimeout(() => {
                document.getElementById('game-container').removeChild(bossIntro);
            }, 3000);
        }
        
        // Advance to next world
        function advanceWorld() {
            // Check if game is complete
            if (gameState.worldIndex >= 4 && gameState.levelIndex >= 5) {
                gameComplete();
                return;
            }
            
            // Advance level or world
            gameState.levelIndex++;
            if (gameState.levelIndex > 5) {
                gameState.worldIndex++;
                gameState.levelIndex = 0;
            }
            
            // Initialize next level
            initGame();
            
            // Show world introduction
            const worldIntro = document.createElement('div');
            worldIntro.style.position = 'absolute';
            worldIntro.style.top = '0';
            worldIntro.style.left = '0';
            worldIntro.style.width = '100%';
            worldIntro.style.height = '100%';
            worldIntro.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            worldIntro.style.display = 'flex';
            worldIntro.style.flexDirection = 'column';
            worldIntro.style.justifyContent = 'center';
            worldIntro.style.alignItems = 'center';
            worldIntro.style.zIndex = '20';
            
            const worldTitle = document.createElement('h2');
            worldTitle.textContent = GAME_WORLDS[gameState.worldIndex].name;
            worldTitle.style.color = '#f8d800';
            worldTitle.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            worldTitle.style.fontSize = '32px';
            worldTitle.style.marginBottom = '20px';
            
            const levelText = document.createElement('p');
            levelText.textContent = `Level ${gameState.levelIndex + 1}`;
            levelText.style.color = '#ffffff';
            levelText.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            levelText.style.fontSize = '18px';
            levelText.style.marginBottom = '30px';
            
            const continueText = document.createElement('p');
            continueText.textContent = 'Press any key to continue';
            continueText.style.color = '#aaaaaa';
            continueText.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            continueText.style.fontSize = '14px';
            
            worldIntro.appendChild(worldTitle);
            worldIntro.appendChild(levelText);
            worldIntro.appendChild(continueText);
            
            document.getElementById('game-container').appendChild(worldIntro);
            
            // Pause game until key press
            gameState.gamePaused = true;
            
            // Listen for any key press
            const continueHandler = (e) => {
                document.getElementById('game-container').removeChild(worldIntro);
                gameState.gamePaused = false;
                document.removeEventListener('keydown', continueHandler);
            };
            
            document.addEventListener('keydown', continueHandler);
        }
        
        // Game completion
        function gameComplete() {
            cancelAnimationFrame(animationId);
            bgMusic.pause();
            
            // Check for secret ending
            const hasSecretEnding = gameState.rainbowBubblesFound >= 30; // 30 rainbow bubbles total
            
            // Create ending screen
            const endingScreen = document.createElement('div');
            endingScreen.style.position = 'absolute';
            endingScreen.style.top = '0';
            endingScreen.style.left = '0';
            endingScreen.style.width = '100%';
            endingScreen.style.height = '100%';
            endingScreen.style.backgroundColor = hasSecretEnding ? 'rgba(100, 0, 150, 0.9)' : 'rgba(0, 50, 100, 0.9)';
            endingScreen.style.display = 'flex';
            endingScreen.style.flexDirection = 'column';
            endingScreen.style.justifyContent = 'center';
            endingScreen.style.alignItems = 'center';
            endingScreen.style.zIndex = '30';
            
            const endingTitle = document.createElement('h1');
            endingTitle.textContent = hasSecretEnding ? 'Secret Ending Achieved!' : 'Congratulations!';
            endingTitle.style.color = '#f8d800';
            endingTitle.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            endingTitle.style.fontSize = '32px';
            endingTitle.style.marginBottom = '30px';
            endingTitle.style.textAlign = 'center';
            
            const endingText = document.createElement('p');
            endingText.innerHTML = hasSecretEnding ? 
                'You collected all the Rainbow Bubbles!<br>Pip has become the new Guardian of Aerispring!' : 
                'You defeated Mistweaver and saved Aerispring!<br>Magic flows freely once again!';
            endingText.style.color = '#ffffff';
            endingText.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            endingText.style.fontSize = '16px';
            endingText.style.marginBottom = '30px';
            endingText.style.textAlign = 'center';
            endingText.style.lineHeight = '1.5';
            
            const finalScore = document.createElement('p');
            finalScore.textContent = `Final Score: ${gameState.score}`;
            finalScore.style.color = '#aaffaa';
            finalScore.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            finalScore.style.fontSize = '24px';
            finalScore.style.marginBottom = '40px';
            
            const playAgainButton = document.createElement('button');
            playAgainButton.textContent = 'Play Again';
            playAgainButton.style.backgroundColor = '#6a4bc4';
            playAgainButton.style.color = 'white';
            playAgainButton.style.border = 'none';
            playAgainButton.style.padding = '15px 30px';
            playAgainButton.style.fontSize = '18px';
            playAgainButton.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            playAgainButton.style.borderRadius = '10px';
            playAgainButton.style.cursor = 'pointer';
            playAgainButton.style.transition = 'all 0.3s';
            
            playAgainButton.addEventListener('click', () => {
                document.getElementById('game-container').removeChild(endingScreen);
                gameState.worldIndex = 0;
                gameState.levelIndex = 0;
                gameState.rainbowBubblesFound = 0;
                gameState.score = 0;
                GRAVITY = 0.5; // Reset gravity
                startGame();
            });
            
            endingScreen.appendChild(endingTitle);
            endingScreen.appendChild(endingText);
            endingScreen.appendChild(finalScore);
            endingScreen.appendChild(playAgainButton);
            
            document.getElementById('game-container').appendChild(endingScreen);
            
            // Play ending music
            const endingMusic = new Audio(hasSecretEnding ? 
                'https://sounds.fuzzycode.dev/music?prompt=triumphant%20magical%20victory%20chiptune&duration=30&ext=.mp3' : 
                'https://sounds.fuzzycode.dev/music?prompt=happy%20ending%20chiptune&duration=30&ext=.mp3');
            endingMusic.play();
        }
        
        function gameLoop(timestamp) {
            if (gameState.gamePaused) {
                animationId = requestAnimationFrame(gameLoop);
                return;
            }
            
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background with parallax effect (layered backgrounds)
            // Main background
            ctx.drawImage(worldBackgroundImage, 0, 0, canvas.width, canvas.height);
            
            // Draw world name and level
            ctx.font = '16px "Press Start 2P"';
            ctx.fillStyle = '#f8d800';
            ctx.textAlign = 'right';
            
            const worldName = GAME_WORLDS[gameState.worldIndex].name;
            const levelText = gameState.showingBoss ? "BOSS" : `Level ${gameState.levelIndex + 1}`;
            
            ctx.fillText(`${worldName} - ${levelText}`, canvas.width - 20, 30);
            
            // Update and draw platforms
            platforms.forEach(platform => {
                platform.update();
                platform.draw();
                
                // Platform collision
                if (player.velocity.y > 0 && // Only check when moving downward
                    player.y + player.height <= platform.y + 10 && // Added tolerance
                    player.y + player.height + player.velocity.y >= platform.y &&
                    player.x + player.width / 2 > platform.x && 
                    player.x + player.width / 2 < platform.x + platform.width) {
                    
                    player.y = platform.y - player.height;
                    player.velocity.y = 0;
                    player.isGrounded = true;
                    player.canBounce = true;
                    player.collisionDebounce = 5; // Set debounce to prevent immediate fall-through
                    
                    // Apply platform movement to player
                    if (platform.isMoving) {
                        player.x += platform.velocity.x;
                    }
                }
            });
            
            // Update and draw bubbles
            bubbles.forEach((bubble, index) => {
                bubble.update();
                bubble.draw();
                
                // Bubble collection
                const dx = player.x + player.width / 2 - bubble.x;
                const dy = player.y + player.height / 2 - bubble.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.width / 2 + bubble.radius) {
                    player.collectBubble(bubble);
                    bubbles.splice(index, 1);
                    
                    // Spawn new bubble
                    if (Math.random() > 0.3) {
                        bubbles.push(new Bubble(
                            Math.random() * canvas.width,
                            Math.random() * 100
                        ));
                    }
                }
            });
            
            // Update and draw enemies
            enemies.forEach(enemy => {
                enemy.update();
                enemy.draw();
                
                // Enemy collision
                const dx = player.x + player.width / 2 - (enemy.x + enemy.width / 2);
                const dy = player.y + player.height / 2 - (enemy.y + enemy.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.width / 2 + enemy.width / 2) {
                    player.hitEnemy();
                }
            });
            
            // Update and draw particles
            particles = particles.filter(particle => {
                particle.update();
                particle.draw();
                return particle.opacity > 0;
            });
            
            // Update and draw player
            player.update(deltaTime);
            player.draw();
            
            // Check for bubble spawn
            if (Math.random() < 0.01 && bubbles.length < 20) {
                bubbles.push(new Bubble(
                    Math.random() * canvas.width,
                    0
                ));
            }
            
            // Check for enemy spawn
            if (Math.random() < 0.002 && enemies.length < 5) {
                enemies.push(new Enemy(
                    Math.random() * canvas.width,
                    0
                ));
            }
            
            // Display current power-up info if active
            if (player.powerUp) {
                ctx.font = '12px "Press Start 2P"';
                ctx.fillStyle = player.getPowerUpColor();
                ctx.textAlign = 'left';
                ctx.fillText(BUBBLE_DESCRIPTIONS[player.powerUp], 10, 70);
                
                // Show power-up timer
                const timerWidth = 100;
                const timerHeight = 10;
                const timerX = 10;
                const timerY = 80;
                const timerFill = (player.powerUpTimer / 5000) * timerWidth;
                
                // Timer background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(timerX, timerY, timerWidth, timerHeight);
                
                // Timer fill
                ctx.fillStyle = player.getPowerUpColor();
                ctx.fillRect(timerX, timerY, timerFill, timerHeight);
            }
            
            // Display consecutive bounce count for player feedback
            if (player.consecutiveBounces > 1) {
                ctx.font = '16px "Press Start 2P"';
                ctx.fillStyle = '#f8d800';
                ctx.textAlign = 'center';
                ctx.fillText(`Bounce x${player.consecutiveBounces}`, player.x + player.width/2, player.y - 20);
            }
            
            // Update and draw special features
            specialFeatures.forEach(feature => {
                feature.update(deltaTime);
                feature.draw();
            });
            
            // Update and draw boss if present
            if (currentBoss) {
                currentBoss.update(deltaTime);
                currentBoss.draw();
                
                // Check boss collision with player attack (red explosive bubble)
                if (player.powerUp === 'red' && player.isBouncing) {
                    const dx = currentBoss.x + currentBoss.width/2 - (player.x + player.width/2);
                    const dy = currentBoss.y + currentBoss.height/2 - (player.y + player.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < player.width/2 + currentBoss.width/2) {
                        currentBoss.hit();
                    }
                }
            }
            
            // Display progress to next level
            if (!gameState.showingBoss) {
                // Progress bar for bubbles collected
                const progressWidth = 150;
                const progressHeight = 10;
                const progressX = canvas.width - progressWidth - 20;
                const progressY = 40;
                const progressFill = (gameState.bubblesCollected / gameState.bubblesNeeded) * progressWidth;
                
                // Progress bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(progressX, progressY, progressWidth, progressHeight);
                
                // Progress bar fill
                ctx.fillStyle = '#64c5ff';
                ctx.fillRect(progressX, progressY, progressFill, progressHeight);
                
                // Progress text
                ctx.font = '12px "Press Start 2P"';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'right';
                ctx.fillText(`${gameState.bubblesCollected}/${gameState.bubblesNeeded}`, progressX + progressWidth, progressY + 25);
            }
            
            // Display rainbow bubbles found
            if (gameState.rainbowBubblesFound > 0) {
                ctx.font = '12px "Press Start 2P"';
                ctx.fillStyle = '#ff44ff';
                ctx.textAlign = 'left';
                ctx.fillText(`Rainbow: ${gameState.rainbowBubblesFound}`, 10, 110);
            }
            
            // Request next frame
            animationId = requestAnimationFrame(gameLoop);
        }

        // Event handlers
        function handleKeyDown(e) {
            switch (e.key) {
                case 'ArrowLeft':
                    gameState.keyState.left = true;
                    break;
                case 'ArrowRight':
                    gameState.keyState.right = true;
                    break;
                case 'ArrowUp':
                case ' ':
                    if (!gameState.keyState.space) {
                        gameState.keyState.space = true;
                        player.bounce();
                    }
                    break;
                case 'z':
                case 'Z':
                    player.toggleBubbleState();
                    break;
                case 'p':
                case 'P':
                    togglePause();
                    break;
            }
        }

        function handleKeyUp(e) {
            switch (e.key) {
                case 'ArrowLeft':
                    gameState.keyState.left = false;
                    break;
                case 'ArrowRight':
                    gameState.keyState.right = false;
                    break;
                case 'ArrowUp':
                case ' ':
                    gameState.keyState.space = false;
                    break;
            }
        }

        function togglePause() {
            gameState.gamePaused = !gameState.gamePaused;
            pauseButton.textContent = gameState.gamePaused ? '' : 'II';
        }

        function startGame() {
            titleScreen.style.display = 'none';
            hud.style.display = 'block';
            pauseButton.style.display = 'block';
            
            gameState.score = 0;
            gameState.lives = 3;
            gameState.gameActive = true;
            
            scoreDisplay.textContent = `Score: ${gameState.score}`;
            livesDisplay.textContent = `Lives: ${gameState.lives}`;
            
            initGame();
            lastTime = performance.now();
            
            // Start background music
            bgMusic.play();
            
            // Start game loop
            animationId = requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameState.gameActive = false;
            cancelAnimationFrame(animationId);
            bgMusic.pause();
            sounds.gameOver.play();
            
            finalScoreDisplay.textContent = `Final Score: ${gameState.score}`;
            gameOverScreen.style.display = 'flex';
        }

        function restartGame() {
            gameOverScreen.style.display = 'none';
            startGame();
        }

        // Create floating bubbles in the background of title screen
        function createTitleBubbles() {
            for (let i = 0; i < 20; i++) {
                const bubble = document.createElement('div');
                bubble.classList.add('bubble');
                bubble.style.width = `${Math.random() * 50 + 20}px`;
                bubble.style.height = bubble.style.width;
                bubble.style.left = `${Math.random() * 100}%`;
                bubble.style.top = `${Math.random() * 100}%`;
                bubble.style.animationDuration = `${Math.random() * 4 + 3}s`;
                bubble.style.animationDelay = `${Math.random() * 2}s`;
                document.getElementById('game-container').appendChild(bubble);
            }
        }

        // Event listeners
        startButton.addEventListener('click', startGame);
        pauseButton.addEventListener('click', togglePause);
        restartButton.addEventListener('click', restartGame);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        // Initialize title screen bubbles
        createTitleBubbles();
    </script>
</body>
</html>