<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Fluffy Rope Swinger - Fullscreen Pendulum</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #1a1a1a;
    overflow: hidden;
    width: 100%;
    height: 100%;
    font-family: sans-serif;
  }

  #gameCanvas {
    display: block;
    background: #333;
  }

  .instructions {
    position: absolute;
    top: 10px;
    left: 10px;
    color: #fff;
    background: rgba(0,0,0,0.5);
    padding: 8px;
    border-radius: 4px;
    font-size: 14px;
    z-index: 9999;
  }
</style>
</head>
<body>

<div id="instructions" class="instructions">
  <b>Controls:</b><br/>
  Press and hold Space to hook onto the nearest anchor above you. Release to let go.<br/>
  Press Space to start the game.<br/><br/>
  The nearest anchor to hook will be highlighted with a dotted circle.<br/>
  The fluffy swinger will swing more freely and not lose momentum too quickly, and upon release will not drop straight down as rapidly.
</div>

<script src="https://fuzzycode.dev/@cdn/resolve?url=https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
<script>
    const levels = [{"level_data":["....K...K...K...K...K....",".........................",".........................","P......................G.",".........................","........................."]},{"level_data":["P                                             ","       K                 K                    ","                                              ","           K                                 G","                                              ","                                              ","                    K           K             ","                                              ","               K                              "]}];
class MainScene extends Phaser.Scene {
  preload() {
    this.load.image('bgTile', 'https://fuzzycode.dev/@images/fast_ai?search=subtle gray geometric gaming background pattern&resize=128x128');
    this.load.image('player', 'https://fuzzycode.dev/@aws/image_buddy_365day_cache/uploads/1c159ab3-db18-4cfe-847d-0342d6f3038c/player!resize_64x64_7968ffe1ef.png');
    this.load.image('knob', 'https://fuzzycode.dev/@images/fast_ai?search=red metal knob hook attachment point&resize=32x32&transparency=true');
    this.load.image('finishLine', 'https://fuzzycode.dev/@aws/image_buddy_365day_cache/uploads/1c159ab3-db18-4cfe-847d-0342d6f3038c/finishLine!resize_64x512.png');
    this.load.image('water', 'https://fuzzycode.dev/@images/fast_ai?search=blue water tile pattern game&resize=64x64');
  }

  create() {
    // Important: create() gets called for each level restart, so we need to check
    // if this is the final win state before resetting everything
    const isGameComplete = this.scene.settings.data?.gameComplete || false;
    
    this.matter.world.pause();
    this.gameStarted = false;

    if (isGameComplete) {
      this.winText = this.add.text(400, 200, 'ðŸŽ‰ CONGRATULATIONS! ðŸŽ‰
You\'ve completed all levels!

Press SPACE to play again', {
        fontSize: '32px',
        fill: '#fff',
        align: 'center',
        backgroundColor: '#000000aa',
        padding: { x: 20, y: 10 }
      });
      this.winText.setOrigin(0.5);
      this.winText.setScrollFactor(0);
      this.winText.setDepth(10);
      this.winText.setVisible(true);
      
      const restartGame = () => {
        this.scene.restart({ currentLevel: 0 });
      };
      this.input.keyboard.once('keydown-SPACE', restartGame);
      this.input.once('pointerdown', restartGame);
      return;
    }


    this.currentLevel = this.scene.settings.data?.currentLevel || 0;
    const levelMap = levels[this.currentLevel].level_data;

    const tileSize = 32; // Match the knob size
    this.anchors = [];

    const bgWidth = this.textures.get('bgTile').getSourceImage().width;
    const bgHeight = this.textures.get('bgTile').getSourceImage().height;
    this.resizeBackground(bgWidth, bgHeight);

    // Parse the level map
    for (let y = 0; y < levelMap.length; y++) {
      for (let x = 0; x < levelMap[y].length; x++) {
        const tile = levelMap[y][x];
        const posX = x * tileSize + tileSize/2;
        const posY = y * tileSize + tileSize/2;

        if (tile === 'K') {
          let anchorBody = this.matter.add.circle(posX, posY, 25, {
            isStatic: true,
            isSensor: true,
            collisionFilter: {
              group: -1,
              category: 0x0002,
              mask: 0x0000
            }
          });
          let anchorGraphics = this.add.image(posX, posY, 'knob').setScale(1);
          anchorGraphics.setDepth(1);
          this.anchors.push({ body: anchorBody, x: posX, y: posY, sprite: anchorGraphics });
        } else if (tile === 'P') {
          this.player = this.matter.add.image(posX, posY, 'player', null, {
            shape: { type: 'circle', radius: 16 },
            frictionAir: 0.0001,
            restitution: 0.0
          }).setScale(0.5).setMass(1);
        } else if (tile === 'G') {
          this.finishLine = this.add.image(posX, posY, 'finishLine');
          this.finishLine.setDepth(2);
        }
      }
    }

    this.hookConstraint = null;
    this.currentAnchor = null;

    this.hookGraphics = this.add.graphics();
    this.hookGraphics.setDepth(3);

    this.highlightGraphics = this.add.graphics();
    this.highlightGraphics.setDepth(3);

    const startHook = () => {
      if (!this.gameStarted) {
        this.gameStarted = true;
        this.matter.world.resume();
        document.getElementById('instructions').style.display = 'none';
      }

      if (this.hookConstraint) return;

      let candidate = this.findNearestAnchorAbove();
      if (candidate) {
        let dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, candidate.x, candidate.y);
        this.hookConstraint = this.matter.add.constraint(this.player.body, candidate.body, dist, 1.0);
        this.currentAnchor = candidate;
      }
    };

    const releaseHook = () => {
      if (this.hookConstraint) {
        this.matter.world.removeConstraint(this.hookConstraint);
        this.hookConstraint = null;
        this.currentAnchor = null;

        this.matter.setVelocity(this.player.body, this.player.body.velocity.x, -5);

        let originalGravity = this.matter.world.engine.world.gravity.y;
        this.matter.world.engine.world.gravity.y = 0.3;

        this.time.delayedCall(1000, () => {
          this.matter.world.engine.world.gravity.y = originalGravity;
        });
      }
    };

    this.input.keyboard.on('keydown-SPACE', startHook);
    this.input.keyboard.on('keyup-SPACE', releaseHook);

    this.input.on('pointerdown', startHook);
    this.input.on('pointerup', releaseHook);
    
    this.cameras.main.startFollow(this.player, true);
    this.cameras.main.setFollowOffset(-200, 0);
    this.cameras.main.setBounds(0, 0, levelMap[0].length * tileSize, window.innerHeight);
    
    // Add water tiles at the bottom
    const waterY = window.innerHeight - 32;
    this.waterTiles = [];
    for (let x = 0; x < levelMap[0].length * tileSize; x += 64) {
      const waterTile = this.add.image(x + 32, waterY, 'water');
      waterTile.setDepth(1);
      this.waterTiles.push(waterTile);
    }
    
    // Add water collision sensor
    this.waterSensor = this.matter.add.rectangle(
      (levelMap[0].length * tileSize) / 2,
      waterY,
      levelMap[0].length * tileSize,
      64,
      { isSensor: true, isStatic: true }
    );
    
    this.matter.world.on('collisionstart', (event) => {
      const pairs = event.pairs;
      for (let i = 0; i < pairs.length; i++) {
        const bodyA = pairs[i].bodyA;
        const bodyB = pairs[i].bodyB;
        if ((bodyA === this.player.body && bodyB === this.waterSensor) ||
            (bodyB === this.player.body && bodyA === this.waterSensor)) {
          this.scene.restart({ currentLevel: this.currentLevel });
        }
      }
    });
    
    this.levelText = this.add.text(10, 10, `Level ${this.currentLevel + 1}/${levels.length}`, {
      fontSize: '24px',
      fill: '#fff',
      backgroundColor: '#000000aa',
      padding: { x: 10, y: 5 }
    });
    this.levelText.setScrollFactor(0);
    this.levelText.setDepth(10);

    this.winText = this.add.text(400, 200, 'Congratulations!
Level Complete!

Press SPACE for next level', {
      fontSize: '32px',
      fill: '#fff',
      align: 'center',
      backgroundColor: '#000000aa',
      padding: { x: 20, y: 10 }
    });
    this.winText.setOrigin(0.5);
    this.winText.setScrollFactor(0);
    this.winText.setDepth(10);
    this.winText.setVisible(false);
    
    window.addEventListener('resize', () => this.scale.resize(window.innerWidth, window.innerHeight));
    this.scale.resize(window.innerWidth, window.innerHeight);
  }

  resizeBackground(bgWidth, bgHeight) {
    const cols = Math.ceil((2000) / bgWidth);
    const rows = Math.ceil(window.innerHeight / bgHeight);

    for (let x = 0; x < cols; x++) {
      for (let y = 0; y < rows; y++) {
        this.add.image(x * bgWidth + bgWidth/2, y * bgHeight + bgHeight/2, 'bgTile').setDepth(-1);
      }
    }
  }

  findNearestAnchorAbove() {
    let playerX = this.player.x;
    let playerY = this.player.y;
    let minDist = Infinity;
    let candidate = null;
    for (let a of this.anchors) {
      let dist = Phaser.Math.Distance.Between(playerX, playerY, a.x, a.y);
      if (dist < minDist) {
        minDist = dist;
        candidate = a;
      }
    }
    return candidate;
  }

  update() {
    if (!this.gameStarted) return;
    
    if (this.player.x >= this.finishLine.x && !this.winText.visible) {
      this.winText.setVisible(true);
      this.matter.world.pause();
      
      const advanceLevel = () => {
        this.currentLevel++;
        if (this.currentLevel >= levels.length) {
          this.scene.restart({ currentLevel: 0, gameComplete: true });
        } else {
          this.scene.restart({ currentLevel: this.currentLevel });
        }
      };
      this.input.keyboard.once('keydown-SPACE', advanceLevel);
      this.input.once('pointerdown', advanceLevel);
    }

    this.hookGraphics.clear();
    this.highlightGraphics.clear();

    let candidate = this.findNearestAnchorAbove();
    if (candidate) {
      this.highlightGraphics.lineStyle(2, 0xffff00, 1);
      let radius = 20;
      for (let angle = 0; angle < 360; angle += 20) {
        let startAngle = Phaser.Math.DegToRad(angle);
        let endAngle = Phaser.Math.DegToRad(angle+10);
        this.highlightGraphics.beginPath();
        this.highlightGraphics.arc(candidate.x, candidate.y, radius, startAngle, endAngle, false);
        this.highlightGraphics.strokePath();
      }
    }

    if (this.hookConstraint && this.currentAnchor) {
      this.hookGraphics.lineStyle(3, 0x00ff00, 1.0);
      this.hookGraphics.beginPath();
      this.hookGraphics.moveTo(this.player.x, this.player.y);
      this.hookGraphics.lineTo(this.currentAnchor.x, this.currentAnchor.y);
      this.hookGraphics.strokePath();
    }
  }
}

const config = {
  type: Phaser.AUTO,
  backgroundColor: '#1a1a1a',
  parent: 'gameCanvas',
  physics: {
    default: 'matter',
    matter: {
      gravity: {y: 1.2},
      debug: false
    }
  },
  scale: {
    mode: Phaser.Scale.RESIZE,
    autoCenter: Phaser.Scale.CENTER_BOTH
  },
  scene: [MainScene]
};

new Phaser.Game({
    ...config,
    preserveDrawingBuffer: true // This will override the initial value
});
</script>
</body>
</html>