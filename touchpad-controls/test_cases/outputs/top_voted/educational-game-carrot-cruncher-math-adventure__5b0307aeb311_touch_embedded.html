<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carrot Cruncher Math Adventure</title>
    <style>
        @import url('https://cdn.fuzzycode.dev/resolve?url=https://fonts.googleapis.com/css2?family=Bubblegum+Sans&family=Nunito:wght@400;700&display=swap');

        body {
            font-family: 'Nunito', sans-serif;
            background-color: #8bc34a;
            background-image: url('https://images.fuzzycode.dev/fast_ai?search=cute%20cartoon%20garden%20background%20with%20carrots%20growing&resize=1200x800');
            background-size: cover;
            background-position: center;
            color: #3e2723;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 600px;
            max-width: 95vw;
            background-color: #dcedc8;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 4px solid #8d6e63;
            transition: all 0.5s ease;
        }

        #game-title {
            font-family: 'Bubblegum Sans', cursive;
            text-align: center;
            font-size: 42px;
            color: #ff6f00;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3), 0 0 10px rgba(255, 255, 255, 0.8);
            margin-bottom: 10px;
            transform: rotate(-2deg);
        }

        #game-subtitle {
            font-family: 'Nunito', sans-serif;
            text-align: center;
            font-size: 18px;
            color: #5d4037;
            margin-bottom: 15px;
        }

        #score-display {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 18px;
            color: #3e2723;
            font-weight: bold;
        }

        #mission {
            text-align: center;
            margin-bottom: 15px;
            font-size: 20px;
            color: #ff5722;
            font-weight: bold;
        }

        #game-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .grid-cell {
            width: 100%;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #aed581;
            background-image: url('https://images.fuzzycode.dev/fast_ai?search=muted%20brown%20cartoon%20dirt%20texture&resize=100x100');
            background-size: cover;
            border-radius: 5px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease-in-out;
            position: relative;
            overflow: hidden;
            color: #3e2723;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.7);
            box-shadow: 0 3px 5px rgba(0,0,0,0.2);
            transform-origin: center;
        }

        .grid-cell:hover {
            background-color: #9ccc65;
            background-image: url('https://images.fuzzycode.dev/fast_ai?search=muted%20brown%20cartoon%20dirt%20texture%20lighter&resize=100x100');
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        @keyframes bunnyBounce {
            0% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0); }
        }

        @keyframes foxSneaking {
            0% { transform: rotate(-3deg) translateX(0); }
            50% { transform: rotate(3deg) translateX(0); }
            100% { transform: rotate(-3deg) translateX(0); }
        }

        .bunny {
            position: absolute;
            width: 80%;
            height: 80%;
            z-index: 10;
            pointer-events: none;
            animation: bunnyBounce 2s infinite ease-in-out;
            transition: all 0.3s ease;
        }

        .fox {
            position: absolute;
            width: 80%;
            height: 80%;
            z-index: 20;
            pointer-events: none;
            animation: foxSneaking 1.5s infinite ease-in-out;
            transition: all 0.3s ease;
        }

        @keyframes correctPulse {
            0% { transform: scale(1); background-color: #ffeb3b; background-image: url('https://images.fuzzycode.dev/fast_ai?search=muted%20yellow%20dirt%20texture%20cartoon&resize=100x100'); }
            50% { transform: scale(1.2); background-color: #ffeb3b; background-image: url('https://images.fuzzycode.dev/fast_ai?search=muted%20yellow%20dirt%20texture%20cartoon&resize=100x100'); }
            100% { transform: scale(1); background-color: #ffeb3b; background-image: url('https://images.fuzzycode.dev/fast_ai?search=muted%20yellow%20dirt%20texture%20cartoon&resize=100x100'); }
        }

        @keyframes wrongShake {
            0% { transform: translateX(0); background-color: #ff5722; background-image: url('https://images.fuzzycode.dev/fast_ai?search=muted%20reddish%20dirt%20texture%20cartoon&resize=100x100'); }
            25% { transform: translateX(-5px); background-color: #ff5722; background-image: url('https://images.fuzzycode.dev/fast_ai?search=muted%20reddish%20dirt%20texture%20cartoon&resize=100x100'); }
            50% { transform: translateX(5px); background-color: #ff5722; background-image: url('https://images.fuzzycode.dev/fast_ai?search=muted%20reddish%20dirt%20texture%20cartoon&resize=100x100'); }
            75% { transform: translateX(-5px); background-color: #ff5722; background-image: url('https://images.fuzzycode.dev/fast_ai?search=muted%20reddish%20dirt%20texture%20cartoon&resize=100x100'); }
            100% { transform: translateX(0); background-color: #ff5722; background-image: url('https://images.fuzzycode.dev/fast_ai?search=muted%20reddish%20dirt%20texture%20cartoon&resize=100x100'); }
        }

        @keyframes carrotCollected {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -100%) scale(0.5); opacity: 0; }
        }

        @keyframes dirtPuff {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0.7; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.5; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }

        .correct {
            background-color: #ffeb3b;
            animation: correctPulse 0.5s ease;
        }

        .wrong {
            background-color: #ff5722;
            animation: wrongShake 0.5s ease;
        }

        #game-over, #level-complete, #difficulty-select, #intro-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(62, 39, 35, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: 15px;
            display: none;
            color: #fff;
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(5px);
        }

        #intro-screen {
            background-color: rgba(139, 195, 74, 0.9);
            background-image: url('https://images.fuzzycode.dev/fast_ai?search=cute%20cartoon%20bunny%20with%20carrots%20math%20background&resize=800x600');
            background-size: cover;
            background-position: center;
            display: flex;
        }

        #intro-content {
            background-color: rgba(255, 255, 255, 0.85);
            padding: 30px;
            border-radius: 15px;
            max-width: 80%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        #intro-title {
            font-family: 'Bubblegum Sans', cursive;
            font-size: 48px;
            color: #ff6f00;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            margin-bottom: 15px;
            animation: bounce 2s infinite ease-in-out;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        #intro-description {
            font-size: 18px;
            margin-bottom: 25px;
            color: #3e2723;
            line-height: 1.5;
        }

        .screen-title {
            font-family: 'Bubblegum Sans', cursive;
            font-size: 36px;
            margin-bottom: 15px;
            color: #ffeb3b;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        button {
            margin-top: 20px;
            padding: 12px 24px;
            font-size: 18px;
            font-family: 'Nunito', sans-serif;
            font-weight: bold;
            background-color: #ff9800;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 0 #e65100;
            position: relative;
            overflow: hidden;
        }

        button:hover {
            background-color: #f57c00;
            transform: translateY(-3px);
            box-shadow: 0 7px 0 #e65100;
        }

        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #e65100;
        }

        button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }

        button:focus:not(:active)::after {
            animation: ripple 1s ease-out;
        }

        @keyframes ripple {
            0% {
                transform: scale(0, 0);
                opacity: 0.5;
            }
            20% {
                transform: scale(25, 25);
                opacity: 0.3;
            }
            100% {
                opacity: 0;
                transform: scale(40, 40);
            }
        }

        #lives-display {
            display: flex;
            align-items: center;
        }

        .life {
            width: 20px;
            height: 20px;
            margin-left: 5px;
            background-color: #ff5722;
            border-radius: 50%;
        }

        #controls-info {
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
            color: #5d4037;
        }

        .difficulty-btn {
            margin: 10px;
            padding: 15px 30px;
            font-size: 20px;
            width: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .difficulty-btn.easy {
            background-color: #4CAF50;
            box-shadow: 0 4px 0 #2E7D32;
        }

        .difficulty-btn.easy:hover {
            background-color: #43A047;
        }

        .difficulty-btn.medium {
            background-color: #ff9800;
            box-shadow: 0 4px 0 #E65100;
            color: #fff;
        }

        .difficulty-btn.medium:hover {
            background-color: #F57C00;
        }

        .difficulty-btn.hard {
            background-color: #f44336;
            box-shadow: 0 4px 0 #B71C1C;
        }

        .difficulty-btn.hard:hover {
            background-color: #E53935;
        }

        #difficulty-title {
            font-family: 'Bubblegum Sans', cursive;
            font-size: 32px;
            margin-bottom: 20px;
            color: #ffeb3b;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .difficulty-icon {
            margin-right: 10px;
            font-size: 24px;
        }

        #music-controls {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 8px;
            border-radius: 30px;
            display: flex;
            align-items: center;
            z-index: 200;
        }

        #music-toggle {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            margin: 0;
            padding: 0;
            color: #5d4037;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: none;
        }

        #music-toggle:hover {
            color: #ff6f00;
            transform: none;
            box-shadow: none;
        }

        .achievement {
            position: fixed;
            top: 30px;
            right: -300px;
            background-color: rgba(255, 235, 59, 0.9);
            color: #3e2723;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            z-index: 1000;
            display: flex;
            align-items: center;
            transition: right 0.5s ease;
            font-weight: bold;
        }

        .achievement-icon {
            margin-right: 10px;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1 id="game-title">Carrot Cruncher</h1>
        <h2 id="game-subtitle">Math Adventure</h2>
        <div id="score-display">
            <div>Carrots: <span id="score">0</span> ü•ï</div>
            <div>Level: <span id="level">1</span></div>
            <div id="lives-display">Lives: </div>
        </div>
        <div id="mission"></div>
        <div id="game-grid"></div>
        <div id="controls-info">
            Use arrow keys to move. Press SPACE to munch a carrot.
        </div>

        <div id="game-over">
            <h2>Game Over!</h2>
            <p>Carrots collected: <span id="final-score">0</span> ü•ï</p>
            <button id="restart-game">Play Again</button>
        </div>

        <div id="level-complete">
            <h2>Level Complete!</h2>
            <p>Get ready for the next level</p>
            <button id="next-level">Continue</button>
        </div>

        <div id="intro-screen">
            <div id="intro-content">
                <h1 id="intro-title">Carrot Cruncher</h1>
                <p id="intro-description">
                    Help Bunny munch on the correct carrots based on math challenges! 
                    Move around the garden using arrow keys and press SPACE to eat carrots.
                    Beware of the sneaky foxes! They'll try to catch you, so be quick and smart.
                    Complete math challenges to level up and become the best carrot cruncher!
                </p>
                <button id="start-game-btn">Start Adventure!</button>
            </div>
        </div>

        <div id="difficulty-select">
            <h2 id="difficulty-title">Choose Difficulty</h2>
            <button class="difficulty-btn easy" data-difficulty="easy"><span class="difficulty-icon">ü•ï</span>Easy</button>
            <button class="difficulty-btn medium" data-difficulty="medium"><span class="difficulty-icon">ü•ïü•ï</span>Medium</button>
            <button class="difficulty-btn hard" data-difficulty="hard"><span class="difficulty-icon">ü•ïü•ïü•ï</span>Hard</button>
        </div>

        <div id="music-controls">
            <button id="music-toggle">üîä</button>
        </div>
    </div>

    <script>
        // Background music and sound effects
        const backgroundMusic = new Audio('https://sounds.fuzzycode.dev/music?prompt=cheerful%20playful%20game%20music%20for%20kids%20with%20happy%20melody&duration=30&ext=.mp3');
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.5;

        // Game configuration
        const config = {
            gridSize: 5,
            initialLives: 3,
            missionTypes: [
                { type: 'multiples', text: 'Munch carrots with multiples of {number}' },
                { type: 'factors', text: 'Munch carrots with factors of {number}' },
                { type: 'primes', text: 'Munch carrots with prime numbers' },
                { type: 'even', text: 'Munch carrots with even numbers' },
                { type: 'odd', text: 'Munch carrots with odd numbers' }
            ],
            pointsPerCorrect: 10,
            levelGoal: 5, // Number of correct answers to complete level
            maxNumber: 50,
            troggleSpeed: 1000, // Time in ms between fox moves
            troggleSpawnRate: 5000, // Time in ms between fox spawns
            difficulty: 'medium' // Default difficulty
        };

        // Difficulty settings
        const difficultySettings = {
            easy: {
                initialLives: 5,
                levelGoal: 3,
                troggleSpeed: 1500,
                troggleSpawnRate: 8000,
                maxTroggles: 2,
                maxNumber: 20, // Easier numbers
                missionTypes: [
                    { type: 'multiples', text: 'Munch carrots with multiples of {number}', numberRange: [2, 5] },
                    { type: 'even', text: 'Munch carrots with even numbers' },
                    { type: 'odd', text: 'Munch carrots with odd numbers' }
                ]
            },
            medium: {
                initialLives: 3,
                levelGoal: 5,
                troggleSpeed: 1000,
                troggleSpawnRate: 5000,
                maxTroggles: 3,
                maxNumber: 50,
                missionTypes: [
                    { type: 'multiples', text: 'Munch carrots with multiples of {number}', numberRange: [2, 10] },
                    { type: 'factors', text: 'Munch carrots with factors of {number}', numberRange: [10, 50] },
                    { type: 'primes', text: 'Munch carrots with prime numbers' },
                    { type: 'even', text: 'Munch carrots with even numbers' },
                    { type: 'odd', text: 'Munch carrots with odd numbers' }
                ]
            },
            hard: {
                initialLives: 2,
                levelGoal: 7,
                troggleSpeed: 700,
                troggleSpawnRate: 3000,
                maxTroggles: 4,
                maxNumber: 100, // Harder numbers
                missionTypes: [
                    { type: 'multiples', text: 'Munch carrots with multiples of {number}', numberRange: [7, 19] },
                    { type: 'factors', text: 'Munch carrots with factors of {number}', numberRange: [50, 100] },
                    { type: 'primes', text: 'Munch carrots with prime numbers' },
                    { type: 'even', text: 'Munch carrots with even numbers' },
                    { type: 'odd', text: 'Munch carrots with odd numbers' },
                    { type: 'squares', text: 'Munch carrots with perfect square numbers' },
                    { type: 'cubes', text: 'Munch carrots with perfect cube numbers' }
                ]
            }
        };

        // Game state
        let state = {
            score: 0,
            level: 1,
            lives: config.initialLives,
            currentMission: null,
            correctAnswers: 0,
            muncherPosition: { row: 2, col: 2 },
            troggles: [],
            grid: [],
            gameOver: false,
            levelComplete: false,
            troggleSpawner: null
        };

        // DOM elements
        const gridElement = document.getElementById('game-grid');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const missionElement = document.getElementById('mission');
        const livesDisplay = document.getElementById('lives-display');
        const gameOverElement = document.getElementById('game-over');
        const levelCompleteElement = document.getElementById('level-complete');
        const difficultySelectElement = document.getElementById('difficulty-select');
        const finalScoreElement = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-game');
        const nextLevelButton = document.getElementById('next-level');
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');

        // Sound effects
        const sounds = {
            chomp: new Audio('https://aws.fuzzycode.dev/generated_sound_effects/bunny-chomping-on-carrot.wav'),
            wrong: new Audio('https://aws.fuzzycode.dev/generated_sound_effects/wrong-move-video-game-sound-effect.wav'),
            levelUp: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=level_complete_happy_jingle&duration=1&ext=.mp3'),
            gameOver: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=sad_game_over&duration=1&ext=.mp3'),
            pop: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=pop_bubble_cute&duration=0.5&ext=.mp3'),
            foxAppear: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=sneaky_fox_appears&duration=0.5&ext=.mp3'),
            achievement: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=achievement_unlocked_happy_chime&duration=1&ext=.mp3'),
            buttonClick: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=button_click_cute&duration=0.5&ext=.mp3')
        };

        // Initialize the game
        function initGame() {
            // Show intro screen first
            document.getElementById('intro-screen').style.display = 'flex';

            // Set up intro screen button
            document.getElementById('start-game-btn').addEventListener('click', () => {
                sounds.buttonClick.currentTime = 0;
                sounds.buttonClick.play();
                document.getElementById('intro-screen').style.display = 'none';
                difficultySelectElement.style.display = 'flex';
            });

            // Set up music toggle
            const musicToggle = document.getElementById('music-toggle');
            musicToggle.addEventListener('click', toggleMusic);

            // Set up difficulty selection handlers
            difficultyButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const difficulty = button.dataset.difficulty;
                    setDifficulty(difficulty);
                    difficultySelectElement.style.display = 'none';
                    startGame();
                });
            });

            // Set up other event listeners
            restartButton.addEventListener('click', restartGame);
            nextLevelButton.addEventListener('click', nextLevel);
        }

        // Toggle background music
        function toggleMusic() {
            const musicToggle = document.getElementById('music-toggle');
            if (backgroundMusic.paused) {
                backgroundMusic.play();
                musicToggle.textContent = 'üîä';
            } else {
                backgroundMusic.pause();
                musicToggle.textContent = 'üîá';
            }
        }

        // Show achievement notification
        function showAchievement(message) {
            const achievementElement = document.createElement('div');
            achievementElement.className = 'achievement';
            achievementElement.innerHTML = `<span class="achievement-icon">üèÜ</span>${message}`;
            document.body.appendChild(achievementElement);

            sounds.achievement.currentTime = 0;
            sounds.achievement.play();

            // Animate in
            setTimeout(() => {
                achievementElement.style.right = '20px';
            }, 100);

            // Animate out and remove
            setTimeout(() => {
                achievementElement.style.right = '-300px';
                setTimeout(() => {
                    document.body.removeChild(achievementElement);
                }, 500);
            }, 3000);
        }

        // Set difficulty
        function setDifficulty(difficulty) {
            sounds.buttonClick.currentTime = 0;
            sounds.buttonClick.play();

            config.difficulty = difficulty;

            // Apply difficulty settings
            const settings = difficultySettings[difficulty];
            config.initialLives = settings.initialLives;
            config.levelGoal = settings.levelGoal;
            config.troggleSpeed = settings.troggleSpeed;
            config.troggleSpawnRate = settings.troggleSpawnRate;
            config.maxTroggles = settings.maxTroggles;
            config.maxNumber = settings.maxNumber;
            config.missionTypes = settings.missionTypes;

            // Update state
            state.lives = config.initialLives;

            // Clean up any existing game elements
            clearAllFoxes();

            // Start playing background music
            try {
                backgroundMusic.play().catch(e => console.log("Auto-play prevented:", e));
            } catch (e) {
                console.log("Music play error:", e);
            }
        }

        // Clear all foxes and their intervals
        function clearAllFoxes() {
            // Clear fox spawner interval
            if (state.troggleSpawner) {
                clearInterval(state.troggleSpawner);
                state.troggleSpawner = null;
            }

            // Clear all fox move intervals and remove elements
            state.troggles.forEach(fox => {
                if (fox.moveInterval) {
                    clearInterval(fox.moveInterval);
                }
            });

            // Clear troggles array
            state.troggles = [];

            // Remove all fox elements
            document.querySelectorAll('.fox').forEach(el => el.remove());
        }

        // Start the game after difficulty selection
        function startGame() {
            // Create grid cells
            gridElement.innerHTML = '';
            for (let row = 0; row < config.gridSize; row++) {
                for (let col = 0; col < config.gridSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    gridElement.appendChild(cell);
                }
            }

            // Initialize lives display
            updateLivesDisplay();

            // Generate mission
            generateMission();

            // Generate grid values
            generateGridValues();

            // Place bunny
            placeBunny(state.muncherPosition.row, state.muncherPosition.col);

            // Start spawning foxes
            startFoxSpawner();

            // Set up keyboard event listeners
            document.addEventListener('keydown', handleKeyPress);
        }

        // Generate a random mission
        function generateMission() {
            const missionIndex = Math.floor(Math.random() * config.missionTypes.length);
            state.currentMission = { ...config.missionTypes[missionIndex] };

            // Set mission parameter if needed
            if (state.currentMission.type === 'multiples') {
                const range = state.currentMission.numberRange || [2, 10];
                state.currentMission.number = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0];
            } else if (state.currentMission.type === 'factors') {
                const range = state.currentMission.numberRange || [10, 50];
                state.currentMission.number = (Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0]);
                // Make sure it has multiple factors
                if (isPrime(state.currentMission.number)) {
                    state.currentMission.number *= 2;
                }
            }

            // Update mission text
            let missionText = state.currentMission.text;
            if (state.currentMission.number) {
                missionText = missionText.replace('{number}', state.currentMission.number);
            }
            missionElement.textContent = missionText;
        }

        // Generate values for the grid
        function generateGridValues() {
            state.grid = [];

            // Calculate how many correct answers to place
            const totalCells = config.gridSize * config.gridSize;
            const correctCells = Math.floor(totalCells * 0.4) + Math.min(state.level, 5);

            // Generate array of indices for placing correct answers
            const indices = Array.from({ length: totalCells }, (_, i) => i);
            shuffleArray(indices);
            const correctIndices = indices.slice(0, correctCells);

            // Generate the grid
            for (let i = 0; i < totalCells; i++) {
                const isCorrect = correctIndices.includes(i);
                let value;

                if (isCorrect) {
                    value = generateCorrectValue();
                } else {
                    value = generateIncorrectValue();
                }

                const row = Math.floor(i / config.gridSize);
                const col = i % config.gridSize;

                if (!state.grid[row]) {
                    state.grid[row] = [];
                }

                state.grid[row][col] = {
                    value,
                    isCorrect
                };
            }

            // Update the DOM with new values
            updateGridDisplay();
        }

        // Generate a correct value based on current mission
        function generateCorrectValue() {
            switch (state.currentMission.type) {
                case 'multiples':
                    // Adjust multiplier range based on difficulty
                    let max = config.difficulty === 'easy' ? 5 : (config.difficulty === 'medium' ? 10 : 15);
                    return state.currentMission.number * (Math.floor(Math.random() * max) + 1);
                case 'factors':
                    const factors = getFactors(state.currentMission.number);
                    return factors[Math.floor(Math.random() * factors.length)];
                case 'primes':
                    // Different prime ranges for different difficulties
                    let primes;
                    if (config.difficulty === 'easy') {
                        primes = [2, 3, 5, 7, 11, 13];
                    } else if (config.difficulty === 'medium') {
                        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
                    } else {
                        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];
                    }
                    return primes[Math.floor(Math.random() * primes.length)];
                case 'even':
                    return (Math.floor(Math.random() * (config.maxNumber / 2)) + 1) * 2;
                case 'odd':
                    return Math.floor(Math.random() * (config.maxNumber / 2)) * 2 + 1;
                case 'squares':
                    // Perfect squares up to maxNumber
                    const maxSqrt = Math.floor(Math.sqrt(config.maxNumber));
                    const n = Math.floor(Math.random() * maxSqrt) + 1;
                    return n * n;
                case 'cubes':
                    // Perfect cubes up to maxNumber
                    const maxCubeRoot = Math.floor(Math.cbrt(config.maxNumber));
                    const m = Math.floor(Math.random() * maxCubeRoot) + 1;
                    return m * m * m;
                default:
                    return Math.floor(Math.random() * config.maxNumber) + 1;
            }
        }

        // Generate an incorrect value based on current mission
        function generateIncorrectValue() {
            let value;
            let isIncorrect = false;
            let attempts = 0;

            while (!isIncorrect && attempts < 50) {
                attempts++;
                value = Math.floor(Math.random() * config.maxNumber) + 1;

                switch (state.currentMission.type) {
                    case 'multiples':
                        isIncorrect = value % state.currentMission.number !== 0;
                        break;
                    case 'factors':
                        isIncorrect = !getFactors(state.currentMission.number).includes(value);
                        break;
                    case 'primes':
                        isIncorrect = !isPrime(value);
                        break;
                    case 'even':
                        isIncorrect = value % 2 !== 0;
                        break;
                    case 'odd':
                        isIncorrect = value % 2 === 0;
                        break;
                    case 'squares':
                        isIncorrect = !isPerfectSquare(value);
                        break;
                    case 'cubes':
                        isIncorrect = !isPerfectCube(value);
                        break;
                    default:
                        isIncorrect = true;
                }
            }

            // If we couldn't find an incorrect value, generate a random one
            if (!isIncorrect) {
                value = Math.floor(Math.random() * config.maxNumber) + 1;
            }

            return value;
        }

        // Update the grid display with current values
        function updateGridDisplay() {
            const cells = document.querySelectorAll('.grid-cell');

            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                // Clear previous content except for bunny/fox
                const bunny = cell.querySelector('.bunny');
                const fox = cell.querySelector('.fox');

                cell.innerHTML = '';
                cell.textContent = state.grid[row][col].value;

                if (bunny) {
                    cell.appendChild(bunny);
                }

                if (fox) {
                    cell.appendChild(fox);
                }

                // Remove any previous correct/wrong classes
                cell.classList.remove('correct', 'wrong');
            });
        }

        // Handle keyboard input
        function handleKeyPress(event) {
            if (state.gameOver || state.levelComplete) return;

            const key = event.key.toLowerCase();

            if (key === 'arrowup' || key === 'w') {
                moveBunny(state.muncherPosition.row - 1, state.muncherPosition.col);
            } else if (key === 'arrowdown' || key === 's') {
                moveBunny(state.muncherPosition.row + 1, state.muncherPosition.col);
            } else if (key === 'arrowleft' || key === 'a') {
                moveBunny(state.muncherPosition.row, state.muncherPosition.col - 1);
            } else if (key === 'arrowright' || key === 'd') {
                moveBunny(state.muncherPosition.row, state.muncherPosition.col + 1);
            } else if (key === ' ' || key === 'enter') {
                // Munch the current carrot
                munchCarrot();
            }
        }

        // Handle cell click
        function handleCellClick(row, col) {
            if (state.gameOver || state.levelComplete) return;

            moveBunny(row, col);
            munchCarrot();
        }

        // Move the bunny to a new position
        function moveBunny(row, col) {
            // Check bounds
            if (row < 0 || row >= config.gridSize || col < 0 || col >= config.gridSize) {
                return;
            }

            // Remove bunny from current position
            const currentCell = document.querySelector(`.grid-cell[data-row="${state.muncherPosition.row}"][data-col="${state.muncherPosition.col}"]`);
            const bunnyElement = currentCell.querySelector('.bunny');

            if (bunnyElement) {
                currentCell.removeChild(bunnyElement);
            }

            // Update position
            state.muncherPosition = { row, col };

            // Place bunny in new position
            placeBunny(row, col);

            // Check if there's a fox at the new position
            checkFoxCollision();
        }

        // Place the bunny at a specific position
        function placeBunny(row, col) {
            const cell = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);

            // Create bunny element if it doesn't exist
            let bunnyElement = cell.querySelector('.bunny');

            if (!bunnyElement) {
                bunnyElement = document.createElement('img');
                bunnyElement.className = 'bunny';
                bunnyElement.src = 'https://aws.fuzzycode.dev/image_buddy_365day_cache/uploads/650d0284-66ef-4e44-ba51-28913dea877c/cartoon bunny rabbit!resize_80x80.png';
                cell.appendChild(bunnyElement);
            }
        }

        // Munch the current carrot
        function munchCarrot() {
            if (state.gameOver || state.levelComplete) return;

            const { row, col } = state.muncherPosition;
            const cell = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
            const gridItem = state.grid[row][col];
            const bunnyElement = cell.querySelector('.bunny');

            if (gridItem.isCorrect) {
                // Correct answer
                sounds.chomp.currentTime = 0;
                sounds.chomp.play();

                // Animate bunny eating
                if (bunnyElement) {
                    bunnyElement.style.animation = 'none';
                    bunnyElement.style.transform = 'scale(1.2)';
                    setTimeout(() => {
                        bunnyElement.style.animation = 'bunnyBounce 2s infinite ease-in-out';
                        bunnyElement.style.transform = '';
                    }, 300);
                }

                cell.classList.add('correct');

                // Create carrot accumulation animation
                const carrot = document.createElement('img');
                carrot.src = 'https://images.fuzzycode.dev/fast_ai?search=cartoon%20carrot&resize=50x50&transparency=true';
                carrot.classList.add('carrot-collected');
                carrot.style.position = 'absolute';
                carrot.style.top = '50%';
                carrot.style.left = '50%';
                carrot.style.transform = 'translate(-50%, -50%)';
                carrot.style.zIndex = '50';
                carrot.style.pointerEvents = 'none';
                cell.appendChild(carrot);

                // Animate carrot flying to score
                const scorePos = scoreElement.getBoundingClientRect();
                const cellPos = cell.getBoundingClientRect();

                setTimeout(() => {
                    carrot.style.transition = 'all 0.5s cubic-bezier(0.165, 0.84, 0.44, 1)';
                    carrot.style.top = (scorePos.top - cellPos.top) + 'px';
                    carrot.style.left = (scorePos.left - cellPos.left) + 'px';
                    carrot.style.transform = 'translate(0, 0) scale(0.5)';
                    carrot.style.opacity = '0.8';

                    // Play carrot collection sound
                    const collectSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=carrot_collected_ding&duration=0.5&ext=.mp3');
                    collectSound.volume = 0.6;
                    collectSound.play();

                    // Remove carrot after animation
                    setTimeout(() => {
                        // Check if carrot is still a child of cell before removing
                        if (carrot.parentNode === cell) {
                            cell.removeChild(carrot);
                        }
                    }, 500);
                }, 100);

                // Animate score increase (carrots collected)
                const oldScore = state.score;
                state.score += config.pointsPerCorrect;
                animateCountUp(scoreElement, oldScore, state.score, 300);

                state.correctAnswers++;

                // Generate a new value for this cell
                state.grid[row][col] = {
                    value: generateIncorrectValue(),
                    isCorrect: false
                };

                // Update after a brief delay to show the correct feedback
                setTimeout(() => {
                    updateGridDisplay();

                    // Check if level is complete
                    if (state.correctAnswers >= config.levelGoal) {
                        levelComplete();
                    }
                }, 600);
            } else {
                // Incorrect answer - bunny dug up something dangerous
                sounds.wrong.currentTime = 0;
                sounds.wrong.play();

                // Create dangerous item animation
                const dangerItems = [
                    { name: 'rock', img: 'https://images.fuzzycode.dev/fast_ai?search=cartoon%20rock&resize=50x50&transparency=true' },
                    { name: 'mole', img: 'https://images.fuzzycode.dev/fast_ai?search=cartoon%20mole&resize=50x50&transparency=true' },
                    { name: 'thorn', img: 'https://aws.fuzzycode.dev/image_buddy_365day_cache/uploads/650d0284-66ef-4e44-ba51-28913dea877c/cartoon thorny plant!resize_50x50.png' }
                ];

                const randomDanger = dangerItems[Math.floor(Math.random() * dangerItems.length)];

                // Add digging sound
                const digSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=rabbit_digging_dirt&duration=0.5&ext=.mp3');
                digSound.volume = 0.7;
                digSound.play();

                // Create dirt puff animation
                const dirtPuff = document.createElement('div');
                dirtPuff.classList.add('dirt-puff');
                dirtPuff.style.position = 'absolute';
                dirtPuff.style.top = '50%';
                dirtPuff.style.left = '50%';
                dirtPuff.style.width = '60px';
                dirtPuff.style.height = '60px';
                dirtPuff.style.backgroundColor = '#8d6e63';
                dirtPuff.style.borderRadius = '50%';
                dirtPuff.style.transform = 'translate(-50%, -50%) scale(0)';
                dirtPuff.style.opacity = '0.7';
                dirtPuff.style.zIndex = '40';
                dirtPuff.style.pointerEvents = 'none';
                cell.appendChild(dirtPuff);

                // Animate dirt puff
                setTimeout(() => {
                    dirtPuff.style.transition = 'all 0.3s ease-out';
                    dirtPuff.style.transform = 'translate(-50%, -50%) scale(1)';

                    // Show the dangerous item after dirt puff
                    setTimeout(() => {
                        const dangerItem = document.createElement('img');
                        dangerItem.src = randomDanger.img;
                        dangerItem.classList.add('danger-item');
                        dangerItem.style.position = 'absolute';
                        dangerItem.style.top = '50%';
                        dangerItem.style.left = '50%';
                        dangerItem.style.transform = 'translate(-50%, -50%) scale(0)';
                        dangerItem.style.zIndex = '45';
                        dangerItem.style.pointerEvents = 'none';
                        cell.appendChild(dangerItem);

                        // Animate danger item appearing
                        setTimeout(() => {
                            dangerItem.style.transition = 'all 0.2s ease-out';
                            dangerItem.style.transform = 'translate(-50%, -50%) scale(1.2)';

                            // Animate bunny reaction
                            if (bunnyElement) {
                                bunnyElement.style.animation = 'none';
                                bunnyElement.style.transform = 'translateY(-10px)';
                                setTimeout(() => {
                                    bunnyElement.style.animation = 'bunnyBounce 2s infinite ease-in-out';
                                    bunnyElement.style.transform = '';
                                }, 300);
                            }

                            // Remove the elements after animation
                            setTimeout(() => {
                                cell.removeChild(dirtPuff);
                                cell.removeChild(dangerItem);
                            }, 400);
                        }, 100);
                    }, 200);
                }, 50);

                cell.classList.add('wrong');

                // Lose a life
                state.lives--;
                updateLivesDisplay();

                // Check if game over
                if (state.lives <= 0) {
                    gameOver();
                    return;
                }

                // Reset after a brief delay
                setTimeout(() => {
                    cell.classList.remove('wrong');
                }, 700);
            }
        }

        // Animate count up for score
        function animateCountUp(element, start, end, duration) {
            let startTimestamp = null;
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                const value = Math.floor(progress * (end - start) + start);
                element.textContent = value;
                if (progress < 1) {
                    window.requestAnimationFrame(step);
                }
            };
            window.requestAnimationFrame(step);
        }

        // Update the lives display
        function updateLivesDisplay() {
            // Clear previous lives
            while (livesDisplay.children.length > 1) {
                livesDisplay.removeChild(livesDisplay.lastChild);
            }

            // Add current lives
            for (let i = 0; i < state.lives; i++) {
                const lifeElement = document.createElement('div');
                lifeElement.className = 'life';
                livesDisplay.appendChild(lifeElement);
            }
        }

        // Start spawning foxes
        function startFoxSpawner() {
            // Clear any existing foxes
            state.troggles = [];
            document.querySelectorAll('.fox').forEach(el => el.remove());

            // Clear any existing spawner
            if (state.troggleSpawner) {
                clearInterval(state.troggleSpawner);
            }

            // Start the spawner interval
            state.troggleSpawner = setInterval(() => {
                if (state.gameOver || state.levelComplete) {
                    clearInterval(state.troggleSpawner);
                    return;
                }

                spawnFox();
            }, config.troggleSpawnRate);
        }

        // Spawn a fox at a random position
        function spawnFox() {
            // Limit number of foxes based on difficulty and level
            const maxFoxes = Math.min(config.maxTroggles, Math.floor(state.level / 2) + 1);
            if (state.troggles.length >= maxFoxes) {
                return;
            }

            // Play fox appear sound
            sounds.foxAppear.currentTime = 0;
            sounds.foxAppear.play();

            // Find a position that doesn't have the bunny or another fox
            let row, col;
            let validPosition = false;

            while (!validPosition) {
                row = Math.floor(Math.random() * config.gridSize);
                col = Math.floor(Math.random() * config.gridSize);

                // Check if position is valid
                validPosition = !(row === state.muncherPosition.row && col === state.muncherPosition.col);

                // Check if there's already a fox at this position
                for (const fox of state.troggles) {
                    if (fox.row === row && fox.col === col) {
                        validPosition = false;
                        break;
                    }
                }
            }

            // Create fox
            const fox = {
                id: Date.now(),
                row,
                col,
                moveInterval: null
            };

            // Add to state
            state.troggles.push(fox);

            // Place fox on grid
            placeFox(fox);

            // Start moving the fox
            fox.moveInterval = setInterval(() => {
                moveFox(fox);
            }, config.troggleSpeed - (state.level * 30)); // Speed increases with level
        }

        // Place a fox at its position
        function placeFox(fox) {
            const cell = document.querySelector(`.grid-cell[data-row="${fox.row}"][data-col="${fox.col}"]`);

            const foxElement = document.createElement('img');
            foxElement.className = 'fox';
            foxElement.dataset.id = fox.id;
            foxElement.src = 'https://aws.fuzzycode.dev/image_buddy_365day_cache/uploads/650d0284-66ef-4e44-ba51-28913dea877c/cartoon orange fox!resize_80x80.png';

            cell.appendChild(foxElement);

            // Check if placed on bunny
            checkFoxCollision();
        }

        // Move a fox
        function moveFox(fox) {
            if (state.gameOver || state.levelComplete) {
                clearInterval(fox.moveInterval);
                return;
            }

            // Remove from current position
            const currentCell = document.querySelector(`.grid-cell[data-row="${fox.row}"][data-col="${fox.col}"]`);
            const foxElement = currentCell.querySelector(`.fox[data-id="${fox.id}"]`);

            if (foxElement) {
                currentCell.removeChild(foxElement);
            }

            // Decide new position - move toward bunny
            let newRow = fox.row;
            let newCol = fox.col;

            // Adjust difficulty of fox movement based on difficulty setting
            let chaseChance;
            switch(config.difficulty) {
                case 'easy': chaseChance = 0.6; break;
                case 'medium': chaseChance = 0.8; break;
                case 'hard': chaseChance = 0.9; break;
                default: chaseChance = 0.8;
            }

            if (Math.random() < chaseChance) {
                if (state.muncherPosition.row < fox.row) {
                    newRow--;
                } else if (state.muncherPosition.row > fox.row) {
                    newRow++;
                } else if (state.muncherPosition.col < fox.col) {
                    newCol--;
                } else if (state.muncherPosition.col > fox.col) {
                    newCol++;
                }
            } else {
                // Random move
                const directions = [
                    { row: -1, col: 0 },
                    { row: 1, col: 0 },
                    { row: 0, col: -1 },
                    { row: 0, col: 1 }
                ];

                const direction = directions[Math.floor(Math.random() * directions.length)];
                newRow = fox.row + direction.row;
                newCol = fox.col + direction.col;
            }

            // Check bounds
            if (newRow < 0 || newRow >= config.gridSize || newCol < 0 || newCol >= config.gridSize) {
                // If out of bounds, try to place back in original position
                placeFox(fox);
                return;
            }

            // Update fox position
            fox.row = newRow;
            fox.col = newCol;

            // Place in new position
            placeFox(fox);
        }

        // Check if a fox has collided with the bunny
        function checkFoxCollision() {
            for (const fox of state.troggles) {
                if (fox.row === state.muncherPosition.row && fox.col === state.muncherPosition.col) {
                    // Collision! Lose a life
                    sounds.wrong.currentTime = 0;
                    sounds.wrong.play();

                    state.lives--;
                    updateLivesDisplay();

                    // Remove the fox
                    removeFox(fox);

                    // Check if game over
                    if (state.lives <= 0) {
                        gameOver();
                        return;
                    }

                    // Flash the bunny
                    const cell = document.querySelector(`.grid-cell[data-row="${state.muncherPosition.row}"][data-col="${state.muncherPosition.col}"]`);
                    cell.classList.add('wrong');

                    setTimeout(() => {
                        cell.classList.remove('wrong');
                    }, 300);
                }
            }
        }

        // Remove a fox
        function removeFox(fox) {
            // Clear the move interval
            clearInterval(fox.moveInterval);

            // Remove from the DOM
            const foxElement = document.querySelector(`.fox[data-id="${fox.id}"]`);
            if (foxElement) {
                foxElement.parentNode.removeChild(foxElement);
            }

            // Remove from state
            state.troggles = state.troggles.filter(t => t.id !== fox.id);
        }

        // Game over
        function gameOver() {
            state.gameOver = true;

            // Stop fox spawner
            if (state.troggleSpawner) {
                clearInterval(state.troggleSpawner);
            }

            // Stop all foxes
            state.troggles.forEach(fox => {
                clearInterval(fox.moveInterval);
            });

            // Play game over sound
            sounds.gameOver.currentTime = 0;
            sounds.gameOver.play();

            // Show game over screen
            finalScoreElement.textContent = state.score;
            gameOverElement.style.display = 'flex';
        }

        // Level complete
        function levelComplete() {
            state.levelComplete = true;

            // Stop fox spawner
            if (state.troggleSpawner) {
                clearInterval(state.troggleSpawner);
            }

            // Stop all foxes
            state.troggles.forEach(fox => {
                clearInterval(fox.moveInterval);
            });

            // Play level complete sound
            sounds.levelUp.currentTime = 0;
            sounds.levelUp.play();

            // Animate cells before showing level complete
            const cells = document.querySelectorAll('.grid-cell');
            cells.forEach((cell, index) => {
                setTimeout(() => {
                    cell.style.transform = 'scale(0)';
                    cell.style.opacity = '0';
                }, index * 30);
            });

            // Show level complete screen after animation
            setTimeout(() => {
                levelCompleteElement.style.display = 'flex';
                levelCompleteElement.style.opacity = '0';
                levelCompleteElement.style.transform = 'scale(0.8)';

                // Fade in animation
                setTimeout(() => {
                    levelCompleteElement.style.transition = 'all 0.5s ease-out';
                    levelCompleteElement.style.opacity = '1';
                    levelCompleteElement.style.transform = 'scale(1)';
                }, 50);
            }, cells.length * 30 + 200);
        }

        // Next level
        function nextLevel() {
            sounds.buttonClick.currentTime = 0;
            sounds.buttonClick.play();

            // Check for achievements
            if (state.level === 3) {
                showAchievement("Math Explorer: Reached Level 3!");
            } else if (state.level === 5) {
                showAchievement("Math Master: Reached Level 5!");
            } else if (state.level === 10) {
                showAchievement("Math Champion: Reached Level 10!");
            }

            // Fade out level complete screen
            levelCompleteElement.style.opacity = '0';
            levelCompleteElement.style.transform = 'scale(1.2)';

            setTimeout(() => {
                levelCompleteElement.style.display = 'none';

                state.level++;
                state.correctAnswers = 0;
                state.levelComplete = false;
                state.troggles = [];

                // Update level display with animation
                const oldLevel = parseInt(levelElement.textContent);
                const newLevel = state.level;
                animateCountUp(levelElement, oldLevel, newLevel, 500);

                // Generate new mission
                generateMission();

                // Reset grid cells for animation
                const cells = document.querySelectorAll('.grid-cell');
                cells.forEach(cell => {
                    cell.style.transform = 'scale(0)';
                    cell.style.opacity = '0';
                });

                // Generate new grid values
                generateGridValues();

                // Clear any foxes
                document.querySelectorAll('.fox').forEach(el => el.remove());

                // Animate grid cells appearing
                setTimeout(() => {
                    cells.forEach((cell, index) => {
                        setTimeout(() => {
                            cell.style.transition = 'all 0.3s ease-out';
                            cell.style.transform = 'scale(1)';
                            cell.style.opacity = '1';
                        }, index * 30);
                    });
                }, 200);

                // Start spawning foxes again after animation
                setTimeout(() => {
                    startFoxSpawner();
                }, cells.length * 30 + 300);

            }, 500);
        }

        // Restart game
        function restartGame() {
            sounds.buttonClick.currentTime = 0;
            sounds.buttonClick.play();

            // Reset game state
            state = {
                score: 0,
                level: 1,
                lives: config.initialLives,
                currentMission: null,
                correctAnswers: 0,
                muncherPosition: { row: 2, col: 2 },
                troggles: [],
                grid: [],
                gameOver: false,
                levelComplete: false,
                troggleSpawner: null
            };

            // Remove existing event listeners to prevent duplicates
            document.removeEventListener('keydown', handleKeyPress);

            // Show difficulty selection
            gameOverElement.style.display = 'none';
            difficultySelectElement.style.display = 'flex';
        }

        // Utility functions
        function getFactors(num) {
            const factors = [];
            for (let i = 1; i <= num; i++) {
                if (num % i === 0) {
                    factors.push(i);
                }
            }
            return factors;
        }

        function isPrime(num) {
            if (num <= 1) return false;
            if (num <= 3) return true;
            if (num % 2 === 0 || num % 3 === 0) return false;

            let i = 5;
            while (i * i <= num) {
                if (num % i === 0 || num % (i + 2) === 0) return false;
                i += 6;
            }
            return true;
        }

        function isPerfectSquare(num) {
            const sqrt = Math.sqrt(num);
            return sqrt === Math.floor(sqrt);
        }

        function isPerfectCube(num) {
            const cbrt = Math.cbrt(num);
            return Math.abs(Math.round(cbrt) - cbrt) < 1e-10;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Start the game when the page loads
        window.addEventListener('load', initGame);
    </script>

    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.2/dist/nipplejs.js" crossorigin="anonymous"></script>
    <script>
(function (root, factory) {
    if (typeof module === "object" && module.exports) {
        module.exports = factory();
    } else {
        root.TouchpadControls = factory();
        root.touchpadControls = root.TouchpadControls;
    }
}(typeof self !== "undefined" ? self : this, function () {
    "use strict";

    const sections = {
        CENTER_LEFT: { top: "50%", left: "130px", transform: "translate(-50%, -50%)" },
        CENTER_TOP: { top: "130px", left: "50%", transform: "translate(-50%, -50%)" },
        CENTER_RIGHT: { top: "50%", left: "calc(100% - 130px)", transform: "translate(-50%, -50%)" },
        CENTER_BOTTOM: { top: "calc(100% - 130px)", left: "50%", transform: "translate(-50%, -50%)" }
    };

    const buttonPositions = {
        CENTER_LEFT: { top: "0", left: "-50px" },
        CENTER_TOP: { top: "-50px", left: "0" },
        CENTER_RIGHT: { top: "0", left: "50px" },
        CENTER_BOTTOM: { top: "50px", left: "0" }
    };

    const STYLE_ID = "touchpad-controls-style";
    const MIN_TOUCH_TARGET = 48;

    const injectTouchpadStyles = () => {
        if (typeof document === "undefined") return;
        if (document.getElementById(STYLE_ID)) return;

        const style = document.createElement("style");
        style.id = STYLE_ID;
        style.textContent = `
            :root {
                --touchpad-size: 72px;
                --touchpad-radius: 50%;
                --touchpad-bg: radial-gradient(135% 135% at 25% 20%, rgba(255,255,255,0.15), rgba(0,0,0,0.6));
                --touchpad-bg-image: none;
                --touchpad-bg-image-size: cover;
                --touchpad-bg-image-position: center;
                --touchpad-bg-blend: soft-light;
                --touchpad-border: 1px solid rgba(255,255,255,0.12);
                --touchpad-shadow: 0 12px 40px rgba(0,0,0,0.7), inset 0 1px 1px rgba(255,255,255,0.1);
                --touchpad-shadow-active: 0 4px 15px rgba(0,0,0,0.9), inset 0 1px 0 rgba(0,0,0,0.3);
                --touchpad-icon: none;
                --touchpad-icon-size: 52%;
                --touchpad-icon-opacity: 0.9;
                --touchpad-foreground-image: none;
                --touchpad-foreground-size: 60%;
                --touchpad-foreground-opacity: 0.8;
                --touchpad-foreground-blend: normal;
                --touchpad-label-color: #E2E8F0;
                --touchpad-label-size: 12px;
            }

            .touchpad {
                position: absolute;
                width: var(--touchpad-size);
                height: var(--touchpad-size);
                padding: 0;
                box-sizing: border-box;
                border-radius: var(--touchpad-radius);
                background-image: var(--touchpad-bg-image, none), var(--touchpad-bg);
                background-size: var(--touchpad-bg-image-size, cover), 100%;
                background-position: var(--touchpad-bg-image-position, center), center;
                background-repeat: no-repeat, no-repeat;
                background-blend-mode: var(--touchpad-bg-blend, soft-light), normal;
                border: var(--touchpad-border);
                box-shadow: var(--touchpad-shadow);
                display: flex;
                justify-content: center;
                align-items: center;
                touch-action: none;
                user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                font-size: 0;
                color: transparent;
                z-index: 9999;
                overflow: visible;
                backdrop-filter: blur(12px) saturate(180%);
                -webkit-backdrop-filter: blur(12px) saturate(180%);
                transition:
                    transform 120ms cubic-bezier(0.2, 0, 0, 1),
                    box-shadow 150ms ease,
                    background 200ms ease,
                    filter 150ms linear;
                background-position: center;
                background-repeat: no-repeat;
                background-size: 45%;
            }

            .touchpad::after {
                content: "";
                position: absolute;
                width: var(--touchpad-icon-size, 52%);
                height: var(--touchpad-icon-size, 52%);
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background-image: var(--touchpad-icon, none);
                background-repeat: no-repeat;
                background-position: center;
                background-size: contain;
                opacity: var(--touchpad-icon-opacity, 0.9);
                pointer-events: none;
                filter: drop-shadow(0 2px 6px rgba(0,0,0,0.6));
            }

            .touchpad::before {
                content: "";
                position: absolute;
                width: var(--touchpad-foreground-size, 60%);
                height: var(--touchpad-foreground-size, 60%);
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background-image: var(--touchpad-foreground-image, none);
                background-repeat: no-repeat;
                background-position: center;
                background-size: contain;
                opacity: var(--touchpad-foreground-opacity, 0.8);
                mix-blend-mode: var(--touchpad-foreground-blend, normal);
                pointer-events: none;
            }

            .touchpad--label {
                font-size: var(--touchpad-label-size, 12px);
                color: var(--touchpad-label-color, #E2E8F0);
            }

            .touchpad-label {
                position: absolute;
                left: 0;
                right: 0;
                bottom: 10%;
                text-align: center;
                font-weight: 600;
                pointer-events: none;
                text-shadow: 0 2px 8px rgba(0,0,0,0.7);
            }

            .touchpad.is-active {
                transform: scale(0.94) translate3d(0, 1px, 0);
                box-shadow: var(--touchpad-shadow-active);
            }

            .touchpad:hover {
                box-shadow: 0 12px 32px rgba(0,0,0,0.95);
            }

            .touchpad--button {
                font-size: 18px;
            }

            .touchpad--joystick {
                font-size: 14px;
            }

            .touchpad .nipple,
            .touchpad .nipple * {
                overflow: visible;
            }

            .touchpad .nipple .back {
                box-shadow:
                    0 0 0 1px rgba(15,23,42,0.85),
                    0 0 0 6px rgba(148,163,184,0.12),
                    0 10px 30px rgba(15,23,42,0.85);
            }

            .touchpad .nipple .front {
                box-shadow:
                    0 0 0 1px rgba(148,163,184,0.9),
                    0 8px 18px rgba(15,23,42,0.9);
            }
        `;
        document.head.appendChild(style);
    };

    const safeEntries = (obj) => {
        if (!obj || typeof obj !== "object") return [];
        return Object.entries(obj);
    };

    const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

    const formatCssValue = (value) => {
        if (typeof value === "number" && Number.isFinite(value)) {
            return `${value}px`;
        }
        return value;
    };

    const ICON_COLOR_DEFAULT = "#E2E8F0";
    const ICON_STROKE = 4;

    const svgToDataUri = (svg) => {
        const encoded = encodeURIComponent(svg)
            .replace(/%0A/g, "");
        return `url(\"data:image/svg+xml,${encoded}\")`;
    };

    const iconArrow = (direction, color) => {
        const stroke = color || ICON_COLOR_DEFAULT;
        if (direction === "left") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M40 16 L24 32 L40 48"/><path d="M26 32 H50"/></svg>`
            );
        }
        if (direction === "right") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M24 16 L40 32 L24 48"/><path d="M14 32 H38"/></svg>`
            );
        }
        if (direction === "up") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M16 30 L32 14 L48 30"/><path d="M32 16 V52"/></svg>`
            );
        }
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M16 34 L32 50 L48 34"/><path d="M32 12 V48"/></svg>`
        );
    };

    const iconHorizontal = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M18 22 L8 32 L18 42"/><path d="M46 22 L56 32 L46 42"/><path d="M14 32 H50"/></svg>`
    );

    const iconVertical = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M22 18 L32 8 L42 18"/><path d="M22 46 L32 56 L42 46"/><path d="M32 14 V50"/></svg>`
    );

    const iconDpad = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M32 16 V48"/><path d="M16 32 H48"/><path d="M24 22 L32 14 L40 22"/><path d="M24 42 L32 50 L40 42"/><path d="M22 24 L14 32 L22 40"/><path d="M42 24 L50 32 L42 40"/></svg>`
    );

    const iconCircle = (filled, color) => {
        const fillColor = color || ICON_COLOR_DEFAULT;
        if (filled) {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="14" fill="${fillColor}"/></svg>`
            );
        }
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="14" fill="none" stroke="${fillColor}" stroke-width="${ICON_STROKE}"/></svg>`
        );
    };

    const iconSquare = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="20" y="20" width="24" height="24" rx="4" fill="${color || ICON_COLOR_DEFAULT}"/></svg>`
    );

    const iconTriangle = (direction, color) => {
        const fillColor = color || ICON_COLOR_DEFAULT;
        if (direction === "left") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M22 32 L42 18 V46 Z" fill="${fillColor}"/></svg>`
            );
        }
        if (direction === "right") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M42 32 L22 18 V46 Z" fill="${fillColor}"/></svg>`
            );
        }
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 18 L18 42 H46 Z" fill="${fillColor}"/></svg>`
        );
    };

    const iconChevron = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M22 18 L34 32 L22 46"/><path d="M34 18 L46 32 L34 46"/></svg>`
    );

    const iconPause = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="20" y="18" width="8" height="28" rx="2" fill="${color || ICON_COLOR_DEFAULT}"/><rect x="36" y="18" width="8" height="28" rx="2" fill="${color || ICON_COLOR_DEFAULT}"/></svg>`
    );

    const keyLabel = (key) => {
        if (!key) return "";
        if (key.startsWith("Key") && key.length === 4) return key.slice(3);
        if (key.startsWith("Digit") && key.length === 6) return key.slice(5);
        if (key === "Space") return "SP";
        if (key === "Escape") return "ESC";
        if (key === "Enter") return "ENT";
        if (key === "Tab") return "TAB";
        if (key === "Backspace") return "BK";
        if (key === "ShiftLeft" || key === "ShiftRight") return "SH";
        if (key === "ControlLeft" || key === "ControlRight") return "CT";
        if (key === "AltLeft" || key === "AltRight") return "AL";
        if (key === "MetaLeft" || key === "MetaRight") return "MD";
        return key.slice(0, 3).toUpperCase();
    };

    const normalizeTheme = (theme) => {
        if (!theme || typeof theme !== "object") {
            return {
                iconColor: ICON_COLOR_DEFAULT,
                iconOpacity: 0.9,
                iconScale: 0.52,
                labelMode: "none",
                labelColor: ICON_COLOR_DEFAULT,
                labelSize: 12,
                background: null,
                backgroundImage: null,
                backgroundBlend: "soft-light",
                backgroundSize: "cover",
                backgroundPosition: "center",
                foregroundImage: null,
                foregroundOpacity: 0.8,
                foregroundSize: "60%",
                foregroundBlend: "normal"
            };
        }
        return {
            iconColor: theme.iconColor || ICON_COLOR_DEFAULT,
            iconOpacity: typeof theme.iconOpacity === "number" ? theme.iconOpacity : 0.9,
            iconScale: typeof theme.iconScale === "number" ? theme.iconScale : 0.52,
            labelMode: theme.labelMode || "none",
            labelColor: theme.labelColor || ICON_COLOR_DEFAULT,
            labelSize: typeof theme.labelSize === "number" ? theme.labelSize : 12,
            background: theme.background || null,
            backgroundImage: theme.backgroundImage || null,
            backgroundBlend: theme.backgroundBlend || "soft-light",
            backgroundSize: theme.backgroundSize || "cover",
            backgroundPosition: theme.backgroundPosition || "center",
            foregroundImage: theme.foregroundImage || null,
            foregroundOpacity: typeof theme.foregroundOpacity === "number" ? theme.foregroundOpacity : 0.8,
            foregroundSize: theme.foregroundSize || "60%",
            foregroundBlend: theme.foregroundBlend || "normal"
        };
    };

    const mergeTheme = (base, override) => {
        if (!override || typeof override !== "object") return base;
        return normalizeTheme(Object.assign({}, base, override));
    };

    const normalizeImageValue = (value) => {
        if (!value) return null;
        if (value.includes("url(")) return value;
        return `url(\"${value}\")`;
    };

    const applyThemeVars = (element, theme) => {
        if (!element || !theme) return;
        if (theme.background) {
            element.style.setProperty("--touchpad-bg", theme.background);
        }
        if (theme.backgroundImage) {
            element.style.setProperty("--touchpad-bg-image", normalizeImageValue(theme.backgroundImage));
            element.style.setProperty("--touchpad-bg-blend", theme.backgroundBlend || "soft-light");
            element.style.setProperty("--touchpad-bg-image-size", theme.backgroundSize || "cover");
            element.style.setProperty("--touchpad-bg-image-position", theme.backgroundPosition || "center");
        }
        if (theme.foregroundImage) {
            element.style.setProperty("--touchpad-foreground-image", normalizeImageValue(theme.foregroundImage));
            element.style.setProperty("--touchpad-foreground-opacity", String(theme.foregroundOpacity));
            element.style.setProperty("--touchpad-foreground-size", theme.foregroundSize || "60%");
            element.style.setProperty("--touchpad-foreground-blend", theme.foregroundBlend || "normal");
        }
        if (theme.iconOpacity != null) {
            element.style.setProperty("--touchpad-icon-opacity", String(theme.iconOpacity));
        }
        if (theme.iconScale != null) {
            element.style.setProperty("--touchpad-icon-size", `${Math.round(theme.iconScale * 100)}%`);
        }
        if (theme.labelColor) {
            element.style.setProperty("--touchpad-label-color", theme.labelColor);
        }
        if (theme.labelSize) {
            element.style.setProperty("--touchpad-label-size", `${theme.labelSize}px`);
        }
    };

    const resolveLabelText = (btn, labelMode) => {
        if (!btn) return "";
        if (labelMode === "none") return "";
        if (labelMode === "text") {
            if (btn.label) return String(btn.label);
            if (typeof btn.keys === "string") return keyLabel(btn.keys);
            return "";
        }
        if (labelMode === "key") {
            if (typeof btn.keys === "string") return keyLabel(btn.keys);
            return "";
        }
        if (labelMode === "both") {
            if (btn.label) return String(btn.label);
            if (typeof btn.keys === "string") return keyLabel(btn.keys);
            return "";
        }
        return "";
    };

    const iconKeycap = (label, color) => {
        const fillColor = color || ICON_COLOR_DEFAULT;
        const safe = String(label || "").replace(/[^A-Z0-9]/g, "");
        const text = safe || "";
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="12" y="14" width="40" height="36" rx="8" fill="none" stroke="${fillColor}" stroke-width="${ICON_STROKE}"/><text x="32" y="38" font-size="16" text-anchor="middle" fill="${fillColor}" font-family="monospace">${text}</text></svg>`
        );
    };

    const resolveDirectionForKey = (key, role) => {
        if (key === "ArrowLeft") return "left";
        if (key === "ArrowRight") return "right";
        if (key === "ArrowUp") return "up";
        if (key === "ArrowDown") return "down";
        if (role === "move" || role === "aim") {
            if (key === "KeyA") return "left";
            if (key === "KeyD") return "right";
            if (key === "KeyW") return "up";
            if (key === "KeyS") return "down";
        }
        return null;
    };

    const resolveIcon = (btn, theme) => {
        if (!btn) return null;
        if (btn.icon) return btn.icon;
        const iconColor = theme && theme.iconColor ? theme.iconColor : ICON_COLOR_DEFAULT;
        const meta = btn.meta || null;
        const keys = btn.keys;
        const role = btn.role;

        if (meta && meta.pair_position) {
            return iconTriangle(meta.pair_position === "right" ? "right" : "left", iconColor);
        }

        if (keys && typeof keys === "object" && !Array.isArray(keys)) {
            const hasLeft = !!keys.left;
            const hasRight = !!keys.right;
            const hasUp = !!keys.up;
            const hasDown = !!keys.down;
            if (hasLeft && hasRight && hasUp && hasDown) return iconDpad(iconColor);
            if (hasLeft && hasRight && !hasUp && !hasDown) return iconHorizontal(iconColor);
            if (hasUp && hasDown && !hasLeft && !hasRight) return iconVertical(iconColor);
            if (hasLeft && !hasRight && !hasUp && !hasDown) return iconArrow("left", iconColor);
            if (hasRight && !hasLeft && !hasUp && !hasDown) return iconArrow("right", iconColor);
            if (hasUp && !hasLeft && !hasRight && !hasDown) return iconArrow("up", iconColor);
            if (hasDown && !hasLeft && !hasRight && !hasUp) return iconArrow("down", iconColor);
        }

        if (typeof keys === "string") {
            const direction = resolveDirectionForKey(keys, role);
            if (direction) return iconArrow(direction, iconColor);
        }

        if (role === "jump") return iconArrow("up", iconColor);
        if (role === "pause") return iconPause(iconColor);
        if (role === "primary") return iconCircle(true, iconColor);
        if (role === "secondary") return iconCircle(false, iconColor);
        if (role === "tertiary") return iconSquare(iconColor);
        if (role === "modifier") return iconChevron(iconColor);
        if (role === "magnitude") return iconArrow("up", iconColor);

        if (typeof keys === "string") {
            return iconKeycap(keyLabel(keys), iconColor);
        }

        return null;
    };

    const KEY_ALIASES = {
        " ": "Space",
        "space": "Space",
        "Spacebar": "Space",
        "Esc": "Escape",
        "Return": "Enter",
        "Left": "ArrowLeft",
        "Right": "ArrowRight",
        "Up": "ArrowUp",
        "Down": "ArrowDown",
        "Del": "Delete",
        "Shift": "ShiftLeft",
        "Control": "ControlLeft",
        "Alt": "AltLeft",
        "Meta": "MetaLeft"
    };

    const KEY_DESCRIPTORS = {
        ArrowLeft: { key: "ArrowLeft", keyCode: 37 },
        ArrowRight: { key: "ArrowRight", keyCode: 39 },
        ArrowUp: { key: "ArrowUp", keyCode: 38 },
        ArrowDown: { key: "ArrowDown", keyCode: 40 },
        Space: { key: " ", keyCode: 32 },
        Enter: { key: "Enter", keyCode: 13 },
        Tab: { key: "Tab", keyCode: 9 },
        Escape: { key: "Escape", keyCode: 27 },
        Backspace: { key: "Backspace", keyCode: 8 },
        Delete: { key: "Delete", keyCode: 46 },
        Insert: { key: "Insert", keyCode: 45 },
        Home: { key: "Home", keyCode: 36 },
        End: { key: "End", keyCode: 35 },
        PageUp: { key: "PageUp", keyCode: 33 },
        PageDown: { key: "PageDown", keyCode: 34 },
        CapsLock: { key: "CapsLock", keyCode: 20 },
        NumLock: { key: "NumLock", keyCode: 144 },
        ScrollLock: { key: "ScrollLock", keyCode: 145 },
        Pause: { key: "Pause", keyCode: 19 },
        PrintScreen: { key: "PrintScreen", keyCode: 44 },
        ContextMenu: { key: "ContextMenu", keyCode: 93 },
        ShiftLeft: { key: "Shift", keyCode: 16, location: 1 },
        ShiftRight: { key: "Shift", keyCode: 16, location: 2 },
        ControlLeft: { key: "Control", keyCode: 17, location: 1 },
        ControlRight: { key: "Control", keyCode: 17, location: 2 },
        AltLeft: { key: "Alt", keyCode: 18, location: 1 },
        AltRight: { key: "Alt", keyCode: 18, location: 2 },
        MetaLeft: { key: "Meta", keyCode: 91, location: 1 },
        MetaRight: { key: "Meta", keyCode: 91, location: 2 },
        Minus: { key: "-", keyCode: 189 },
        Equal: { key: "=", keyCode: 187 },
        BracketLeft: { key: "[", keyCode: 219 },
        BracketRight: { key: "]", keyCode: 221 },
        Backslash: { key: "\\", keyCode: 220 },
        Semicolon: { key: ";", keyCode: 186 },
        Quote: { key: "'", keyCode: 222 },
        Backquote: { key: "`", keyCode: 192 },
        Comma: { key: ",", keyCode: 188 },
        Period: { key: ".", keyCode: 190 },
        Slash: { key: "/", keyCode: 191 }
    };

    const NUMPAD_DESCRIPTORS = {
        NumpadAdd: { key: "+", keyCode: 107, location: 3 },
        NumpadSubtract: { key: "-", keyCode: 109, location: 3 },
        NumpadMultiply: { key: "*", keyCode: 106, location: 3 },
        NumpadDivide: { key: "/", keyCode: 111, location: 3 },
        NumpadDecimal: { key: ".", keyCode: 110, location: 3 },
        NumpadEnter: { key: "Enter", keyCode: 13, location: 3 },
        NumpadEqual: { key: "=", keyCode: 187, location: 3 }
    };

    const resolveKeyDescriptor = (rawKey) => {
        const raw = String(rawKey);
        const key = KEY_ALIASES[raw] || raw;
        let keyCode;
        let code;
        let keyValue = key;
        let location;

        const preset = KEY_DESCRIPTORS[key];
        if (preset) {
            keyCode = preset.keyCode;
            code = key;
            keyValue = preset.key;
            location = preset.location;
        }

        if (keyCode == null) {
            if (/^Key[a-zA-Z]$/.test(key)) {
                const letter = key.charAt(3).toUpperCase();
                keyCode = letter.charCodeAt(0);
                code = key;
                keyValue = letter.toLowerCase();
            } else if (/^Digit[0-9]$/.test(key)) {
                const digit = key.charAt(5);
                keyCode = 48 + parseInt(digit, 10);
                code = key;
                keyValue = digit;
            } else if (/^F([1-9]|1[0-9]|2[0-4])$/.test(key)) {
                const number = parseInt(key.slice(1), 10);
                keyCode = 111 + number;
                code = key;
                keyValue = key;
            } else if (/^Numpad[0-9]$/.test(key)) {
                const digit = parseInt(key.slice(6), 10);
                keyCode = 96 + digit;
                code = key;
                keyValue = String(digit);
                location = 3;
            } else if (NUMPAD_DESCRIPTORS[key]) {
                const numpadPreset = NUMPAD_DESCRIPTORS[key];
                keyCode = numpadPreset.keyCode;
                code = key;
                keyValue = numpadPreset.key;
                location = numpadPreset.location;
            } else if (key.length === 1) {
                const upper = key.toUpperCase();
                keyCode = upper.charCodeAt(0);
                code = upper;
                keyValue = key;
            } else {
                keyCode = key.toUpperCase().charCodeAt(0);
                code = key;
                keyValue = key;
            }
        }

        return { key: keyValue, code, keyCode, location };
    };

    const simulateKeyEvent = (key, type) => {
        const { key: keyValue, code, keyCode, location } = resolveKeyDescriptor(key);

        if (typeof KeyboardEvent === "undefined") return;

        const eventOptions = {
            key: keyValue,
            code: code,
            keyCode: keyCode,
            which: keyCode,
            bubbles: true,
            cancelable: true
        };
        if (location != null) {
            eventOptions.location = location;
        }
        const event = new KeyboardEvent(type, eventOptions);

        const canvas = typeof document !== "undefined" ? document.querySelector("canvas") : null;
        if (canvas && typeof canvas.focus === "function") {
            canvas.focus();
            canvas.dispatchEvent(event);
        } else if (typeof document !== "undefined") {
            document.dispatchEvent(event);
        }
    };

    const sanitizeActionMeta = (actionMeta) => {
        if (!actionMeta || typeof actionMeta !== "object") return {};
        const allowedBehavior = new Set(["continuous", "discrete"]);
        const allowedInteraction = new Set(["tap", "hold", "repeat"]);
        const allowedControlSpace = new Set(["vector", "rate", "magnitude"]);
        const allowedActivation = new Set(["hold", "latch"]);
        const allowedDirectionMode = new Set(["vector", "cardinal"]);
        const allowedGranularity = new Set(["fine", "coarse"]);
        const allowedPairPosition = new Set(["left", "right"]);

        const sanitized = {};
        Object.entries(actionMeta).forEach(([action, meta]) => {
            if (!meta || typeof meta !== "object") return;
            const cleaned = {};
            Object.entries(meta).forEach(([key, value]) => {
                if (key === "behavior" && allowedBehavior.has(value)) cleaned[key] = value;
                else if (key === "interaction" && allowedInteraction.has(value)) cleaned[key] = value;
                else if (key === "simultaneous" && typeof value === "boolean") cleaned[key] = value;
                else if (key === "control_space" && allowedControlSpace.has(value)) cleaned[key] = value;
                else if (key === "activation" && allowedActivation.has(value)) cleaned[key] = value;
                else if (key === "direction_mode" && allowedDirectionMode.has(value)) cleaned[key] = value;
                else if (key === "granularity" && allowedGranularity.has(value)) cleaned[key] = value;
                else if (key === "pair_id" && typeof value === "string") cleaned[key] = value;
                else if (key === "pair_position" && allowedPairPosition.has(value)) cleaned[key] = value;
                else if (key === "kind" && typeof value === "string") cleaned[key] = value;
            });
            if (Object.keys(cleaned).length) {
                sanitized[action] = cleaned;
            }
        });
        return sanitized;
    };

    const extractMeta = (spec, kind) => {
        const meta = {};
        if (spec && typeof spec === "object") {
            ["behavior", "interaction", "simultaneous", "control_space", "activation", "direction_mode", "granularity", "pair_id", "pair_position"].forEach((field) => {
                if (field in spec) meta[field] = spec[field];
            });
        }
        if (kind) meta.kind = kind;
        return meta;
    };

    const extractActionKeys = (spec) => {
        if (spec && typeof spec === "object") {
            if ("keys" in spec) return spec.keys;
            if ("key" in spec) return spec.key;
        }
        return spec;
    };

    const selectSingleKey = (keys) => {
        if (!keys || typeof keys !== "object") return null;
        const order = ["up", "right", "down", "left"];
        for (let i = 0; i < order.length; i += 1) {
            const key = keys[order[i]];
            if (key) return key;
        }
        return null;
    };

    const axisPriority = (axis) => {
        const priority = axis.priority;
        const priorityScore = priority === "primary" ? 2 : priority === "secondary" ? 1 : 0;
        const controlSpace = axis.control_space;
        const controlScore = controlSpace === "vector" ? 2 : controlSpace === "rate" ? 1 : 0;
        return [priorityScore, controlScore];
    };

    const extractBindingsFromAxesActions = (data) => {
        if (!data || typeof data !== "object") return null;
        const axes = data.axes;
        const actions = data.actions;
        if (!Array.isArray(axes) && (typeof actions !== "object" || actions === null)) {
            return null;
        }

        const bindings = {};
        let actionMeta = {};

        if (actions && typeof actions === "object") {
            Object.entries(actions).forEach(([role, spec]) => {
                const keys = extractActionKeys(spec);
                if (!keys) return;
                bindings[role] = keys;
                const meta = extractMeta(spec, "button");
                if (Object.keys(meta).length) {
                    actionMeta[role] = meta;
                }
            });
        }

        const movementAxes = [];
        const aimAxes = [];

        if (Array.isArray(axes)) {
            axes.forEach((axis) => {
                if (!axis || typeof axis !== "object") return;
                const keys = axis.keys;
                if (!keys || typeof keys !== "object") return;
                const usage = axis.usage;
                const controlSpace = axis.control_space;
                if (usage !== "movement" && usage !== "aim") return;

                if (controlSpace === "magnitude") {
                    if (bindings.magnitude) return;
                    const magKey = selectSingleKey(keys);
                    if (!magKey) return;
                    bindings.magnitude = magKey;
                    const magMeta = extractMeta(axis, "button");
                    magMeta.control_space = "magnitude";
                    actionMeta.magnitude = magMeta;
                    return;
                }

                if (usage === "movement") movementAxes.push(axis);
                if (usage === "aim") aimAxes.push(axis);
            });
        }

        const buildAxisMapping = (axis) => {
            const keys = axis.keys;
            const meta = extractMeta(axis, "axis");
            if (axis.control_space) meta.control_space = axis.control_space;
            return { keys, meta };
        };

        const compareAxis = (a, b) => {
            const [ap, ac] = axisPriority(a);
            const [bp, bc] = axisPriority(b);
            if (ap !== bp) return bp - ap;
            return bc - ac;
        };

        if (movementAxes.length) {
            movementAxes.sort(compareAxis);
            const move = buildAxisMapping(movementAxes[0]);
            bindings.move = move.keys;
            if (Object.keys(move.meta).length) actionMeta.move = move.meta;

            if (aimAxes.length) {
                aimAxes.sort(compareAxis);
                const aim = buildAxisMapping(aimAxes[0]);
                bindings.aim = aim.keys;
                if (Object.keys(aim.meta).length) actionMeta.aim = aim.meta;
            }
        } else if (aimAxes.length) {
            aimAxes.sort(compareAxis);
            const move = buildAxisMapping(aimAxes[0]);
            bindings.move = move.keys;
            if (Object.keys(move.meta).length) actionMeta.move = move.meta;

            if (aimAxes.length > 1) {
                const aim = buildAxisMapping(aimAxes[1]);
                bindings.aim = aim.keys;
                if (Object.keys(aim.meta).length) actionMeta.aim = aim.meta;
            }
        }

        actionMeta = sanitizeActionMeta(actionMeta);
        return { bindings, actionMeta };
    };

    const resolveBindingsAndMeta = (config = {}) => {
        let bindings = config.bindings || {};
        let actionMeta = config.actionMeta || config.action_meta || {};

        let analysis = null;
        if (Array.isArray(config.axes) || (config.actions && typeof config.actions === "object")) {
            analysis = { axes: config.axes || [], actions: config.actions || {} };
        } else if (bindings && typeof bindings === "object" && (bindings.axes || bindings.actions)) {
            analysis = { axes: bindings.axes || [], actions: bindings.actions || {} };
        } else if (actionMeta && typeof actionMeta === "object" && (actionMeta.axes || actionMeta.actions)) {
            analysis = { axes: actionMeta.axes || [], actions: actionMeta.actions || {} };
        }

        if (analysis) {
            const extracted = extractBindingsFromAxesActions(analysis);
            if (extracted) {
                bindings = extracted.bindings || {};
                actionMeta = extracted.actionMeta || {};
            }
        }

        if (!bindings || typeof bindings !== "object") bindings = {};
        if (!actionMeta || typeof actionMeta !== "object") actionMeta = {};

        return { bindings, actionMeta };
    };

    const parseKeys = (keys) => {
        let keyMap = { left: null, right: null, up: null, down: null, key: null };

        if (Array.isArray(keys)) {
            if (keys.length === 2) {
                keyMap.left = keys[0] || null;
                keyMap.right = keys[1] || null;
            } else if (keys.length === 1) {
                keyMap.key = keys[0];
            } else {
                keyMap.left = keys[0] || null;
                keyMap.right = keys[1] || null;
                keyMap.up = keys[2] || null;
                keyMap.down = keys[3] || null;
            }
        } else if (keys && typeof keys === "object") {
            keyMap.left = keys.left || null;
            keyMap.right = keys.right || null;
            keyMap.up = keys.up || null;
            keyMap.down = keys.down || null;
            if (keys.key) keyMap.key = keys.key;
        } else if (typeof keys === "string") {
            keyMap.key = keys;
        }

        return keyMap;
    };

    const createNipple = (element, keys) => {
        if (typeof nipplejs === "undefined") {
            throw new Error(
                "[touchpad_controls] nipplejs is required to create joystick controls. " +
                "Include nipplejs before touchpad-controls.js."
            );
        }

        const options = {
            zone: element,
            mode: "static",
            position: { top: "50%", left: "50%" },
            color: "gray",
            size: 120,
            threshold: 0.25
        };

        const keyMap = parseKeys(keys);

        const hasLeft = keyMap.left != null;
        const hasRight = keyMap.right != null;
        const hasUp = keyMap.up != null;
        const hasDown = keyMap.down != null;
        const hasSingleKey = keyMap.key != null;

        if ((hasLeft || hasRight) && !(hasUp || hasDown)) {
            options.lockX = true;
        } else if ((hasUp || hasDown) && !(hasLeft || hasRight)) {
            options.lockY = true;
        } else if (hasSingleKey) {
            options.lockX = true;
            options.lockY = true;
        } else {
            options.lockX = false;
            options.lockY = false;
        }

        const manager = nipplejs.create(options);

        const activeKeys = {};
        const activeDirections = new Set();

        const getDirections = (direction) => {
            if (!direction) return [];
            const directions = [];
            if (direction.x === "left" || direction.x === "right") {
                directions.push(direction.x);
            }
            if (direction.y === "up" || direction.y === "down") {
                directions.push(direction.y);
            }
            return directions;
        };

        manager.on("start", () => {
            element.classList.add("is-active");
        });

        const syncDirections = (directionsSet) => {
            const toRelease = [];
            activeDirections.forEach((direction) => {
                if (!directionsSet.has(direction)) {
                    toRelease.push(direction);
                }
            });

            toRelease.forEach((direction) => {
                const key = keyMap[direction];
                if (key && activeKeys[key]) {
                    simulateKeyEvent(key, "keyup");
                    activeKeys[key] = false;
                }
                activeDirections.delete(direction);
            });

            directionsSet.forEach((direction) => {
                if (activeDirections.has(direction)) return;
                const key = keyMap[direction];
                if (!key) return;
                if (!activeKeys[key]) {
                    simulateKeyEvent(key, "keydown");
                    activeKeys[key] = true;
                }
                activeDirections.add(direction);
            });
        };

        manager.on("dir", (evt, data) => {
            const directions = getDirections(data && data.direction);
            if (!directions.length) return;
            syncDirections(new Set(directions));
        });

        const releaseAllKeys = () => {
            Object.keys(activeKeys).forEach((key) => {
                if (activeKeys[key]) {
                    simulateKeyEvent(key, "keyup");
                    activeKeys[key] = false;
                }
            });
            activeDirections.clear();
        };

        manager.on("move", (evt, data) => {
            if (!data || !data.direction) {
                releaseAllKeys();
                return;
            }

            const currentDirections = new Set();
            if (data.direction.x) currentDirections.add(data.direction.x);
            if (data.direction.y) currentDirections.add(data.direction.y);

            syncDirections(currentDirections);
        });

        manager.on("end", () => {
            releaseAllKeys();
            element.classList.remove("is-active");
        });

        return manager;
    };

    const createButton = (element, key) => {
        const keys = Array.isArray(key) ? key.filter((k) => k != null) : [key];
        if (!keys.length) return;

        let isActive = false;

        const press = (event) => {
            if (event && typeof event.preventDefault === "function") {
                event.preventDefault();
            }
            if (isActive) return;
            isActive = true;
            element.classList.add("is-active");
            keys.forEach((k) => simulateKeyEvent(k, "keydown"));
        };

        const release = (event) => {
            if (event && typeof event.preventDefault === "function") {
                event.preventDefault();
            }
            if (!isActive) return;
            isActive = false;
            element.classList.remove("is-active");
            keys.forEach((k) => simulateKeyEvent(k, "keyup"));
        };

        const handleMouseDown = (event) => {
            press(event);
            const handleMouseUp = (e) => {
                release(e);
                window.removeEventListener("mouseup", handleMouseUp);
            };
            window.addEventListener("mouseup", handleMouseUp);
        };

        const handleTouchStart = (event) => {
            press(event);
            const handleTouchEndOrCancel = (e) => {
                release(e);
                window.removeEventListener("touchend", handleTouchEndOrCancel);
                window.removeEventListener("touchcancel", handleTouchEndOrCancel);
            };
            window.addEventListener("touchend", handleTouchEndOrCancel);
            window.addEventListener("touchcancel", handleTouchEndOrCancel);
        };

        element.addEventListener("mousedown", handleMouseDown);
        element.addEventListener("touchstart", handleTouchStart, {
            passive: false
        });

        element.addEventListener("mouseup", release);
        element.addEventListener("mouseleave", release);
        element.addEventListener("touchend", release);
        element.addEventListener("touchcancel", release);
    };

    const createTouchpadControls = (config = {}) => {
        if (typeof document === "undefined") {
            throw new Error("[touchpad_controls] document is required to render controls.");
        }

        injectTouchpadStyles();

        const root = config.root || document.body || document.documentElement;
        const baseTheme = normalizeTheme(config.theme);
        const buttons = Array.isArray(config.buttons) ? config.buttons : [];

        const touchpads = [];
        const nippleManagers = [];

        buttons.forEach((btn) => {
            if (!btn) return;

            const theme = mergeTheme(baseTheme, btn.theme);
            const touchpad = document.createElement("div");
            touchpad.id = btn.id || "";
            touchpad.className = "touchpad";

            if (btn.className) {
                touchpad.className += " " + btn.className;
            }
            if (Array.isArray(btn.classList)) {
                btn.classList.forEach((cls) => {
                    if (cls) touchpad.classList.add(cls);
                });
            }

            let type = btn.type;
            if (!type) {
                if (
                    (Array.isArray(btn.keys) && btn.keys.length > 1) ||
                    (btn.keys && typeof btn.keys === "object" && !Array.isArray(btn.keys))
                ) {
                    type = "joystick";
                } else {
                    type = "button";
                }
            }

            const labelMode = btn.labelMode || theme.labelMode || "none";
            const labelText = type === "button" ? resolveLabelText(btn, labelMode) : "";
            if (labelText) {
                const labelEl = document.createElement("span");
                labelEl.className = "touchpad-label";
                labelEl.textContent = labelText;
                touchpad.classList.add("touchpad--label");
                touchpad.appendChild(labelEl);
            }

            const ariaLabel = btn.label != null
                ? String(btn.label)
                : (labelText || (typeof btn.keys === "string" ? keyLabel(btn.keys) : ""));
            if (ariaLabel) {
                touchpad.setAttribute("aria-label", ariaLabel);
            }

            const sectionName = btn.section;
            const section = sectionName && sections[sectionName] ? sections[sectionName] : null;

            safeEntries(section).forEach(([key, value]) => {
                touchpad.style[key] = value;
            });

            const posName = btn.position;
            const buttonPosition =
                posName && buttonPositions[posName]
                    ? buttonPositions[posName]
                    : null;

            if (section && buttonPosition) {
                safeEntries(buttonPosition).forEach(([key, value]) => {
                    const base = section[key] || "0px";
                    touchpad.style[key] = `calc(${base} + ${value})`;
                });
            }

            if (btn.top != null) {
                touchpad.style.top = formatCssValue(btn.top);
            }
            if (btn.left != null) {
                touchpad.style.left = formatCssValue(btn.left);
            }
            if (btn.x != null) {
                touchpad.style.left = formatCssValue(btn.x);
            }
            if (btn.y != null) {
                touchpad.style.top = formatCssValue(btn.y);
            }

            safeEntries(btn.style).forEach(([key, value]) => {
                if (value != null) {
                    touchpad.style[key] = formatCssValue(value);
                }
            });

            applyThemeVars(touchpad, theme);

            const showIcon = labelMode !== "text" && labelMode !== "key";
            if (showIcon) {
                const icon = resolveIcon(btn, theme);
                if (icon) {
                    touchpad.style.setProperty("--touchpad-icon", icon);
                }
            }

            root.appendChild(touchpad);

            touchpad.dataset.touchpadType = type;
            if (type === "joystick") {
                touchpad.classList.add("touchpad--joystick");
            } else {
                touchpad.classList.add("touchpad--button");
            }

            const tp = { element: touchpad, keys: btn.keys, type: type };
            touchpads.push(tp);
        });

        touchpads.forEach((tp) => {
            if (tp.type === "joystick") {
                const manager = createNipple(tp.element, tp.keys);
                if (manager) nippleManagers.push(manager);
            } else {
                createButton(tp.element, tp.keys);
            }
        });

        const destroy = () => {
            nippleManagers.forEach((manager) => {
                if (manager && typeof manager.destroy === "function") {
                    manager.destroy();
                }
            });

            touchpads.forEach((tp) => {
                const el = tp.element;
                if (el && el.parentNode) {
                    el.parentNode.removeChild(el);
                }
            });
        };

        return { touchpads, destroy };
    };

    const getSafeAreaInsets = (viewport) => {
        if (viewport && viewport.safeArea) {
            return {
                top: viewport.safeArea.top || 0,
                right: viewport.safeArea.right || 0,
                bottom: viewport.safeArea.bottom || 0,
                left: viewport.safeArea.left || 0
            };
        }

        if (typeof document === "undefined") {
            return { top: 0, right: 0, bottom: 0, left: 0 };
        }

        const measure = document.createElement("div");
        measure.style.cssText = [
            "position: fixed",
            "top: 0",
            "left: 0",
            "right: 0",
            "bottom: 0",
            "padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)",
            "pointer-events: none",
            "visibility: hidden"
        ].join(";");

        const root = document.body || document.documentElement;
        root.appendChild(measure);
        const style = window.getComputedStyle(measure);
        const insets = {
            top: parseFloat(style.paddingTop) || 0,
            right: parseFloat(style.paddingRight) || 0,
            bottom: parseFloat(style.paddingBottom) || 0,
            left: parseFloat(style.paddingLeft) || 0
        };
        root.removeChild(measure);
        return insets;
    };

    const normalizeBindings = (bindings = {}) => {
        const move = parseKeys(bindings.move || bindings.movement || null);
        const aim = parseKeys(bindings.aim || bindings.look || null);

        const jump = bindings.jump || null;
        const magnitude = bindings.magnitude || null;
        const primary = bindings.primary || bindings.shoot || bindings.fire || null;
        const secondary = bindings.secondary || bindings.attack || null;
        const tertiary = bindings.tertiary || (bindings.shoot && bindings.shoot !== primary ? bindings.shoot : null) || null;
        const modifier = bindings.modifier || bindings.run || null;

        return { move, aim, jump, magnitude, primary, secondary, tertiary, modifier };
    };

    const normalizeActionMeta = (actionMeta = {}) => {
        if (!actionMeta || typeof actionMeta !== "object") return {};
        return actionMeta;
    };

    const hasDirectionalKeys = (keyMap) => !!(keyMap && (keyMap.left || keyMap.right || keyMap.up || keyMap.down));

    const deriveAxisKeys = (keyMap, meta) => {
        if (!keyMap || !meta || typeof meta !== "object") return keyMap;
        const controlSpace = meta.control_space;
        if (controlSpace === "rate") {
            if (!keyMap.left && !keyMap.right) return keyMap;
            return {
                left: keyMap.left || null,
                right: keyMap.right || null,
                up: null,
                down: null
            };
        }
        if (controlSpace === "magnitude") {
            if (!keyMap.up && !keyMap.down) return keyMap;
            return {
                left: null,
                right: null,
                up: keyMap.up || null,
                down: keyMap.down || null
            };
        }
        return keyMap;
    };

    const chooseLayout = (bindings, preferredLayout, actionMeta = {}) => {
        if (preferredLayout && preferredLayout !== "auto") return preferredLayout;

        const moveMeta = actionMeta && actionMeta.move ? actionMeta.move : null;
        const moveKeys = deriveAxisKeys(bindings.move, moveMeta);
        const hasMove = hasDirectionalKeys(moveKeys);
        const hasAim = hasDirectionalKeys(bindings.aim);

        if (hasAim) return "dual-stick";
        if (hasMove) {
            const isCardinal = moveMeta && moveMeta.direction_mode === "cardinal";
            const isDiscrete = moveMeta && (
                moveMeta.behavior === "discrete" ||
                moveMeta.activation === "latch" ||
                moveMeta.granularity === "coarse"
            );
            const requiresChord = moveMeta && moveMeta.simultaneous === true;
            const hasVertical = !!(moveKeys.up || moveKeys.down);
            if (!requiresChord && (isDiscrete || (isCardinal && hasVertical))) {
                return "digital-dpad";
            }
            if (moveKeys.up || moveKeys.down) return "fast-platformer";
            return "safe-platformer";
        }
        return "runner";
    };

    const getLayoutMetrics = (viewport, options = {}) => {
        const width = viewport && Number.isFinite(viewport.width)
            ? viewport.width
            : (typeof window !== "undefined" ? window.innerWidth : 0);
        const height = viewport && Number.isFinite(viewport.height)
            ? viewport.height
            : (typeof window !== "undefined" ? window.innerHeight : 0);

        const safeArea = getSafeAreaInsets(viewport);
        const minDim = Math.max(1, Math.min(width, height));
        const orientation = width >= height ? "landscape" : "portrait";

        const baseSize = clamp(minDim * 0.17, 64, 112);
        const actionSize = clamp(minDim * 0.14, 56, 96);
        const smallActionSize = clamp(minDim * 0.12, MIN_TOUCH_TARGET, 80);
        const miniActionSize = clamp(minDim * 0.1, MIN_TOUCH_TARGET, 72);
        const spacing = clamp(minDim * 0.03, 10, 20);
        const edgePadding = clamp(minDim * 0.05, 16, 32);
        const verticalOffset = orientation === "portrait"
            ? clamp(minDim * 0.04, 8, 16)
            : clamp(minDim * 0.02, 6, 12);

        const bottomY = height - safeArea.bottom - edgePadding;

        return {
            width,
            height,
            orientation,
            safeArea,
            minDim,
            baseSize,
            actionSize,
            smallActionSize,
            miniActionSize,
            spacing,
            edgePadding,
            verticalOffset,
            bottomY
        };
    };

    const clampPosition = (pos, size, metrics) => {
        const minX = metrics.safeArea.left + metrics.edgePadding + size / 2;
        const maxX = metrics.width - metrics.safeArea.right - metrics.edgePadding - size / 2;
        const minY = metrics.safeArea.top + metrics.edgePadding + size / 2;
        const maxY = metrics.height - metrics.safeArea.bottom - metrics.edgePadding - size / 2;
        return {
            x: clamp(pos.x, minX, maxX),
            y: clamp(pos.y, minY, maxY)
        };
    };

    const makeButton = (spec) => {
        const baseStyle = {
            width: spec.size,
            height: spec.size,
            transform: "translate(-50%, -50%)"
        };

        return {
            id: spec.id,
            label: spec.label || "",
            keys: spec.keys,
            x: spec.x,
            y: spec.y,
            size: spec.size,
            role: spec.role,
            type: spec.type,
            meta: spec.meta || null,
            icon: spec.icon || null,
            classList: spec.classList || [],
            style: Object.assign(baseStyle, spec.style || {})
        };
    };

    const getActionSize = (sizes, role) => {
        if (!sizes) return 0;
        return sizes[role] || sizes.secondary || sizes.primary || 0;
    };

    const findPairedActions = (actions = []) => {
        const groups = new Map();
        actions.forEach((action) => {
            const meta = action && action.meta ? action.meta : null;
            const pairId = meta && meta.pair_id;
            if (!pairId) return;
            if (!groups.has(pairId)) groups.set(pairId, []);
            groups.get(pairId).push(action);
        });

        for (const [pairId, group] of groups.entries()) {
            if (group.length < 2) continue;
            let left = group.find((action) => action.meta && action.meta.pair_position === "left");
            let right = group.find((action) => action.meta && action.meta.pair_position === "right");
            if (!left || !right) {
                left = group[0];
                right = group[1];
            }
            if (left === right) continue;
            return { pairId, left, right };
        }
        return null;
    };

    const buildActionCluster = (anchor, actions, sizes, metrics) => {
        const buttons = [];
        if (!actions.length) return buttons;

        const pair = findPairedActions(actions);
        if (!pair) {
            const primary = actions[0];
            const primarySize = sizes.primary;
            const primaryPos = clampPosition(anchor, primarySize, metrics);
            buttons.push(makeButton({
                id: primary.role,
                keys: primary.keys,
                role: primary.role,
                x: primaryPos.x,
                y: primaryPos.y,
                size: primarySize,
                meta: primary.meta || null,
                classList: ["touchpad-role-" + primary.role]
            }));

            if (actions[1]) {
                const secondary = actions[1];
                const secondarySize = sizes.secondary;
                const secondaryPos = clampPosition({
                    x: anchor.x,
                    y: anchor.y - (primarySize / 2 + metrics.spacing + secondarySize / 2)
                }, secondarySize, metrics);
                buttons.push(makeButton({
                    id: secondary.role,
                    keys: secondary.keys,
                    role: secondary.role,
                    x: secondaryPos.x,
                    y: secondaryPos.y,
                    size: secondarySize,
                    meta: secondary.meta || null,
                    classList: ["touchpad-role-" + secondary.role]
                }));
            }

            if (actions[2]) {
                const tertiary = actions[2];
                const tertiarySize = sizes.tertiary;
                const tertiaryPos = clampPosition({
                    x: anchor.x - (primarySize / 2 + metrics.spacing + tertiarySize / 2),
                    y: anchor.y - primarySize * 0.2
                }, tertiarySize, metrics);
                buttons.push(makeButton({
                    id: tertiary.role,
                    keys: tertiary.keys,
                    role: tertiary.role,
                    x: tertiaryPos.x,
                    y: tertiaryPos.y,
                    size: tertiarySize,
                    meta: tertiary.meta || null,
                    classList: ["touchpad-role-" + tertiary.role]
                }));
            }

            if (actions[3]) {
                const modifier = actions[3];
                const modifierSize = sizes.modifier;
                const modifierPos = clampPosition({
                    x: anchor.x - (primarySize / 2 + metrics.spacing + modifierSize / 2),
                    y: anchor.y - (primarySize / 2 + metrics.spacing + modifierSize / 2)
                }, modifierSize, metrics);
                buttons.push(makeButton({
                    id: modifier.role,
                    keys: modifier.keys,
                    role: modifier.role,
                    x: modifierPos.x,
                    y: modifierPos.y,
                    size: modifierSize,
                    meta: modifier.meta || null,
                    classList: ["touchpad-role-" + modifier.role]
                }));
            }

            return buttons;
        }

        const used = new Set();
        const place = (action, pos, size) => {
            if (!action || used.has(action)) return;
            used.add(action);
            const clamped = clampPosition(pos, size, metrics);
            buttons.push(makeButton({
                id: action.role,
                keys: action.keys,
                role: action.role,
                x: clamped.x,
                y: clamped.y,
                size,
                meta: action.meta || null,
                classList: ["touchpad-role-" + action.role]
            }));
        };

        const primary = actions.find((action) => action.role === "primary" && action !== pair.left && action !== pair.right)
            || actions.find((action) => action !== pair.left && action !== pair.right);
        const primarySize = primary ? getActionSize(sizes, primary.role) : 0;

        const leftAction = pair.left;
        const rightAction = pair.right;
        const leftSize = getActionSize(sizes, leftAction.role);
        const rightSize = getActionSize(sizes, rightAction.role);
        const rowHeight = Math.max(leftSize, rightSize);
        const rowWidth = leftSize + rightSize + metrics.spacing;

        const minCenterX = metrics.safeArea.left + metrics.edgePadding + rowWidth / 2;
        const maxCenterX = metrics.width - metrics.safeArea.right - metrics.edgePadding - rowWidth / 2;
        const centerX = clamp(anchor.x, minCenterX, maxCenterX);

        let primaryPos = null;
        if (primary) {
            primaryPos = clampPosition({ x: centerX, y: anchor.y }, primarySize, metrics);
            place(primary, primaryPos, primarySize);
        }

        const baseY = primaryPos ? primaryPos.y : anchor.y;
        const rowY = primaryPos
            ? baseY - (primarySize / 2 + metrics.spacing + rowHeight / 2)
            : baseY;

        const leftX = centerX - rowWidth / 2 + leftSize / 2;
        const rightX = centerX + rowWidth / 2 - rightSize / 2;
        place(leftAction, { x: leftX, y: rowY }, leftSize);
        place(rightAction, { x: rightX, y: rowY }, rightSize);

        let stackY = rowY - rowHeight / 2 - metrics.spacing;
        actions.forEach((action) => {
            if (used.has(action)) return;
            const size = getActionSize(sizes, action.role);
            place(action, { x: centerX, y: stackY - size / 2 }, size);
            stackY = stackY - size - metrics.spacing;
        });

        return buttons;
    };

    const buildButtonsForLayout = (layout, bindings, metrics, actionMeta) => {
        const buttons = [];
        const actions = [];
        const roleOrder = ["magnitude", "jump", "primary", "secondary", "tertiary", "modifier"];
        const roleBaseScore = {
            magnitude: 5,
            jump: 4,
            primary: 3,
            secondary: 2,
            tertiary: 1,
            modifier: 1
        };

        const moveMeta = actionMeta && actionMeta.move ? actionMeta.move : null;
        const moveKeys = deriveAxisKeys(bindings.move, moveMeta);

        const usedKeys = new Set();
        const addAction = (role, keys) => {
            if (!keys) return;
            const signature = JSON.stringify(keys);
            if (usedKeys.has(signature)) return;
            usedKeys.add(signature);
            actions.push({
                role,
                keys,
                meta: actionMeta && actionMeta[role] ? actionMeta[role] : null
            });
        };

        roleOrder.forEach((role) => addAction(role, bindings[role]));

        actions.forEach((action, index) => {
            const meta = action.meta || {};
            let score = roleBaseScore[action.role] || 0;
            if (meta.behavior === "discrete") score += 1;
            if (meta.interaction === "tap") score += 1;
            if (meta.simultaneous === true) score += 1;
            if (meta.control_space === "magnitude") score += 2;
            if (meta.behavior === "continuous" && meta.interaction === "hold" && meta.simultaneous === false) {
                score -= 1;
            }
            action._score = score;
            action._index = index;
        });

        actions.sort((a, b) => {
            if (b._score !== a._score) return b._score - a._score;
            return a._index - b._index;
        });

        const leftAnchor = {
            x: metrics.safeArea.left + metrics.edgePadding + metrics.baseSize / 2,
            y: metrics.bottomY - metrics.baseSize / 2 - metrics.verticalOffset
        };
        const rightAnchor = {
            x: metrics.width - metrics.safeArea.right - metrics.edgePadding - metrics.baseSize / 2,
            y: metrics.bottomY - metrics.baseSize / 2 - metrics.verticalOffset
        };

        if (!actions.length && !hasDirectionalKeys(moveKeys) && !hasDirectionalKeys(bindings.aim)) {
            return buttons;
        }

        if (layout === "digital-dpad") {
            if (hasDirectionalKeys(moveKeys)) {
                const dpadSize = clamp(metrics.baseSize * 0.5, MIN_TOUCH_TARGET, metrics.baseSize * 0.75);
                const dpadGap = clamp(dpadSize * 0.2, 6, 14);
                const offset = dpadSize + dpadGap;
                const radius = offset + dpadSize / 2;
                const minCenterX = metrics.safeArea.left + metrics.edgePadding + radius;
                const maxCenterX = metrics.width - metrics.safeArea.right - metrics.edgePadding - radius;
                const minCenterY = metrics.safeArea.top + metrics.edgePadding + radius;
                const maxCenterY = metrics.height - metrics.safeArea.bottom - metrics.edgePadding - radius;
                const center = {
                    x: clamp(leftAnchor.x, minCenterX, maxCenterX),
                    y: clamp(leftAnchor.y, minCenterY, maxCenterY)
                };
                const directions = [
                    { name: "up", x: center.x, y: center.y - offset },
                    { name: "down", x: center.x, y: center.y + offset },
                    { name: "left", x: center.x - offset, y: center.y },
                    { name: "right", x: center.x + offset, y: center.y }
                ];

                directions.forEach((dir) => {
                    const key = moveKeys[dir.name];
                    if (!key) return;
                    buttons.push(makeButton({
                        id: `move-${dir.name}`,
                        keys: key,
                        role: "move",
                        x: dir.x,
                        y: dir.y,
                        size: dpadSize,
                        type: "button",
                        meta: actionMeta && actionMeta.move ? actionMeta.move : null,
                        classList: ["touchpad-role-move", "touchpad--dpad", `touchpad-move-${dir.name}`]
                    }));
                });
            }

            const clusterButtons = buildActionCluster(
                rightAnchor,
                actions,
                {
                    primary: metrics.actionSize,
                    secondary: metrics.smallActionSize,
                    tertiary: metrics.smallActionSize,
                    modifier: metrics.miniActionSize
                },
                metrics
            );
            buttons.push(...clusterButtons);
        } else if (layout === "safe-platformer" || layout === "fast-platformer") {
            if (hasDirectionalKeys(moveKeys)) {
                const moveSize = metrics.baseSize;
                const movePos = clampPosition(leftAnchor, moveSize, metrics);
                buttons.push(makeButton({
                    id: "move",
                    keys: moveKeys,
                    role: "move",
                    x: movePos.x,
                    y: movePos.y,
                    size: moveSize,
                    meta: actionMeta && actionMeta.move ? actionMeta.move : null,
                    classList: ["touchpad-role-move"]
                }));
            }

            const clusterButtons = buildActionCluster(
                rightAnchor,
                actions,
                {
                    primary: metrics.actionSize,
                    secondary: metrics.smallActionSize,
                    tertiary: metrics.smallActionSize,
                    modifier: metrics.miniActionSize
                },
                metrics
            );
            buttons.push(...clusterButtons);
        } else if (layout === "dual-stick") {
            const moveSize = clamp(metrics.baseSize * 1.05, 64, 120);
            const aimSize = clamp(metrics.baseSize * 0.95, 60, 112);

            if (hasDirectionalKeys(moveKeys)) {
                const leftPos = clampPosition({
                    x: metrics.safeArea.left + metrics.edgePadding + moveSize / 2,
                    y: metrics.bottomY - moveSize / 2 - metrics.verticalOffset
                }, moveSize, metrics);
                buttons.push(makeButton({
                    id: "move",
                    keys: moveKeys,
                    role: "move",
                    x: leftPos.x,
                    y: leftPos.y,
                    size: moveSize,
                    meta: actionMeta && actionMeta.move ? actionMeta.move : null,
                    classList: ["touchpad-role-move"]
                }));
            }

            if (hasDirectionalKeys(bindings.aim)) {
                const rightPos = clampPosition({
                    x: metrics.width - metrics.safeArea.right - metrics.edgePadding - aimSize / 2,
                    y: metrics.bottomY - aimSize / 2 - metrics.verticalOffset
                }, aimSize, metrics);
                buttons.push(makeButton({
                    id: "aim",
                    keys: bindings.aim,
                    role: "aim",
                    x: rightPos.x,
                    y: rightPos.y,
                    size: aimSize,
                    meta: actionMeta && actionMeta.aim ? actionMeta.aim : null,
                    classList: ["touchpad-role-aim"]
                }));

                if (actions[0]) {
                    const fireSize = metrics.actionSize;
                    const firePos = clampPosition({
                        x: rightPos.x,
                        y: rightPos.y - (aimSize / 2 + metrics.spacing + fireSize / 2)
                    }, fireSize, metrics);
                    buttons.push(makeButton({
                        id: actions[0].role,
                        keys: actions[0].keys,
                        role: actions[0].role,
                        x: firePos.x,
                        y: firePos.y,
                        size: fireSize,
                        meta: actions[0].meta || null,
                        classList: ["touchpad-role-" + actions[0].role]
                    }));
                }
            }
        } else if (layout === "runner") {
            const actionCount = Math.min(actions.length || 1, 4);
            const slots = actionCount === 1
                ? [0.5]
                : actionCount === 2
                    ? [0.35, 0.65]
                    : actionCount === 3
                        ? [0.2, 0.5, 0.8]
                        : [0.15, 0.4, 0.6, 0.85];

            const size = metrics.actionSize;
            const availableWidth = metrics.width - metrics.safeArea.left - metrics.safeArea.right - metrics.edgePadding * 2;
            const bandY = metrics.bottomY - size / 2 - metrics.verticalOffset;

            for (let i = 0; i < actionCount; i += 1) {
                const action = actions[i] || actions[0] || { role: "primary", keys: bindings.primary };
                const x = metrics.safeArea.left + metrics.edgePadding + availableWidth * slots[i];
                const pos = clampPosition({ x, y: bandY }, size, metrics);
                buttons.push(makeButton({
                    id: action.role,
                    keys: action.keys,
                    role: action.role,
                    x: pos.x,
                    y: pos.y,
                    size: size,
                    meta: action.meta || null,
                    classList: ["touchpad-role-" + action.role]
                }));
            }
        }

        return buttons;
    };

    const buildLayout = (config = {}) => {
        const resolved = resolveBindingsAndMeta(config);
        const normalized = normalizeBindings(resolved.bindings || {});
        const actionMeta = normalizeActionMeta(resolved.actionMeta || {});
        const layout = chooseLayout(normalized, config.layout, actionMeta);
        const metrics = getLayoutMetrics(config.viewport, config);
        const buttons = buildButtonsForLayout(layout, normalized, metrics, actionMeta);
        return { layout, buttons, metrics, bindings: normalized, actionMeta };
    };

    const roundLayoutValue = (value) => {
        if (typeof value !== "number" || !Number.isFinite(value)) return value;
        return Math.round(value * 10) / 10;
    };

    const summarizeLayout = (layoutConfig) => {
        if (!layoutConfig || typeof layoutConfig !== "object") return null;
        const buttons = Array.isArray(layoutConfig.buttons) ? layoutConfig.buttons : [];
        return {
            layout: layoutConfig.layout || null,
            buttons: buttons.map((btn) => ({
                id: btn.id || null,
                role: btn.role || null,
                type: btn.type || (btn.keys && typeof btn.keys === "object" ? "joystick" : "button"),
                keys: btn.keys || null,
                x: roundLayoutValue(btn.x),
                y: roundLayoutValue(btn.y),
                size: roundLayoutValue(btn.size)
            }))
        };
    };

    const createGesturePrevention = (options = {}) => {
        if (typeof document === "undefined") return () => {};

        const extraExclusions = Array.isArray(options.excludeSelectors) ? options.excludeSelectors : [];
        const handler = (event) => {
            if (!event || typeof event.preventDefault !== "function") return;
            const target = event.target;
            if (!target) {
                event.preventDefault();
                return;
            }

            const tagName = target.tagName;
            const blockedTags = ["SELECT", "OPTION", "BUTTON", "INPUT", "TEXTAREA", "A"];
            if (tagName && blockedTags.includes(tagName)) return;

            if (extraExclusions.some((selector) => target.closest && target.closest(selector))) return;

            event.preventDefault();
        };

        document.addEventListener("touchmove", handler, { passive: false });
        document.addEventListener("touchstart", handler, { passive: false });
        document.addEventListener("gesturestart", handler);
        document.addEventListener("gesturechange", handler);
        document.addEventListener("gestureend", handler);

        return () => {
            document.removeEventListener("touchmove", handler);
            document.removeEventListener("touchstart", handler);
            document.removeEventListener("gesturestart", handler);
            document.removeEventListener("gesturechange", handler);
            document.removeEventListener("gestureend", handler);
        };
    };

    const create = (config = {}) => {
        const layoutConfig = buildLayout(config);
        if (config.debug && typeof console !== "undefined" && typeof console.info === "function") {
            console.info("[touchpad_controls] layout", summarizeLayout(layoutConfig));
        }
        const hasCustomButtons = Array.isArray(config.buttons) && config.buttons.length > 0;
        const buttons = hasCustomButtons ? config.buttons : layoutConfig.buttons;
        const root = config.root;

        if (config.preventGestures !== false) {
            const excludeSelectors = config.excludeSelectors || [];
            var removeGesturePrevention = createGesturePrevention({ excludeSelectors });
        }

        let instance = createTouchpadControls({ root, buttons });
        let resizeTimer = null;

        const rebuild = () => {
            if (instance && typeof instance.destroy === "function") {
                instance.destroy();
            }
            const nextLayout = buildLayout(config);
            if (config.debug && typeof console !== "undefined" && typeof console.info === "function") {
                console.info("[touchpad_controls] layout", summarizeLayout(nextLayout));
            }
            const nextButtons = hasCustomButtons ? config.buttons : nextLayout.buttons;
            instance = createTouchpadControls({ root, buttons: nextButtons });
        };

        const handleResize = () => {
            if (resizeTimer) window.clearTimeout(resizeTimer);
            resizeTimer = window.setTimeout(rebuild, 120);
        };

        if (config.responsive !== false && typeof window !== "undefined") {
            window.addEventListener("resize", handleResize);
        }

        return {
            layout: layoutConfig.layout,
            buttons,
            diagnostics: config.debug ? summarizeLayout(layoutConfig) : null,
            destroy: () => {
                if (resizeTimer && typeof window !== "undefined") {
                    window.clearTimeout(resizeTimer);
                }
                if (config.responsive !== false && typeof window !== "undefined") {
                    window.removeEventListener("resize", handleResize);
                }
                if (instance && typeof instance.destroy === "function") {
                    instance.destroy();
                }
                if (typeof removeGesturePrevention === "function") {
                    removeGesturePrevention();
                }
            },
            rebuild
        };
    };

    return {
        createTouchpadControls,
        create,
        buildLayout,
        chooseLayout,
        getLayoutMetrics,
        parseKeys,
        simulateKeyEvent,
        resolveKeyDescriptor,
        _internal: {
            buildButtonsForLayout,
            normalizeBindings,
            clampPosition,
            summarizeLayout,
            extractBindingsFromAxesActions,
            resolveBindingsAndMeta
        }
    };
}));

</script>
    <script>
    const touchBindings = {
        "primary": "Space",
        "move": {
            "left": "ArrowLeft",
            "right": "ArrowRight",
            "up": "ArrowUp",
            "down": "ArrowDown"
        }
    };
    const touchActionMeta = {
        "primary": {
            "behavior": "discrete",
            "interaction": "tap",
            "simultaneous": true,
            "kind": "button"
        },
        "move": {
            "behavior": "discrete",
            "interaction": "hold",
            "simultaneous": false,
            "control_space": "vector",
            "activation": "hold",
            "direction_mode": "cardinal",
            "granularity": "coarse",
            "kind": "axis"
        }
    };

    TouchpadControls.create({
        layout: "auto",
        bindings: touchBindings,
        actionMeta: touchActionMeta,
        debug: true,
    });
</script>
</body>
</html>