<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bogglebeast Quest</title>
    <style>
        @font-face {
            font-family: 'PixelFont';
            src: url('https://cdn.fuzzycode.dev/resolve?url=https://fonts.cdnfonts.com/css/press-start-2p');
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'PixelFont', 'Press Start 2P', monospace;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            image-rendering: pixelated;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            margin: 0 auto;
            overflow: hidden;
            background-color: #111;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://images.fuzzycode.dev/fast_ai?search=pixelated%20fantasy%20world%20with%20colorful%20landscapes%20and%20pixel%20art%20style&resize=800x600') no-repeat center center;
            background-size: cover;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #title {
            font-size: 48px;
            text-shadow: 4px 4px 0 #000, -4px -4px 0 #000, 4px -4px 0 #000, -4px 4px 0 #000;
            margin-bottom: 20px;
            color: #f8e71c;
            text-align: center;
            animation: pulse 2s infinite;
        }

        #subtitle {
            font-size: 16px;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
            margin-bottom: 40px;
            color: #fff;
            text-align: center;
            max-width: 600px;
        }

        .menu-button {
            background-color: #4a6cd1;
            color: white;
            border: 4px solid #fff;
            padding: 12px 24px;
            margin: 10px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            text-transform: uppercase;
        }

        .menu-button:hover {
            background-color: #f8e71c;
            color: #000;
            transform: scale(1.05);
        }

        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        #health-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 5px;
        }

        .health-point {
            width: 20px;
            height: 20px;
            background-color: #f00;
            border: 2px solid #fff;
        }

        #color-powers {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .color-power {
            width: 30px;
            height: 30px;
            border: 3px solid #fff;
            border-radius: 50%;
            opacity: 0.5;
        }

        .color-power.active {
            opacity: 1;
            box-shadow: 0 0 10px 2px currentColor;
        }

        #red-power {
            background-color: #ff0000;
            color: #ff0000;
        }

        #blue-power {
            background-color: #0000ff;
            color: #0000ff;
        }

        #yellow-power {
            background-color: #ffff00;
            color: #ffff00;
        }

        #green-power {
            background-color: #00ff00;
            color: #00ff00;
        }

        #collect-counter {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #spark-icon {
            width: 24px;
            height: 24px;
            background-color: #f8e71c;
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
        }

        #level-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 16px;
        }

        #dialog-box {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            background-color: rgba(0, 0, 0, 0.8);
            border: 4px solid #fff;
            padding: 15px;
            display: none;
            z-index: 20;
        }

        #dialog-text {
            font-size: 16px;
            line-height: 1.4;
        }

        #dialog-continue {
            margin-top: 10px;
            text-align: right;
            font-size: 14px;
            animation: blink 1s infinite;
        }

        #game-over, #level-complete {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 15;
        }

        .screen-title {
            font-size: 48px;
            margin-bottom: 40px;
            text-align: center;
        }

        #game-over .screen-title {
            color: #ff0000;
        }

        #level-complete .screen-title {
            color: #f8e71c;
        }

        #pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        #pause-title {
            font-size: 36px;
            margin-bottom: 30px;
            color: #f8e71c;
        }

        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
        }

        #loading-text {
            font-size: 24px;
            margin-bottom: 20px;
            color: #f8e71c;
        }

        #loading-bar-container {
            width: 300px;
            height: 20px;
            border: 3px solid #fff;
            padding: 2px;
        }

        #loading-bar {
            height: 100%;
            background-color: #f8e71c;
            width: 0%;
            transition: width 0.3s;
        }

        #controls-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 25;
            padding: 30px;
        }

        #controls-title {
            font-size: 36px;
            margin-bottom: 30px;
            color: #f8e71c;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            width: 70%;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .control-key {
            background-color: #4a6cd1;
            padding: 5px 10px;
            border: 2px solid #fff;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }

        #wumpus-sprite {
            position: absolute;
            width: 50px;
            height: 50px;
            background: url('https://images.fuzzycode.dev/fast_ai?search=cute%20fluffy%20round%20creature%20with%20big%20eyes%20pixel%20art&resize=50x50&transparency=true') no-repeat;
            background-size: contain;
            transform: translateX(-50%) translateY(-50%);
            z-index: 2;
        }

        .platform {
            position: absolute;
            background-color: #8a5d3b;
            border-top: 4px solid #a87d5b;
        }

        .enemy {
            position: absolute;
            width: 40px;
            height: 40px;
            background: url('https://images.fuzzycode.dev/fast_ai?search=blob%20monster%20pixel%20art&resize=40x40&transparency=true') no-repeat;
            background-size: contain;
            z-index: 2;
        }

        .collectible {
            position: absolute;
            width: 30px;
            height: 30px;
            background: url('https://images.fuzzycode.dev/fast_ai?search=glowing%20star%20spark%20pixel%20art&resize=30x30&transparency=true') no-repeat;
            background-size: contain;
            animation: pulse 1.5s infinite;
            z-index: 1;
        }

        .color-berry {
            position: absolute;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            z-index: 1;
        }

        .color-berry.red {
            background-color: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        .color-berry.blue {
            background-color: #0000ff;
            box-shadow: 0 0 10px #0000ff;
        }

        .color-berry.yellow {
            background-color: #ffff00;
            box-shadow: 0 0 10px #ffff00;
        }

        .color-berry.green {
            background-color: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        .background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            z-index: 0;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-canvas"></div>

        <div id="game-ui">
            <div id="health-bar">
                <div class="health-point"></div>
                <div class="health-point"></div>
                <div class="health-point"></div>
            </div>

            <div id="color-powers">
                <div id="red-power" class="color-power"></div>
                <div id="blue-power" class="color-power"></div>
                <div id="yellow-power" class="color-power"></div>
                <div id="green-power" class="color-power"></div>
            </div>

            <div id="collect-counter">
                <div id="spark-icon"></div>
                <span id="spark-count">0/5</span>
            </div>

            <div id="level-indicator">Wonderwood Whimsy - 1-1</div>
        </div>

        <div id="dialog-box">
            <div id="dialog-text">Welcome to Luminara, Wumpus! The Flow of Wonder has been shattered by the sinister Scrangle. It's up to you to restore magic to our world!</div>
            <div id="dialog-continue">Press SPACE to continue...</div>
        </div>

        <div id="menu-screen">
            <h1 id="title">BOGGLEBEAST QUEST</h1>
            <p id="subtitle">Embark on a whimsical adventure as Wumpus the Bogglebeast, a shape-shifting, color-changing critter on a quest to restore the fractured Flow of Wonder!</p>
            <button id="start-button" class="menu-button">Start Game</button>
            <button id="controls-button" class="menu-button">Controls</button>
        </div>

        <div id="game-over">
            <h2 class="screen-title">GAME OVER</h2>
            <button id="retry-button" class="menu-button">Try Again</button>
            <button id="menu-button-1" class="menu-button">Main Menu</button>
        </div>

        <div id="level-complete">
            <h2 class="screen-title">LEVEL COMPLETE!</h2>
            <p id="level-stats">Sparks Collected: 0/5</p>
            <button id="next-level-button" class="menu-button">Next Level</button>
            <button id="menu-button-2" class="menu-button">Main Menu</button>
        </div>

        <div id="pause-screen">
            <h2 id="pause-title">PAUSED</h2>
            <button id="resume-button" class="menu-button">Resume</button>
            <button id="menu-button-3" class="menu-button">Main Menu</button>
        </div>

        <div id="loading-screen">
            <h2 id="loading-text">LOADING...</h2>
            <div id="loading-bar-container">
                <div id="loading-bar"></div>
            </div>
        </div>

        <div id="controls-screen">
            <h2 id="controls-title">CONTROLS</h2>
            <div class="control-item">
                <span>Move Left/Right</span>
                <span class="control-key">A / D or Arrow Keys</span>
            </div>
            <div class="control-item">
                <span>Jump</span>
                <span class="control-key">SPACE or W</span>
            </div>
            <div class="control-item">
                <span>Special Ability</span>
                <span class="control-key">SHIFT</span>
            </div>
            <div class="control-item">
                <span>Change Color (when available)</span>
                <span class="control-key">1-4 Keys</span>
            </div>
            <div class="control-item">
                <span>Pause Game</span>
                <span class="control-key">ESC or P</span>
            </div>
            <button id="back-button" class="menu-button">Back</button>
        </div>
    </div>

    <script>
        // Helper functions for robust and standardized collision handling
        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        function getOverlap(obj1, obj2) {
            const overlapX = Math.min(obj1.x + obj1.width, obj2.x + obj2.width) - Math.max(obj1.x, obj2.x);
            const overlapY = Math.min(obj1.y + obj1.height, obj2.y + obj2.height) - Math.max(obj1.y, obj2.y);
            return { overlapX, overlapY };
        }

        // Reusable collision processing for objects like collectibles and color berries
        function processCollisions(entity, collidables, callback) {
            collidables.forEach(obj => {
                if (!obj.collected && checkCollision(entity, obj)) {
                    callback(obj);
                }
            });
        }

        // Game variables
        const game = {
            isRunning: false,
            isPaused: false,
            currentLevel: 1,
            currentWorld: 1,
            health: 3,
            sparksCollected: 0,
            totalSparks: 5,
            totalSparksInGame: 0,
            currentColor: "red", // Default mode is red
            unlockedColors: {
                red: true,
                blue: false,
                yellow: false,
                green: false
            },
            unlockedPowerups: {
                zippyZapperHat: false,
                puffPodBoots: false,
                echoOrb: false
            },
            worldNames: [
                "Wonderwood Whimsy",
                "Gelatinous Jungle",
                "Clockwork Carnival",
                "Melodica Mountains",
                "Scrangle's Nightmare Nexus"
            ],
            dialogQueue: [],
            isShowingDialog: false,
            gravity: 0.5,
            // Default jump force for red mode is -12
            jumpForce: -12,
            secretDoorsFound: 0,
            totalSecretDoors: 15,
            timeAttackUnlocked: false,
            characters: {
                professor: {
                    name: "Professor Piffletock",
                    image: "https://images.fuzzycode.dev/fast_ai?search=owl%20inventor%20with%20glasses%20pixel%20art&resize=50x50&transparency=true"
                },
                twink: {
                    name: "Twink",
                    image: "https://images.fuzzycode.dev/fast_ai?search=tiny%20blue%20sprite%20fairy%20pixel%20art&resize=40x40&transparency=true"
                },
                blip: {
                    name: "Blip",
                    image: "https://images.fuzzycode.dev/fast_ai?search=tiny%20pink%20sprite%20fairy%20pixel%20art&resize=40x40&transparency=true" 
                },
                scrangle: {
                    name: "Scrangle",
                    image: "https://images.fuzzycode.dev/fast_ai?search=shadowy%20trickster%20villain%20pixel%20art&resize=60x60&transparency=true"
                }
            }
        };

        // Mode settings mapping: Each mode defines its own speed, jump force, and sprite background
        const modeSettings = {
            red: {
                speed: 5,
                jumpForce: -12,
                background: "url('https://images.fuzzycode.dev/fast_ai?search=cute%20fluffy%20round%20creature%20with%20big%20eyes%20red%20tint%20pixel%20art&resize=50x50&transparency=true') no-repeat",
                ability: "Charge into enemies and break barriers",
                specialCooldown: 60
            },
            blue: {
                speed: 4,
                jumpForce: -12,
                background: "url('https://images.fuzzycode.dev/fast_ai?search=cute%20fluffy%20round%20creature%20with%20big%20eyes%20blue%20tint%20pixel%20art&resize=50x50&transparency=true') no-repeat",
                ability: "Phase through certain objects and walk on water",
                specialCooldown: 120
            },
            yellow: {
                speed: 5,
                jumpForce: -15,
                background: "url('https://images.fuzzycode.dev/fast_ai?search=cute%20fluffy%20round%20creature%20with%20big%20eyes%20yellow%20tint%20pixel%20art&resize=50x50&transparency=true') no-repeat",
                ability: "Bounce higher and deflect projectiles",
                specialCooldown: 90
            },
            green: {
                speed: 3.5,
                jumpForce: -12,
                background: "url('https://images.fuzzycode.dev/fast_ai?search=cute%20fluffy%20round%20creature%20with%20big%20eyes%20green%20tint%20pixel%20art&resize=50x50&transparency=true') no-repeat",
                ability: "Climb walls and stick to ceilings",
                specialCooldown: 45
            }
        };

        // Player object
        const player = {
            x: 100,
            y: 300,
            width: 50,
            height: 50,
            velocityX: 0,
            velocityY: 0,
            speed: 5,
            isJumping: false,
            isOnGround: false,
            isOnWall: false,
            isOnCeiling: false,
            direction: 1,
            element: null,
            specialCooldown: 0,
            colorChangeTimer: 0,
            morphState: "normal", // normal, inflated, shrunken, elongated
            morphTimer: 0,
            invincibilityTimer: 0
        };

        // Game elements arrays
        let platforms = [];
        let enemies = [];
        let collectibles = [];
        let colorBerries = [];
        let background = null;

        // Game element classes
        class Platform {
            constructor(x, y, width, height, type = 'normal') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.element = document.createElement('div');
                this.element.className = 'platform';

                if (type === 'vanishing') {
                    this.element.classList.add('vanishing');
                    this.vanishTimer = 0;
                    this.isVisible = true;
                } else if (type === 'moving') {
                    this.element.classList.add('moving');
                    this.startX = x;
                    this.startY = y;
                    this.moveRange = 100;
                    this.moveSpeed = 1;
                    this.moveDirection = 1;
                    this.moveAxis = 'x'; // or 'y'
                } else if (type === 'bouncy') {
                    this.element.classList.add('bouncy');
                } else if (type === 'breakable') {
                    this.element.classList.add('breakable');
                    this.health = 2;
                } else if (type === 'water') {
                    this.element.classList.add('water');
                    this.isWater = true;
                }

                this.element.style.width = `${width}px`;
                this.element.style.height = `${height}px`;
                this.element.style.left = `${x}px`;
                this.element.style.top = `${y}px`;
                document.getElementById('game-canvas').appendChild(this.element);
            }

            update() {
                if (this.type === 'vanishing') {
                    if (player.isOnGround && checkCollision(player, this)) {
                        this.vanishTimer++;
                        if (this.vanishTimer > 60) {
                            this.isVisible = false;
                            this.element.style.opacity = '0';
                            setTimeout(() => {
                                this.isVisible = true;
                                this.element.style.opacity = '1';
                                this.vanishTimer = 0;
                            }, 2000);
                        } else {
                            this.element.style.opacity = 1 - (this.vanishTimer / 60);
                        }
                    }
                } else if (this.type === 'moving') {
                    if (this.moveAxis === 'x') {
                        this.x += this.moveSpeed * this.moveDirection;
                        if (Math.abs(this.x - this.startX) > this.moveRange) {
                            this.moveDirection *= -1;
                        }
                    } else {
                        this.y += this.moveSpeed * this.moveDirection;
                        if (Math.abs(this.y - this.startY) > this.moveRange) {
                            this.moveDirection *= -1;
                        }
                    }
                    this.element.style.left = `${this.x}px`;
                    this.element.style.top = `${this.y}px`;

                    // Move player with platform if standing on it
                    if (player.isOnGround && checkCollision(player, this) && player.y + player.height <= this.y + 5) {
                        if (this.moveAxis === 'x') {
                            player.x += this.moveSpeed * this.moveDirection;
                        } else {
                            player.y += this.moveSpeed * this.moveDirection;
                        }
                    }
                }
            }

            remove() {
                this.element.remove();
            }
        }

        class Enemy {
            constructor(x, y, type = 'normal') {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.type = type;
                this.direction = 1;
                this.speed = 2;
                this.health = type === 'boss' ? 3 : 1;
                this.attackTimer = 0;
                this.element = document.createElement('div');
                this.element.className = 'enemy';

                // Different enemy types
                if (type === 'grouble') {
                    this.element.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=oozing%20blob%20monster%20pixel%20art&resize=40x40&transparency=true') no-repeat";
                    this.element.classList.add('grouble');
                    this.mimicTimer = 0;
                    this.mimicColor = 'red';
                } else if (type === 'ticktock') {
                    this.element.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=wind%20up%20toy%20monster%20pixel%20art&resize=40x40&transparency=true') no-repeat";
                    this.element.classList.add('ticktock');
                    this.speedUpTimer = 0;
                } else if (type === 'boss') {
                    if (game.currentWorld === 1) {
                        this.element.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=giant%20toad%20boss%20pixel%20art&resize=80x80&transparency=true') no-repeat";
                        this.element.classList.add('king-glubble');
                        this.width = 80;
                        this.height = 80;
                        this.swallowTimer = 0;
                    } else if (game.currentWorld === 2) {
                        this.element.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=giant%20slime%20king%20boss%20pixel%20art&resize=80x80&transparency=true') no-repeat";
                        this.element.classList.add('slime-king');
                        this.width = 80;
                        this.height = 80;
                        this.bounceTimer = 0;
                        this.isJumping = true;
                    } else if (game.currentWorld === 3) {
                        this.element.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=mechanical%20clockwork%20boss%20pixel%20art&resize=70x70&transparency=true') no-repeat";
                        this.element.classList.add('gear-lord');
                        this.width = 70;
                        this.height = 70;
                        this.gearAttackTimer = 0;
                    } else if (game.currentWorld === 4) {
                        this.element.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=ghostly%20composer%20pixel%20art&resize=60x60&transparency=true') no-repeat";
                        this.element.classList.add('mad-maestro');
                        this.width = 60;
                        this.height = 60;
                        this.noteAttackTimer = 0;
                    } else if (game.currentWorld === 5) {
                        this.element.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=shadowy%20trickster%20boss%20pixel%20art&resize=70x70&transparency=true') no-repeat";
                        this.element.classList.add('scrangle');
                        this.width = 70;
                        this.height = 70;
                        this.transformTimer = 0;
                        this.currentForm = 0;
                    }
                }

                this.element.style.width = `${this.width}px`;
                this.element.style.height = `${this.height}px`;
                this.element.style.backgroundSize = 'contain';
                this.element.style.left = `${x}px`;
                this.element.style.top = `${y}px`;
                document.getElementById('game-canvas').appendChild(this.element);
            }

            update() {
                if (this.type === 'patrol') {
                    this.x += this.speed * this.direction;
                    let onPlatform = false;
                    let hitWall = false;
                    for (const platform of platforms) {
                        if (this.x + this.width > platform.x && 
                            this.x < platform.x + platform.width &&
                            this.y + this.height === platform.y) {
                            onPlatform = true;
                        }
                        if (this.x <= platform.x + platform.width &&
                            this.x + this.width >= platform.x &&
                            this.y + this.height > platform.y &&
                            this.y < platform.y + platform.height) {
                            hitWall = true;
                        }
                    }
                    if (!onPlatform || hitWall) {
                        this.direction *= -1;
                        this.x += this.speed * this.direction;
                    }
                    this.element.style.transform = `scaleX(${this.direction})`;
                }
                else if (this.type === 'follow') {
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 200) {
                        this.x += (dx / distance) * (this.speed * 0.7);
                        this.y += (dy / distance) * (this.speed * 0.7);
                        this.direction = dx > 0 ? 1 : -1;
                        this.element.style.transform = `scaleX(${this.direction})`;
                    }
                }
                else if (this.type === 'grouble') {
                    // Mimics Wumpus's current color
                    this.mimicTimer++;
                    if (this.mimicTimer > 180) { // Change every 3 seconds
                        this.mimicColor = game.currentColor;
                        this.element.style.filter = `hue-rotate(${this.getHueRotation(this.mimicColor)}deg)`;
                        this.mimicTimer = 0;
                    }

                    // Basic patrol movement
                    this.x += this.speed * this.direction;
                    let shouldTurn = false;
                    for (const platform of platforms) {
                        if ((this.x <= platform.x && this.direction < 0) || 
                            (this.x + this.width >= platform.x + platform.width && this.direction > 0)) {
                            shouldTurn = true;
                        }
                    }
                    if (shouldTurn || this.x <= 0 || this.x + this.width >= 800) {
                        this.direction *= -1;
                    }
                    this.element.style.transform = `scaleX(${this.direction})`;
                }
                else if (this.type === 'ticktock') {
                    // Speed up when near Wumpus
                    const distance = Math.sqrt(
                        Math.pow(player.x - this.x, 2) + 
                        Math.pow(player.y - this.y, 2)
                    );

                    if (distance < 150) {
                        this.speedUpTimer = 120; // 2 seconds of speed boost
                    }

                    if (this.speedUpTimer > 0) {
                        this.speed = 4;
                        this.speedUpTimer--;
                        this.element.style.animation = 'ticktock 0.2s infinite';
                    } else {
                        this.speed = 2;
                        this.element.style.animation = '';
                    }

                    // Basic movement
                    this.x += this.speed * this.direction;
                    if (this.x <= 0 || this.x + this.width >= 800) {
                        this.direction *= -1;
                    }
                    this.element.style.transform = `scaleX(${this.direction})`;
                }
                else if (this.type === 'boss') {
                    // Boss-specific behaviors
                    if (this.element.classList.contains('king-glubble')) {
                        // King Glubble: occasionally tries to swallow parts of level
                        this.swallowTimer++;
                        if (this.swallowTimer > 180) { // Every 3 seconds
                            this.element.classList.add('swallowing');
                            // Temporarily remove a platform
                            const platformsInRange = platforms.filter(p => 
                                Math.abs(p.x - this.x) < 150 && 
                                Math.abs(p.y - this.y) < 150 &&
                                p.type !== 'water'
                            );
                            if (platformsInRange.length > 0) {
                                const platform = platformsInRange[Math.floor(Math.random() * platformsInRange.length)];
                                platform.element.style.opacity = '0';
                                setTimeout(() => {
                                    platform.element.style.opacity = '1';
                                }, 5000);
                            }
                            setTimeout(() => {
                                this.element.classList.remove('swallowing');
                            }, 1000);
                            this.swallowTimer = 0;
                        }

                        // Hop movement
                        if (this.y + this.height < 600 && this.isJumping) {
                            this.y += 2;
                            if (this.y + this.height >= 550) {
                                this.isJumping = false;
                                setTimeout(() => {
                                    this.isJumping = true;
                                    this.y -= 50;
                                    this.x += this.direction * 40;
                                    if (this.x <= 50 || this.x + this.width >= 750) {
                                        this.direction *= -1;
                                    }
                                }, 2000);
                            }
                        }
                    }
                    else if (this.element.classList.contains('slime-king')) {
                        // Slime King: Bounces around and splits into smaller enemies when hit
                        this.bounceTimer++;
                        if (this.bounceTimer > 120) { // Every 2 seconds
                            this.velocityY = -15; // Big bounce
                            this.bounceTimer = 0;
                            
                            // Create slime puddles that damage the player
                            const puddle = document.createElement('div');
                            puddle.className = 'slime-puddle';
                            puddle.style.position = 'absolute';
                            puddle.style.width = '60px';
                            puddle.style.height = '10px';
                            puddle.style.backgroundColor = '#8bc34a';
                            puddle.style.borderRadius = '50%';
                            puddle.style.opacity = '0.7';
                            puddle.style.left = `${this.x + this.width/2 - 30}px`;
                            puddle.style.top = `${this.y + this.height}px`;
                            puddle.style.zIndex = '1';
                            gameCanvas.appendChild(puddle);
                            
                            // Puddle collision detection
                            const puddleRect = {
                                x: this.x + this.width/2 - 30,
                                y: this.y + this.height,
                                width: 60,
                                height: 10
                            };
                            
                            const puddleInterval = setInterval(() => {
                                if (checkCollision(player, puddleRect) && 
                                    game.currentColor !== 'blue' && 
                                    !keys.special) {
                                    takeDamage();
                                    clearInterval(puddleInterval);
                                    puddle.remove();
                                }
                            }, 100);
                            
                            setTimeout(() => {
                                clearInterval(puddleInterval);
                                puddle.remove();
                            }, 3000);
                        }
                        
                        // Apply gravity and bounce physics
                        this.velocityY = this.velocityY || 0;
                        this.velocityY += 0.5; // gravity
                        this.y += this.velocityY;
                        
                        // Bounce off floor
                        if (this.y + this.height > 550) {
                            this.y = 550 - this.height;
                            this.velocityY = -10; // Bounce back up
                            
                            // Move sideways after bounce
                            this.x += this.direction * 50;
                            if (this.x < 50 || this.x + this.width > 750) {
                                this.direction *= -1;
                            }
                        }
                        
                        this.element.style.transform = `scaleX(${this.direction})`;
                    }
                    else if (this.element.classList.contains('gear-lord')) {
                        // Gear Lord: Shoots gears and changes the platform movement patterns
                        this.gearAttackTimer++;
                        if (this.gearAttackTimer > 150) { // Every 2.5 seconds
                            // Create gear projectiles
                            for (let i = 0; i < 4; i++) {
                                const gear = document.createElement('div');
                                gear.className = 'gear-projectile';
                                gear.style.position = 'absolute';
                                gear.style.width = '30px';
                                gear.style.height = '30px';
                                gear.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=gear%20cog%20pixel%20art&resize=30x30&transparency=true') no-repeat";
                                gear.style.backgroundSize = 'contain';
                                gear.style.left = `${this.x + this.width/2 - 15}px`;
                                gear.style.top = `${this.y + this.height/2 - 15}px`;
                                gear.style.animation = 'spin 1s linear infinite';
                                gameCanvas.appendChild(gear);
                                
                                // Animate the gear in different directions
                                const angle = i * 90;
                                const rad = angle * Math.PI / 180;
                                const vx = Math.cos(rad) * 3;
                                const vy = Math.sin(rad) * 3;
                                
                                const gearInterval = setInterval(() => {
                                    const left = parseFloat(gear.style.left);
                                    const top = parseFloat(gear.style.top);
                                    gear.style.left = `${left + vx}px`;
                                    gear.style.top = `${top + vy}px`;
                                    
                                    // Check collision with player
                                    const gearRect = {
                                        x: left,
                                        y: top,
                                        width: 30,
                                        height: 30
                                    };
                                    
                                    if (checkCollision(player, gearRect)) {
                                        if (game.currentColor === 'red' && keys.special) {
                                            // Red form can deflect with charge
                                            clearInterval(gearInterval);
                                            gear.remove();
                                        } else {
                                            takeDamage();
                                            clearInterval(gearInterval);
                                            gear.remove();
                                        }
                                    }
                                    
                                    // Remove gear if it goes off screen
                                    if (left < 0 || left > 800 || top < 0 || top > 600) {
                                        clearInterval(gearInterval);
                                        gear.remove();
                                    }
                                }, 16);
                            }
                            
                            // Change platform movement patterns
                            for (const platform of platforms) {
                                if (platform.type === 'moving') {
                                    platform.moveDirection *= -1;
                                    platform.moveSpeed = 1 + Math.random() * 3;
                                }
                            }
                            
                            this.gearAttackTimer = 0;
                        }
                        
                        // Circular movement pattern
                        const centerX = 400;
                        const centerY = 300;
                        const radius = 150;
                        const speed = 0.01;
                        this.angle = this.angle || 0;
                        this.angle += speed;
                        this.x = centerX + Math.cos(this.angle) * radius - this.width/2;
                        this.y = centerY + Math.sin(this.angle) * radius - this.height/2;
                    }
                    else if (this.element.classList.contains('mad-maestro')) {
                        // Mad Maestro: attack with musical notes
                        this.noteAttackTimer++;
                        if (this.noteAttackTimer > 120) { // Every 2 seconds
                            // Create musical note projectiles
                            for (let i = 0; i < 3; i++) {
                                const note = document.createElement('div');
                                note.className = 'musical-note';
                                note.style.position = 'absolute';
                                note.style.width = '20px';
                                note.style.height = '30px';
                                note.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=musical%20note%20pixel%20art&resize=20x30&transparency=true') no-repeat";
                                note.style.backgroundSize = 'contain';
                                note.style.left = `${this.x + this.width/2}px`;
                                note.style.top = `${this.y + this.height/2}px`;
                                gameCanvas.appendChild(note);

                                // Animate the note
                                const angle = (i * 45) - 45;
                                const rad = angle * Math.PI / 180;
                                const vx = Math.cos(rad) * 3;
                                const vy = Math.sin(rad) * 3;

                                const noteInterval = setInterval(() => {
                                    const left = parseFloat(note.style.left);
                                    const top = parseFloat(note.style.top);
                                    note.style.left = `${left + vx}px`;
                                    note.style.top = `${top + vy}px`;

                                    // Check collision with player
                                    const noteRect = {
                                        x: left,
                                        y: top,
                                        width: 20,
                                        height: 30
                                    };

                                    if (checkCollision(player, noteRect)) {
                                        if (game.currentColor === 'yellow' && keys.special) {
                                            // Yellow form can deflect
                                            clearInterval(noteInterval);
                                            note.remove();
                                        } else {
                                            takeDamage();
                                            clearInterval(noteInterval);
                                            note.remove();
                                        }
                                    }

                                    // Remove note if it goes off screen
                                    if (left < 0 || left > 800 || top < 0 || top > 600) {
                                        clearInterval(noteInterval);
                                        note.remove();
                                    }
                                }, 16);
                            }
                            this.noteAttackTimer = 0;
                        }

                        // Floating movement
                        this.x += Math.sin(Date.now() / 500) * 2;
                        this.y += Math.cos(Date.now() / 700) * 1;
                    }
                    else if (this.element.classList.contains('scrangle')) {
                        // Scrangle: changes forms and alters physics
                        this.transformTimer++;
                        if (this.transformTimer > 300) { // Every 5 seconds
                            this.currentForm = (this.currentForm + 1) % 4;
                            this.element.style.filter = `hue-rotate(${this.currentForm * 90}deg)`;

                            // Change game physics based on form
                            switch(this.currentForm) {
                                case 0:
                                    game.gravity = 0.5;
                                    break;
                                case 1:
                                    game.gravity = 0.3;
                                    break;
                                case 2:
                                    game.gravity = 0.7;
                                    break;
                                case 3:
                                    game.gravity = -0.3; // Reverse gravity!
                                    break;
                            }

                            this.transformTimer = 0;
                            this.element.classList.add('transforming');
                            setTimeout(() => {
                                this.element.classList.remove('transforming');
                            }, 1000);
                        }

                        // Teleport movement
                        this.attackTimer++;
                        if (this.attackTimer > 180) {
                            this.x = 100 + Math.random() * 600;
                            this.y = 100 + Math.random() * 400;
                            this.attackTimer = 0;
                        }
                    }
                }

                this.element.style.left = `${this.x}px`;
                this.element.style.top = `${this.y}px`;
            }

            getHueRotation(color) {
                switch(color) {
                    case 'red': return 0;
                    case 'blue': return 240;
                    case 'yellow': return 60;
                    case 'green': return 120;
                    default: return 0;
                }
            }

            takeDamage() {
                this.health--;
                this.element.style.opacity = '0.5';
                setTimeout(() => {
                    this.element.style.opacity = '1';
                }, 200);

                if (this.health <= 0) {
                    this.remove();
                    enemies = enemies.filter(e => e !== this);
                    if (this.type === 'boss') {
                        // Special effects for boss defeat
                        const explosion = document.createElement('div');
                        explosion.className = 'explosion';
                        explosion.style.position = 'absolute';
                        explosion.style.left = `${this.x}px`;
                        explosion.style.top = `${this.y}px`;
                        explosion.style.width = `${this.width * 1.5}px`;
                        explosion.style.height = `${this.height * 1.5}px`;
                        explosion.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=pixel%20art%20explosion&resize=100x100&transparency=true') no-repeat";
                        explosion.style.backgroundSize = 'contain';
                        explosion.style.zIndex = '10';
                        gameCanvas.appendChild(explosion);

                        setTimeout(() => {
                            explosion.remove();
                            levelComplete();
                        }, 1000);
                    }
                }
            }

            remove() {
                this.element.remove();
            }
        }

        class Collectible {
            constructor(x, y, type = 'spark') {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.type = type;
                this.collected = false;
                this.element = document.createElement('div');

                if (type === 'spark') {
                    this.element.className = 'collectible spark';
                    this.element.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=glowing%20star%20spark%20pixel%20art&resize=30x30&transparency=true') no-repeat";
                } else if (type === 'powerup') {
                    this.element.className = 'collectible powerup';
                    this.powerupType = ['zippyZapperHat', 'puffPodBoots', 'echoOrb'][Math.floor(Math.random() * 3)];

                    if (this.powerupType === 'zippyZapperHat') {
                        this.element.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=wizard%20hat%20pixel%20art&resize=30x30&transparency=true') no-repeat";
                    } else if (this.powerupType === 'puffPodBoots') {
                        this.element.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=bouncy%20boots%20pixel%20art&resize=30x30&transparency=true') no-repeat";
                    } else if (this.powerupType === 'echoOrb') {
                        this.element.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=glowing%20orb%20pixel%20art&resize=30x30&transparency=true') no-repeat";
                    }
                } else if (type === 'secretDoor') {
                    this.element.className = 'collectible secret-door';
                    this.element.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=mysterious%20door%20pixel%20art&resize=40x60&transparency=true') no-repeat";
                    this.width = 40;
                    this.height = 60;
                    this.element.style.width = `${this.width}px`;
                    this.element.style.height = `${this.height}px`;
                }

                this.element.style.backgroundSize = 'contain';
                this.element.style.left = `${x}px`;
                this.element.style.top = `${y}px`;
                document.getElementById('game-canvas').appendChild(this.element);
            }

            collect() {
                if (!this.collected) {
                    this.collected = true;
                    this.element.style.display = 'none';

                    if (this.type === 'spark') {
                        game.sparksCollected++;
                        game.totalSparksInGame++;
                        updateUI();
                        playSoundEffect('collect');
                    } else if (this.type === 'powerup') {
                        game.unlockedPowerups[this.powerupType] = true;

                        if (this.powerupType === 'zippyZapperHat') {
                            showDialog("You found the Zippy Zapper Hat! Press Z to fire energy bursts at enemies!");
                        } else if (this.powerupType === 'puffPodBoots') {
                            showDialog("You found the Puff Pod Boots! You can now perform a triple jump for a short time!");
                        } else if (this.powerupType === 'echoOrb') {
                            showDialog("You found the Echo Orb! You can now mimic certain enemy attacks!");
                        }

                        playSoundEffect('powerup');
                    } else if (this.type === 'secretDoor') {
                        game.secretDoorsFound++;
                        showDialog("You found a secret door! Let's see what's inside...");
                        setTimeout(() => {
                            loadBonusRoom();
                        }, 1000);
                    }
                }
            }

            remove() {
                this.element.remove();
            }
        }

        class ColorBerry {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.width = 25;
                this.height = 25;
                this.color = color;
                this.collected = false;
                this.element = document.createElement('div');
                this.element.className = `color-berry ${color}`;
                this.element.style.left = `${x}px`;
                this.element.style.top = `${y}px`;
                document.getElementById('game-canvas').appendChild(this.element);
            }

            collect() {
                if (!this.collected) {
                    this.collected = true;
                    this.element.style.display = 'none';
                    game.unlockedColors[this.color] = true;
                    changeWumpusColor(this.color);
                    playSoundEffect('powerup');

                    if (this.color === 'blue') {
                        showDialog("You found a Blue Berry! Now you can phase through certain objects and walk on water. Press 2 to activate Blue Form.");
                    } else if (this.color === 'yellow') {
                        showDialog("You found a Yellow Berry! Now you can bounce higher and deflect projectiles. Press 3 to activate Yellow Form.");
                    } else if (this.color === 'green') {
                        showDialog("You found a Green Berry! Now you can climb walls and stick to ceilings. Press 4 to activate Green Form.");
                    }
                }
            }

            remove() {
                this.element.remove();
            }
        }

        // DOM elements
        const gameCanvas = document.getElementById('game-canvas');
        const menuScreen = document.getElementById('menu-screen');
        const startButton = document.getElementById('start-button');
        const controlsButton = document.getElementById('controls-button');
        const controlsScreen = document.getElementById('controls-screen');
        const backButton = document.getElementById('back-button');
        const gameOverScreen = document.getElementById('game-over');
        const retryButton = document.getElementById('retry-button');
        const menuButton1 = document.getElementById('menu-button-1');
        const levelCompleteScreen = document.getElementById('level-complete');
        const levelStats = document.getElementById('level-stats');
        const nextLevelButton = document.getElementById('next-level-button');
        const menuButton2 = document.getElementById('menu-button-2');
        const pauseScreen = document.getElementById('pause-screen');
        const resumeButton = document.getElementById('resume-button');
        const menuButton3 = document.getElementById('menu-button-3');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingBar = document.getElementById('loading-bar');
        const dialogBox = document.getElementById('dialog-box');
        const dialogText = document.getElementById('dialog-text');
        const sparkCount = document.getElementById('spark-count');
        const levelIndicator = document.getElementById('level-indicator');
        const healthBar = document.getElementById('health-bar');
        const colorPowers = document.querySelectorAll('.color-power');

        // Audio elements
        const sounds = {
            jump: null,
            collect: null,
            hit: null,
            powerup: null,
            levelComplete: null,
            gameOver: null,
            colorChange: null,
            backgroundMusic: null
        };

        // Keyboard state
        const keys = {
            left: false,
            right: false,
            jump: false,
            special: false,
            color1: false,
            color2: false,
            color3: false,
            color4: false,
            pause: false
        };

        // Initialize game
        function init() {
            startButton.addEventListener('click', startGame);
            controlsButton.addEventListener('click', showControls);
            backButton.addEventListener('click', hideControls);
            retryButton.addEventListener('click', restartLevel);
            menuButton1.addEventListener('click', returnToMenu);
            nextLevelButton.addEventListener('click', loadNextLevel);
            menuButton2.addEventListener('click', returnToMenu);
            resumeButton.addEventListener('click', resumeGame);
            menuButton3.addEventListener('click', returnToMenu);

            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            preloadSounds();
            simulateLoading();
        }

        function preloadSounds() {
            sounds.jump = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=cartoon%20jump%20sound&duration=0.5&ext=.mp3');
            sounds.collect = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=collect%20sparkle%20item%20sound&duration=0.5&ext=.mp3');
            sounds.hit = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=cartoon%20hit%20impact&duration=0.5&ext=.mp3');
            sounds.powerup = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=power%20up%20video%20game%20sound&duration=0.5&ext=.mp3');
            sounds.levelComplete = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=level%20complete%20victory%20fanfare&duration=1&ext=.mp3');
            sounds.gameOver = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=game%20over%20sad%20tune&duration=1&ext=.mp3');
            sounds.colorChange = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=magical%20transformation%20sound&duration=0.5&ext=.mp3');
            sounds.backgroundMusic = new Audio('https://sounds.fuzzycode.dev/music?prompt=upbeat%208bit%20video%20game%20adventure%20music&duration=30&ext=.mp3');
            sounds.backgroundMusic.loop = true;
            sounds.backgroundMusic.volume = 0.5;
        }

        function playSoundEffect(soundName) {
            if (sounds[soundName]) {
                const sound = sounds[soundName].cloneNode();
                sound.play();
            }
        }

        function simulateLoading() {
            let progress = 0;
            const interval = setInterval(() => {
                progress += 5;
                loadingBar.style.width = `${progress}%`;
                if (progress >= 100) {
                    clearInterval(interval);
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 500);
                }
            }, 150);
        }

        function startGame() {
            menuScreen.style.display = 'none';
            resetGame();
            loadLevel(game.currentWorld, game.currentLevel);
            game.isRunning = true;
            gameLoop();
            sounds.backgroundMusic.play();
        }

        function resetGame() {
            game.currentWorld = 1;
            game.currentLevel = 1;
            game.health = 3;
            game.sparksCollected = 0;
            game.currentColor = "red";
            game.unlockedColors = {
                red: true,
                blue: false,
                yellow: false,
                green: false
            };
            // Reset jump force to red mode's default
            game.jumpForce = modeSettings.red.jumpForce;
            player.speed = modeSettings.red.speed;
            updateUI();
        }

        function showControls() {
            controlsScreen.style.display = 'flex';
        }

        function hideControls() {
            controlsScreen.style.display = 'none';
        }

        function loadLevel(world, level) {
            clearLevel();
            if (!player.element) {
                player.element = document.createElement('div');
                player.element.id = 'wumpus-sprite';
                gameCanvas.appendChild(player.element);
            }
            player.x = 100;
            player.y = 300;
            player.velocityX = 0;
            player.velocityY = 0;
            player.isJumping = false;
            player.direction = 1;

            background = document.createElement('div');
            background.className = 'background';
            switch(world) {
                case 1:
                    background.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=lush%20storybook%20forest%20pixel%20art&resize=800x600') no-repeat center center";
                    break;
                case 2:
                    background.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=bouncy%20goo%20covered%20jungle%20pixel%20art&resize=800x600') no-repeat center center";
                    break;
                case 3:
                    background.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=mechanical%20funhouse%20with%20gears%20pixel%20art&resize=800x600') no-repeat center center";
                    break;
                case 4:
                    background.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=musical%20landscape%20with%20sound%20waves%20pixel%20art&resize=800x600') no-repeat center center";
                    break;
                case 5:
                    background.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=warped%20dreamlike%20void%20with%20shifting%20reality%20pixel%20art&resize=800x600') no-repeat center center";
                    break;
            }
            background.style.backgroundSize = 'cover';
            gameCanvas.appendChild(background);

            if (world === 1) {
                if (level === 1) {
                    createPlatform(0, 550, 800, 50);
                    createPlatform(300, 450, 100, 20);
                    createPlatform(500, 400, 120, 20);
                    createPlatform(650, 300, 100, 20);

                    createEnemy(400, 510, 'patrol');

                    createCollectible(350, 420);
                    createCollectible(550, 370);
                    createCollectible(700, 270);
                    createCollectible(100, 520);
                    createCollectible(750, 520);

                    createColorBerry(600, 370, 'blue');

                    game.dialogQueue = [
                        "Welcome to Luminara, Wumpus! The Flow of Wonder has been shattered by the sinister Scrangle.",
                        "It's up to you to restore magic to our world! Use the ARROW KEYS or A/D to move and SPACE to jump.",
                        "Collect the glowing Imagination Sparks to restore the Flow of Wonder. Good luck on your adventure!"
                    ];

                    showNextDialog();
                }
                else if (level === 2) {
                    createPlatform(0, 550, 300, 50);
                    createPlatform(500, 550, 300, 50);

                    const water = document.createElement('div');
                    water.style.position = 'absolute';
                    water.style.left = '300px';
                    water.style.top = '550px';
                    water.style.width = '200px';
                    water.style.height = '50px';
                    water.style.backgroundColor = '#4a90e2';
                    water.style.opacity = '0.7';
                    water.isWater = true;
                    water.x = 300;
                    water.y = 550;
                    water.width = 200;
                    water.height = 50;
                    gameCanvas.appendChild(water);
                    platforms.push(water);

                    createEnemy(200, 410, 'patrol');
                    createEnemy(600, 510, 'follow');

                    createCollectible(180, 420);
                    createCollectible(400, 370);
                    createCollectible(580, 420);
                    createCollectible(700, 520);
                    createCollectible(50, 520);

                    showDialog("Use your Blue Form to cross the water! Press 2 to change to Blue Form if you've collected the Blue Berry.");
                }
                else if (level === 3) {
                    createPlatform(0, 550, 200, 50);
                    createPlatform(300, 550, 200, 50);
                    createPlatform(600, 550, 200, 50);
                    createPlatform(250, 450, 100, 20);
                    createPlatform(450, 400, 100, 20);
                    createEnemy(320, 510, 'patrol');
                    createCollectible(180, 420);
                    createCollectible(260, 420);
                    createCollectible(500, 370);
                    createCollectible(650, 520);
                    createCollectible(700, 520);
                    createColorBerry(480, 370, 'yellow');
                    
                    // Boss for World 1
                    createEnemy(400, 300, 'boss');
                    
                    showDialog("Level 1-3: Cross the fragmented trail and be wary of lurking dangers!");
                }
            }
            else if (world === 2) { // Gelatinous Jungle
                if (level === 1) {
                    // Create bouncy platforms characteristic of the Gelatinous Jungle
                    createPlatform(0, 550, 800, 50);
                    const bouncy1 = new Platform(200, 450, 100, 20, 'bouncy');
                    platforms.push(bouncy1);
                    const bouncy2 = new Platform(400, 400, 100, 20, 'bouncy');
                    platforms.push(bouncy2);
                    const bouncy3 = new Platform(600, 350, 100, 20, 'bouncy');
                    platforms.push(bouncy3);
                    
                    // Moving platforms that wobble
                    const moving1 = new Platform(300, 300, 80, 15, 'moving');
                    moving1.moveAxis = 'y';
                    moving1.moveRange = 50;
                    platforms.push(moving1);
                    
                    // Enemies specific to this world
                    createEnemy(350, 250, 'grouble');
                    createEnemy(550, 510, 'patrol');
                    
                    // Collectibles
                    createCollectible(250, 420);
                    createCollectible(450, 370);
                    createCollectible(650, 320);
                    createCollectible(350, 200);
                    createCollectible(100, 520);
                    
                    showDialog("Welcome to the Gelatinous Jungle! The platforms here are bouncy and unstable. Use your jumping skills wisely!");
                }
                else if (level === 2) {
                    // More complex layout with gooey obstacles
                    createPlatform(0, 550, 300, 50);
                    createPlatform(400, 550, 400, 50);
                    
                    // Goo pool
                    const gooPool = document.createElement('div');
                    gooPool.style.position = 'absolute';
                    gooPool.style.left = '300px';
                    gooPool.style.top = '550px';
                    gooPool.style.width = '100px';
                    gooPool.style.height = '50px';
                    gooPool.style.backgroundColor = '#8bc34a';
                    gooPool.style.opacity = '0.8';
                    gooPool.isWater = true; // Reuse water mechanics for goo
                    gooPool.x = 300;
                    gooPool.y = 550;
                    gooPool.width = 100;
                    gooPool.height = 50;
                    gameCanvas.appendChild(gooPool);
                    platforms.push(gooPool);
                    
                    // Vanishing platforms
                    const vanishing1 = new Platform(150, 450, 80, 15, 'vanishing');
                    platforms.push(vanishing1);
                    const vanishing2 = new Platform(300, 400, 80, 15, 'vanishing');
                    platforms.push(vanishing2);
                    const vanishing3 = new Platform(450, 350, 80, 15, 'vanishing');
                    platforms.push(vanishing3);
                    const vanishing4 = new Platform(600, 300, 80, 15, 'vanishing');
                    platforms.push(vanishing4);
                    
                    // Enemies
                    createEnemy(200, 410, 'grouble');
                    createEnemy(500, 310, 'ticktock');
                    
                    // Collectibles
                    createCollectible(150, 420);
                    createCollectible(300, 370);
                    createCollectible(450, 320);
                    createCollectible(600, 270);
                    createCollectible(700, 520);
                    
                    // Color berry
                    createColorBerry(200, 520, 'green');
                    
                    showDialog("The platforms here disappear when you stand on them too long! Use the Green Berry to climb walls if you find it.");
                }
                else if (level === 3) {
                    // Boss level for Gelatinous Jungle
                    createPlatform(0, 550, 800, 50);
                    
                    // Bouncy platforms for the boss fight
                    const bouncy1 = new Platform(150, 450, 80, 15, 'bouncy');
                    platforms.push(bouncy1);
                    const bouncy2 = new Platform(650, 450, 80, 15, 'bouncy');
                    platforms.push(bouncy2);
                    const bouncy3 = new Platform(400, 400, 100, 15, 'bouncy');
                    platforms.push(bouncy3);
                    
                    // Moving goo platforms
                    const moving1 = new Platform(250, 350, 60, 10, 'moving');
                    moving1.moveAxis = 'x';
                    moving1.moveRange = 100;
                    platforms.push(moving1);
                    const moving2 = new Platform(550, 350, 60, 10, 'moving');
                    moving2.moveAxis = 'x';
                    moving2.moveRange = 100;
                    moving2.moveDirection = -1;
                    platforms.push(moving2);
                    
                    // Collectibles
                    createCollectible(150, 420);
                    createCollectible(650, 420);
                    createCollectible(400, 370);
                    createCollectible(250, 320);
                    createCollectible(550, 320);
                    
                    // Boss - a bigger Grouble
                    createEnemy(400, 200, 'boss');
                    
                    showDialog("The King Glubble rules this slimy domain! Defeat it to restore the Flow of Wonder to the Gelatinous Jungle!");
                }
            }
            else if (world === 3) { // Clockwork Carnival
                if (level === 1) {
                    // Mechanical, gear-like platforms
                    createPlatform(0, 550, 250, 50);
                    createPlatform(350, 550, 250, 50);
                    createPlatform(700, 550, 100, 50);
                    
                    // Moving platforms that represent gears and machinery
                    const gear1 = new Platform(250, 550, 100, 20, 'moving');
                    gear1.moveAxis = 'y';
                    gear1.moveRange = 100;
                    gear1.moveSpeed = 2;
                    platforms.push(gear1);
                    
                    const gear2 = new Platform(600, 550, 100, 20, 'moving');
                    gear2.moveAxis = 'y';
                    gear2.moveRange = 100;
                    gear2.moveSpeed = 2;
                    gear2.moveDirection = -1;
                    platforms.push(gear2);
                    
                    // Rotating platforms
                    const gear3 = new Platform(200, 400, 80, 15, 'moving');
                    gear3.moveAxis = 'x';
                    gear3.moveRange = 100;
                    platforms.push(gear3);
                    
                    const gear4 = new Platform(500, 350, 80, 15, 'moving');
                    gear4.moveAxis = 'x';
                    gear4.moveRange = 100;
                    gear4.moveDirection = -1;
                    platforms.push(gear4);
                    
                    // Tick-Tock enemies fitting the mechanical theme
                    createEnemy(300, 510, 'ticktock');
                    createEnemy(450, 510, 'ticktock');
                    
                    // Collectibles
                    createCollectible(100, 520);
                    createCollectible(400, 520);
                    createCollectible(750, 520);
                    createCollectible(200, 370);
                    createCollectible(500, 320);
                    
                    showDialog("Welcome to the Clockwork Carnival! Mind the moving platforms and watch out for the Tick-Tock Terrors!");
                }
                else if (level === 2) {
                    // More complex clockwork level with vanishing platforms
                    createPlatform(0, 550, 200, 50);
                    createPlatform(300, 550, 200, 50);
                    createPlatform(600, 550, 200, 50);
                    
                    // Breakable platforms
                    const breakable1 = new Platform(200, 550, 100, 50, 'breakable');
                    platforms.push(breakable1);
                    const breakable2 = new Platform(500, 550, 100, 50, 'breakable');
                    platforms.push(breakable2);
                    
                    // Moving and vanishing platforms
                    const platform1 = new Platform(150, 450, 70, 15, 'vanishing');
                    platforms.push(platform1);
                    const platform2 = new Platform(300, 400, 70, 15, 'vanishing');
                    platforms.push(platform2);
                    const platform3 = new Platform(450, 350, 70, 15, 'vanishing');
                    platforms.push(platform3);
                    const platform4 = new Platform(600, 300, 70, 15, 'vanishing');
                    platforms.push(platform4);
                    
                    // Moving platform
                    const gear1 = new Platform(350, 250, 100, 15, 'moving');
                    gear1.moveAxis = 'x';
                    gear1.moveRange = 200;
                    gear1.moveSpeed = 3;
                    platforms.push(gear1);
                    
                    // Enemies
                    createEnemy(200, 510, 'ticktock');
                    createEnemy(500, 510, 'ticktock');
                    createEnemy(350, 220, 'follow');
                    
                    // Collectibles
                    createCollectible(150, 420);
                    createCollectible(300, 370);
                    createCollectible(450, 320);
                    createCollectible(600, 270);
                    createCollectible(400, 220);
                    
                    // Secret door
                    const secretDoor = new Collectible(700, 490, 'secretDoor');
                    collectibles.push(secretDoor);
                    
                    showDialog("The clockwork gets more complex! Some platforms break when you charge into them with Red Form. Find the secret door!");
                }
                else if (level === 3) {
                    // Boss level for Clockwork Carnival
                    createPlatform(0, 550, 800, 50);
                    
                    // Moving platforms in a circular pattern
                    const positions = [
                        {x: 200, y: 450},
                        {x: 300, y: 400},
                        {x: 400, y: 350},
                        {x: 500, y: 400},
                        {x: 600, y: 450}
                    ];
                    
                    for (let i = 0; i < positions.length; i++) {
                        const gear = new Platform(positions[i].x, positions[i].y, 80, 15, 'moving');
                        gear.startX = positions[i].x;
                        gear.startY = positions[i].y;
                        gear.moveAxis = i % 2 === 0 ? 'x' : 'y';
                        gear.moveRange = 50;
                        gear.moveSpeed = 2;
                        gear.moveDirection = i % 2 === 0 ? 1 : -1;
                        platforms.push(gear);
                    }
                    
                    // Central platform for the boss
                    createPlatform(350, 250, 100, 20);
                    
                    // Collectibles
                    createCollectible(200, 420);
                    createCollectible(300, 370);
                    createCollectible(500, 370);
                    createCollectible(600, 420);
                    createCollectible(400, 220);
                    
                    // Boss - a mechanical monster
                    const boss = new Enemy(400, 200, 'boss');
                    boss.element.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=mechanical%20monster%20boss%20pixel%20art&resize=60x60&transparency=true') no-repeat";
                    boss.element.style.backgroundSize = 'contain';
                    enemies.push(boss);
                    
                    showDialog("The gears are going haywire! Defeat the mechanical monstrosity to restore order to the Clockwork Carnival!");
                }
            }
            else if (world === 4) { // Melodica Mountains
                if (level === 1) {
                    // Musical platforms that look like sound waves
                    createPlatform(0, 550, 800, 50);
                    
                    // Sound wave platforms
                    const wave1 = new Platform(150, 450, 100, 10);
                    wave1.element.style.backgroundColor = '#9c27b0';
                    wave1.element.style.borderRadius = '10px';
                    platforms.push(wave1);
                    
                    const wave2 = new Platform(350, 400, 100, 10);
                    wave2.element.style.backgroundColor = '#9c27b0';
                    wave2.element.style.borderRadius = '10px';
                    platforms.push(wave2);
                    
                    const wave3 = new Platform(550, 350, 100, 10);
                    wave3.element.style.backgroundColor = '#9c27b0';
                    wave3.element.style.borderRadius = '10px';
                    platforms.push(wave3);
                    
                    // Moving sound wave platforms
                    const wave4 = new Platform(250, 300, 80, 10, 'moving');
                    wave4.element.style.backgroundColor = '#e91e63';
                    wave4.element.style.borderRadius = '10px';
                    wave4.moveAxis = 'y';
                    wave4.moveRange = 50;
                    platforms.push(wave4);
                    
                    const wave5 = new Platform(450, 250, 80, 10, 'moving');
                    wave5.element.style.backgroundColor = '#e91e63';
                    wave5.element.style.borderRadius = '10px';
                    wave5.moveAxis = 'y';
                    wave5.moveRange = 50;
                    wave5.moveDirection = -1;
                    platforms.push(wave5);
                    
                    // Musical note enemies
                    createEnemy(200, 410, 'follow');
                    createEnemy(400, 360, 'follow');
                    createEnemy(600, 310, 'follow');
                    
                    // Collectibles
                    createCollectible(150, 420);
                    createCollectible(350, 370);
                    createCollectible(550, 320);
                    createCollectible(250, 270);
                    createCollectible(450, 220);
                    
                    showDialog("Welcome to the Melodica Mountains! The platforms here move to the rhythm of the music. Time your jumps carefully!");
                }
                else if (level === 2) {
                    // More musical themed level with rhythm-based challenges
                    createPlatform(0, 550, 200, 50);
                    createPlatform(300, 550, 200, 50);
                    createPlatform(600, 550, 200, 50);
                    
                    // Vanishing platforms that appear and disappear to the beat
                    for (let i = 0; i < 5; i++) {
                        const beatPlatform = new Platform(100 + i * 150, 450 - i * 30, 70, 10, 'vanishing');
                        beatPlatform.element.style.backgroundColor = '#3f51b5';
                        beatPlatform.element.style.borderRadius = '10px';
                        beatPlatform.vanishTimer = i * 20; // Stagger the timing
                        platforms.push(beatPlatform);
                    }
                    
                    // Moving platforms in melodic patterns
                    const melody1 = new Platform(200, 300, 80, 10, 'moving');
                    melody1.element.style.backgroundColor = '#2196f3';
                    melody1.element.style.borderRadius = '10px';
                    melody1.moveAxis = 'x';
                    melody1.moveRange = 150;
                    melody1.moveSpeed = 3;
                    platforms.push(melody1);
                    
                    const melody2 = new Platform(500, 250, 80, 10, 'moving');
                    melody2.element.style.backgroundColor = '#2196f3';
                    melody2.element.style.borderRadius = '10px';
                    melody2.moveAxis = 'x';
                    melody2.moveRange = 150;
                    melody2.moveSpeed = 3;
                    melody2.moveDirection = -1;
                    platforms.push(melody2);
                    
                    // Musical enemies
                    createEnemy(150, 510, 'follow');
                    createEnemy(450, 510, 'follow');
                    createEnemy(350, 200, 'ticktock');
                    
                    // Collectibles
                    createCollectible(100, 420);
                    createCollectible(250, 390);
                    createCollectible(400, 360);
                    createCollectible(550, 330);
                    createCollectible(700, 520);
                    
                    // Powerup
                    const powerup = new Collectible(350, 270, 'powerup');
                    collectibles.push(powerup);
                    
                    showDialog("The rhythm gets more complex! Platforms appear and disappear to the beat. Find the Echo Orb to mimic enemy attacks!");
                }
                else if (level === 3) {
                    // Boss level for Melodica Mountains
                    createPlatform(0, 550, 800, 50);
                    
                    // Musical staff platforms
                    for (let i = 0; i < 5; i++) {
                        const staffLine = new Platform(100, 450 - i * 40, 600, 5);
                        staffLine.element.style.backgroundColor = '#9e9e9e';
                        platforms.push(staffLine);
                        
                        // Note platforms on each line
                        for (let j = 0; j < 4; j++) {
                            const note = new Platform(150 + j * 150, 440 - i * 40, 30, 30);
                            note.element.style.backgroundColor = '#f44336';
                            note.element.style.borderRadius = '50%';
                            platforms.push(note);
                        }
                    }
                    
                    // Moving platform for the boss
                    const conductorPlatform = new Platform(350, 200, 100, 20, 'moving');
                    conductorPlatform.moveAxis = 'x';
                    conductorPlatform.moveRange = 200;
                    conductorPlatform.moveSpeed = 2;
                    platforms.push(conductorPlatform);
                    
                    // Collectibles
                    createCollectible(150, 520);
                    createCollectible(300, 520);
                    createCollectible(500, 520);
                    createCollectible(650, 520);
                    createCollectible(400, 170);
                    
                    // Boss - Mad Maestro
                    createEnemy(400, 150, 'boss');
                    
                    showDialog("The Mad Maestro conducts chaos in the mountains! Dodge his musical attacks and restore harmony to the Melodica Mountains!");
                }
            }
            else if (world === 5) { // Scrangle's Nightmare Nexus
                if (level === 1) {
                    // Surreal, shifting platforms in a void-like environment
                    createPlatform(0, 550, 800, 50);
                    
                    // Floating, unstable platforms
                    for (let i = 0; i < 8; i++) {
                        const floatingPlatform = new Platform(100 + i * 80, 450 - (i % 3) * 50, 60, 15, i % 2 === 0 ? 'vanishing' : 'moving');
                        if (i % 2 === 1) {
                            floatingPlatform.moveAxis = 'y';
                            floatingPlatform.moveRange = 50 + (i * 5);
                            floatingPlatform.moveSpeed = 1 + (i * 0.2);
                        }
                        floatingPlatform.element.style.backgroundColor = '#673ab7';
                        floatingPlatform.element.style.boxShadow = '0 0 10px #9c27b0';
                        platforms.push(floatingPlatform);
                    }
                    
                    // Reality-warped enemies
                    createEnemy(200, 510, 'grouble');
                    createEnemy(400, 510, 'ticktock');
                    createEnemy(600, 510, 'follow');
                    
                    // Collectibles
                    createCollectible(150, 400);
                    createCollectible(300, 350);
                    createCollectible(450, 300);
                    createCollectible(600, 350);
                    createCollectible(750, 400);
                    
                    showDialog("Welcome to Scrangle's Nightmare Nexus! Reality shifts and warps here. Use all your forms and abilities to navigate this chaotic realm.");
                }
                else if (level === 2) {
                    // More chaotic level with physics-defying elements
                    
                    // Upside-down platforms on the ceiling
                    createPlatform(0, 0, 800, 50);
                    createPlatform(0, 550, 800, 50);
                    
                    // Floating platforms that move erratically
                    for (let i = 0; i < 10; i++) {
                        const chaosPlatform = new Platform(50 + i * 70, 100 + (i % 5) * 80, 50, 15, 'moving');
                        chaosPlatform.moveAxis = i % 2 === 0 ? 'x' : 'y';
                        chaosPlatform.moveRange = 70 + (i * 3);
                        chaosPlatform.moveSpeed = 1.5 + (i * 0.1);
                        chaosPlatform.moveDirection = i % 3 === 0 ? 1 : -1;
                        chaosPlatform.element.style.backgroundColor = '#ff9800';
                        chaosPlatform.element.style.boxShadow = '0 0 15px #ff5722';
                        platforms.push(chaosPlatform);
                    }
                    
                    // Gravity-defying enemies
                    for (let i = 0; i < 3; i++) {
                        const enemy = createEnemy(200 + i * 200, 50, 'follow');
                        enemy.element.style.transform = 'scaleY(-1)'; // Upside down enemies
                    }
                    
                    createEnemy(300, 300, 'grouble');
                    createEnemy(500, 300, 'ticktock');
                    
                    // Collectibles
                    createCollectible(100, 200);
                    createCollectible(250, 300);
                    createCollectible(400, 400);
                    createCollectible(550, 300);
                    createCollectible(700, 200);
                    
                    // Special powerup
                    const powerup = new Collectible(400, 200, 'powerup');
                    collectibles.push(powerup);
                    
                    showDialog("Scrangle's chaos grows stronger! The very laws of physics bend to his will. Use Green Form to navigate the ceiling areas!");
                }
                else if (level === 3) {
                    // Final boss level - the showdown with Scrangle
                    createPlatform(0, 550, 800, 50);
                    
                    // Central platform for the boss fight
                    createPlatform(300, 400, 200, 30);
                    
                    // Surrounding platforms that appear and disappear
                    const positions = [
                        {x: 150, y: 350},
                        {x: 150, y: 450},
                        {x: 650, y: 350},
                        {x: 650, y: 450},
                        {x: 300, y: 300},
                        {x: 500, y: 300}
                    ];
                    
                    for (let i = 0; i < positions.length; i++) {
                        const platform = new Platform(positions[i].x, positions[i].y, 80, 20, 'vanishing');
                        platform.element.style.backgroundColor = '#9c27b0';
                        platform.element.style.boxShadow = '0 0 20px #e91e63';
                        platform.vanishTimer = i * 10;
                        platforms.push(platform);
                    }
                    
                    // Moving platforms that orbit the center
                    for (let i = 0; i < 4; i++) {
                        const angle = i * Math.PI / 2;
                        const orbitPlatform = new Platform(
                            400 + Math.cos(angle) * 150,
                            300 + Math.sin(angle) * 100,
                            60, 15, 'moving'
                        );
                        orbitPlatform.element.style.backgroundColor = '#ff9800';
                        orbitPlatform.element.style.boxShadow = '0 0 15px #ff5722';
                        orbitPlatform.moveAxis = 'x';
                        orbitPlatform.moveRange = 100;
                        orbitPlatform.moveSpeed = 2;
                        orbitPlatform.moveDirection = i % 2 === 0 ? 1 : -1;
                        platforms.push(orbitPlatform);
                    }
                    
                    // Collectibles - the final Imagination Sparks
                    createCollectible(150, 320);
                    createCollectible(650, 320);
                    createCollectible(300, 270);
                    createCollectible(500, 270);
                    createCollectible(400, 200);
                    
                    // Final boss - Scrangle
                    createEnemy(400, 250, 'boss');
                    
                    showDialog("This is it, Wumpus! Face Scrangle and restore the Flow of Wonder to Luminara! Use all your forms and abilities in this final battle!");
                }
            }

            levelIndicator.textContent = `${game.worldNames[world-1]} - ${world}-${level}`;
            updateUI();
        }

        function clearLevel() {
            while (gameCanvas.firstChild) {
                gameCanvas.removeChild(gameCanvas.firstChild);
            }
            platforms = [];
            enemies = [];
            collectibles = [];
            colorBerries = [];
            if (player.element) {
                gameCanvas.appendChild(player.element);
            }
        }

        function createPlatform(x, y, width, height) {
            const platform = new Platform(x, y, width, height);
            platforms.push(platform);
            return platform;
        }

        function createEnemy(x, y, type) {
            const enemy = new Enemy(x, y, type);
            enemies.push(enemy);
            return enemy;
        }

        function createCollectible(x, y) {
            const collectible = new Collectible(x, y);
            collectibles.push(collectible);
            return collectible;
        }

        function createColorBerry(x, y, color) {
            const berry = new ColorBerry(x, y, color);
            colorBerries.push(berry);
            return berry;
        }

        function updateUI() {
            sparkCount.textContent = `${game.sparksCollected}/${game.totalSparks}`;
            const healthPoints = healthBar.querySelectorAll('.health-point');
            for (let i = 0; i < healthPoints.length; i++) {
                healthPoints[i].style.opacity = i < game.health ? '1' : '0.3';
            }
            colorPowers.forEach(power => {
                const colorId = power.id.split('-')[0];
                power.classList.toggle('active', game.currentColor === colorId);
                power.style.opacity = game.unlockedColors[colorId] ? '1' : '0.3';
            });
        }

        // Update player mode based on mapping
        function changeWumpusColor(color) {
            if (game.unlockedColors[color]) {
                game.currentColor = color;
                player.colorChangeTimer = 30;
                const settings = modeSettings[color];
                player.speed = settings.speed;
                game.jumpForce = settings.jumpForce;
                player.element.style.background = settings.background;
                player.element.style.backgroundSize = 'contain';
                updateUI();
                playSoundEffect('colorChange');
            }
        }

        function showDialog(text) {
            game.isShowingDialog = true;
            dialogText.textContent = text;
            dialogBox.style.display = 'block';
            game.isPaused = true;
        }

        function hideDialog() {
            dialogBox.style.display = 'none';
            game.isShowingDialog = false;
            game.isPaused = false;
            if (game.dialogQueue.length > 0) {
                setTimeout(showNextDialog, 500);
            }
        }

        function showNextDialog() {
            if (game.dialogQueue.length > 0) {
                const nextText = game.dialogQueue.shift();
                showDialog(nextText);
            }
        }

        function handleKeyDown(e) {
            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keys.left = true;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keys.right = true;
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                case ' ':
                    keys.jump = true;
                    if (game.isShowingDialog) {
                        hideDialog();
                    } else if (player.isOnGround && !player.isJumping) {
                        player.velocityY = game.jumpForce;
                        player.isJumping = true;
                        player.isOnGround = false;
                        player.jumpCount = 1;
                        playSoundEffect('jump');
                    }
                    break;
                case 'Shift':
                    keys.special = true;
                    useSpecialAbility();
                    break;
                case '1':
                    keys.color1 = true;
                    changeWumpusColor('red');
                    break;
                case '2':
                    keys.color2 = true;
                    changeWumpusColor('blue');
                    break;
                case '3':
                    keys.color3 = true;
                    changeWumpusColor('yellow');
                    break;
                case '4':
                    keys.color4 = true;
                    changeWumpusColor('green');
                    break;
                case 'z':
                case 'Z':
                    // Zippy Zapper Hat ability
                    if (game.unlockedPowerups.zippyZapperHat) {
                        keys.special = true;
                    }
                    break;
                case 'x':
                case 'X':
                    // Morph abilities
                    cycleMorphState();
                    break;
                case 'c':
                case 'C':
                    // Echo Orb ability
                    if (game.unlockedPowerups.echoOrb) {
                        keys.special = true;
                    }
                    break;
                case 'Escape':
                case 'p':
                case 'P':
                    keys.pause = true;
                    togglePause();
                    break;
            }
        }

        function cycleMorphState() {
            if (player.morphTimer <= 0) {
                switch(player.morphState) {
                    case "normal":
                        player.morphState = "inflated";
                        player.element.style.transform = `translateX(-50%) translateY(-50%) scaleX(${player.direction}) scale(1.3)`;
                        player.gravity = 0.2;
                        showDialog("Inflated form! You can float gently downward.");
                        break;
                    case "inflated":
                        player.morphState = "shrunken";
                        player.element.style.transform = `translateX(-50%) translateY(-50%) scaleX(${player.direction}) scale(0.7)`;
                        player.width *= 0.7;
                        player.height *= 0.7;
                        showDialog("Shrunken form! You can squeeze through tight spaces.");
                        break;
                    case "shrunken":
                        player.morphState = "elongated";
                        player.element.style.transform = `translateX(-50%) translateY(-50%) scaleX(${player.direction}) scaleY(1.5)`;
                        player.height *= 1.5;
                        showDialog("Elongated form! You can reach higher platforms.");
                        break;
                    case "elongated":
                        player.morphState = "normal";
                        player.element.style.transform = `translateX(-50%) translateY(-50%) scaleX(${player.direction})`;
                        player.width = 50;
                        player.height = 50;
                        player.gravity = 0.5;
                        showDialog("Back to normal form!");
                        break;
                }
                player.morphTimer = 300; // 5 seconds cooldown

                // Reset after a short time (except when explicitly changed back)
                if (player.morphState !== "normal") {
                    setTimeout(() => {
                        player.morphState = "normal";
                        player.element.style.transform = `translateX(-50%) translateY(-50%) scaleX(${player.direction})`;
                        player.width = 50;
                        player.height = 50;
                        player.gravity = 0.5;
                    }, 10000);
                }
            }
        }

        function handleKeyUp(e) {
            switch(e.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    keys.right = false;
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                case ' ':
                    keys.jump = false;
                    break;
                case 'Shift':
                    keys.special = false;
                    break;
                case '1':
                    keys.color1 = false;
                    break;
                case '2':
                    keys.color2 = false;
                    break;
                case '3':
                    keys.color3 = false;
                    break;
                case '4':
                    keys.color4 = false;
                    break;
                case 'Escape':
                case 'p':
                case 'P':
                    keys.pause = false;
                    break;
            }
        }

        function useSpecialAbility() {
            if (player.specialCooldown <= 0) {
                switch(game.currentColor) {
                    case 'red':
                        // Red form: charge into enemies and break barriers
                        player.velocityX = player.direction * 15;

                        // Visual effect for charge
                        const chargeEffect = document.createElement('div');
                        chargeEffect.className = 'charge-effect';
                        chargeEffect.style.position = 'absolute';
                        chargeEffect.style.width = '30px';
                        chargeEffect.style.height = '30px';
                        chargeEffect.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
                        chargeEffect.style.borderRadius = '50%';
                        chargeEffect.style.left = `${player.x - (player.direction * 20)}px`;
                        chargeEffect.style.top = `${player.y + player.height/2}px`;
                        gameCanvas.appendChild(chargeEffect);

                        setTimeout(() => {
                            chargeEffect.remove();
                        }, 500);

                        // Check for breakable platforms
                        for (const platform of platforms) {
                            if (platform.type === 'breakable' && checkCollision(player, platform)) {
                                platform.health--;
                                if (platform.health <= 0) {
                                    platform.remove();
                                    platforms = platforms.filter(p => p !== platform);
                                } else {
                                    platform.element.style.opacity = '0.5';
                                }
                            }
                        }

                        playSoundEffect('hit');
                        break;
                    case 'blue':
                        // Blue form: phasing handled in collision detection
                        // Visual effect for phasing
                        player.element.style.opacity = '0.5';
                        setTimeout(() => {
                            player.element.style.opacity = '1';
                        }, 2000);
                        break;
                    case 'yellow':
                        // Yellow form: bounce higher and deflect projectiles
                        if (player.isOnGround) {
                            player.velocityY = -20;
                            player.isJumping = true;
                            player.isOnGround = false;
                            playSoundEffect('jump');

                            // Visual effect for super bounce
                            const bounceEffect = document.createElement('div');
                            bounceEffect.className = 'bounce-effect';
                            bounceEffect.style.position = 'absolute';
                            bounceEffect.style.width = '60px';
                            bounceEffect.style.height = '10px';
                            bounceEffect.style.backgroundColor = 'rgba(255, 255, 0, 0.7)';
                            bounceEffect.style.borderRadius = '50%';
                            bounceEffect.style.left = `${player.x + player.width/2 - 30}px`;
                            bounceEffect.style.top = `${player.y + player.height}px`;
                            gameCanvas.appendChild(bounceEffect);

                            setTimeout(() => {
                                bounceEffect.remove();
                            }, 500);
                        } else {
                            // Deflection shield when in air
                            const shield = document.createElement('div');
                            shield.className = 'deflection-shield';
                            shield.style.position = 'absolute';
                            shield.style.width = '70px';
                            shield.style.height = '70px';
                            shield.style.backgroundColor = 'rgba(255, 255, 0, 0.3)';
                            shield.style.border = '2px solid rgba(255, 255, 0, 0.7)';
                            shield.style.borderRadius = '50%';
                            shield.style.left = `${player.x + player.width/2 - 35}px`;
                            shield.style.top = `${player.y + player.height/2 - 35}px`;
                            shield.style.zIndex = '2';
                            gameCanvas.appendChild(shield);

                            setTimeout(() => {
                                shield.remove();
                            }, 1000);
                        }
                        break;
                    case 'green':
                        // Green form: wall sticking handled in movement/collision
                        // Visual effect for sticky mode
                        const stickyEffect = document.createElement('div');
                        stickyEffect.className = 'sticky-effect';
                        stickyEffect.style.position = 'absolute';
                        stickyEffect.style.width = `${player.width + 10}px`;
                        stickyEffect.style.height = `${player.height + 10}px`;
                        stickyEffect.style.border = '3px dashed rgba(0, 255, 0, 0.7)';
                        stickyEffect.style.borderRadius = '50%';
                        stickyEffect.style.left = `${player.x - 5}px`;
                        stickyEffect.style.top = `${player.y - 5}px`;
                        gameCanvas.appendChild(stickyEffect);

                        setTimeout(() => {
                            stickyEffect.remove();
                        }, 3000);
                        break;
                }
                player.specialCooldown = modeSettings[game.currentColor].specialCooldown;
            }
        }

        function togglePause() {
            if (game.isRunning && !game.isShowingDialog) {
                game.isPaused = !game.isPaused;
                pauseScreen.style.display = game.isPaused ? 'flex' : 'none';
                if (game.isPaused) {
                    sounds.backgroundMusic.pause();
                } else {
                    sounds.backgroundMusic.play();
                }
            }
        }

        function resumeGame() {
            game.isPaused = false;
            pauseScreen.style.display = 'none';
            sounds.backgroundMusic.play();
        }

        function returnToMenu() {
            game.isRunning = false;
            game.isPaused = false;
            pauseScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            menuScreen.style.display = 'flex';
            clearLevel();
            sounds.backgroundMusic.pause();
        }

        function gameOver() {
            game.isRunning = false;
            gameOverScreen.style.display = 'flex';
            playSoundEffect('gameOver');
            sounds.backgroundMusic.pause();
        }

        function levelComplete() {
            game.isRunning = false;
            
            // Check for world completion
            if (game.currentLevel === 3 && game.currentWorld < 5) {
                levelStats.textContent = `World ${game.currentWorld} Complete!\nSparks Collected: ${game.sparksCollected}/${game.totalSparks}`;
                
                // Character dialogue for world completion
                let character;
                let message;
                
                switch(game.currentWorld) {
                    case 1:
                        character = game.characters.professor;
                        message = "Excellent work, Wumpus! You've restored the flow to Wonderwood Whimsy. But Scrangle's chaos still affects the Gelatinous Jungle!";
                        break;
                    case 2:
                        character = game.characters.twink;
                        message = "Wow! You're amazing, Wumpus! The jungle is bouncy in a good way again! Let's head to the Clockwork Carnival next!";
                        break;
                    case 3:
                        character = game.characters.blip;
                        message = "The carnival is working properly again! Scrangle is getting desperate. Be careful in the Melodica Mountains!";
                        break;
                    case 4:
                        character = game.characters.professor;
                        message = "The music flows freely again! Now it's time to confront Scrangle in his Nightmare Nexus. Good luck, brave Wumpus!";
                        break;
                }
                
                showDialog(message);
                setTimeout(hideDialog, 5000);
            } else if (game.currentWorld === 5 && game.currentLevel === 3) {
                // Game completion!
                levelStats.textContent = `You've completed Bogglebeast Quest!\nTotal Sparks: ${game.totalSparksInGame}/${game.totalSparks * 15}`;
                
                if (game.totalSparksInGame >= game.totalSparks * 15) {
                    // Unlock secret ending if all sparks collected
                    showDialog("Congratulations! You've collected all Imagination Sparks and fully restored the Flow of Wonder! A secret epilogue has been unlocked!");
                    game.timeAttackUnlocked = true;
                } else {
                    showDialog("Congratulations! You've defeated Scrangle and restored the Flow of Wonder to Luminara! The world is saved thanks to your courage and adaptability!");
                }
            } else {
                levelStats.textContent = `Sparks Collected: ${game.sparksCollected}/${game.totalSparks}`;
            }
            
            levelCompleteScreen.style.display = 'flex';
            playSoundEffect('levelComplete');
        }

        function restartLevel() {
            gameOverScreen.style.display = 'none';
            game.health = 3;
            game.sparksCollected = 0;
            loadLevel(game.currentWorld, game.currentLevel);
            game.isRunning = true;
            sounds.backgroundMusic.play();
        }

        function loadNextLevel() {
            levelCompleteScreen.style.display = 'none';
            game.currentLevel++;
            if (game.currentLevel > 3) {
                game.currentWorld++;
                game.currentLevel = 1;
                if (game.currentWorld > 5) {
                    returnToMenu();
                    return;
                }
            }
            game.sparksCollected = 0;
            loadLevel(game.currentWorld, game.currentLevel);
            game.isRunning = true;
            sounds.backgroundMusic.play();
        }

        function updatePlayer() {
            if (keys.left) {
                player.velocityX = -player.speed;
                player.direction = -1;
            } else if (keys.right) {
                player.velocityX = player.speed;
                player.direction = 1;
            } else {
                if (player.velocityX > 0.1) {
                    player.velocityX -= 0.2;
                } else if (player.velocityX < -0.1) {
                    player.velocityX += 0.2;
                } else {
                    player.velocityX = 0;
                }
            }

            // Special handling for morph states
            if (player.morphState === "inflated") {
                // Inflated form floats gently
                if (player.velocityY > 1) {
                    player.velocityY = 1;
                } else {
                    player.velocityY += game.gravity * 0.4;
                }
            } else if (player.morphState === "elongated" && keys.jump && !player.isJumping) {
                // Elongated form can jump higher
                player.velocityY = game.jumpForce * 1.3;
                player.isJumping = true;
                playSoundEffect('jump');
            } else if (game.currentColor === 'green' && (player.isOnWall || player.isOnCeiling)) {
                // Green form can stick to walls and ceilings
                player.velocityY = 0;

                // Allow climbing up walls
                if (player.isOnWall && keys.jump) {
                    player.velocityY = -3;
                }
            } else {
                player.velocityY += game.gravity;
            }

            player.x += player.velocityX;
            player.y += player.velocityY;

            player.x = clamp(player.x, 0, 800 - player.width);

            if (player.y > 600) {
                takeDamage();
                player.x = 100;
                player.y = 300;
                player.velocityY = 0;
            }

            player.isOnGround = false;
            player.isOnWall = false;
            player.isOnCeiling = false;

            for (const platform of platforms) {
                // Blue form can walk on water
                if (platform.isWater && game.currentColor !== 'blue') continue;

                // Shrunken form can pass through small gaps
                if (player.morphState === "shrunken" && platform.type === "small-gap") continue;

                if (checkCollision(player, platform)) {
                    // Handle special platform types
                    if (platform.type === 'bouncy') {
                        player.velocityY = game.jumpForce * 1.5;
                        playSoundEffect('jump');
                    } else if (platform.type === 'vanishing' && !platform.isVisible) {
                        continue;
                    } else {
                        handlePlatformCollision(player, platform);
                    }
                }
            }

            // Reset jump count when on ground
            if (player.isOnGround) {
                player.jumpCount = 0;
            }

            // Decrease morph timer
            if (player.morphTimer > 0) {
                player.morphTimer--;
            }

            // Handle enemy collisions
            for (const enemy of enemies) {
                if (checkCollision(player, enemy)) {
                    // Invincibility check
                    if (player.invincibilityTimer > 0) continue;

                    // Blue form can phase through enemies with special
                    if (game.currentColor === 'blue' && keys.special) continue;

                    // Red form can charge into enemies with special
                    if (game.currentColor === 'red' && keys.special) {
                        enemy.takeDamage();
                    } 
                    // Yellow form can deflect with special
                    else if (game.currentColor === 'yellow' && keys.special) {
                        enemy.takeDamage();
                        player.velocityY = -8;
                    }
                    // Jump on enemy head
                    else if (player.velocityY > 0 && player.y < enemy.y - player.height/2) {
                        enemy.takeDamage();
                        player.velocityY = -10;
                    } 
                    // Take damage
                    else {
                        takeDamage();
                        player.velocityX = player.direction * -5;
                        player.velocityY = -5;

                        // Set invincibility timer
                        player.invincibilityTimer = 60; // 1 second of invincibility

                        // Flash effect during invincibility
                        const flashInterval = setInterval(() => {
                            player.element.style.opacity = player.element.style.opacity === '0.5' ? '1' : '0.5';
                        }, 100);

                        setTimeout(() => {
                            clearInterval(flashInterval);
                            player.element.style.opacity = '1';
                        }, 1000);
                    }
                }
            }

            // Collect items
            processCollisions(player, collectibles, obj => obj.collect());
            processCollisions(player, colorBerries, obj => obj.collect());

            // Update player position and appearance
            player.element.style.left = `${player.x}px`;
            player.element.style.top = `${player.y}px`;

            // Maintain morph state in transform
            let morphTransform = '';
            switch(player.morphState) {
                case "inflated":
                    morphTransform = ' scale(1.3)';
                    break;
                case "shrunken":
                    morphTransform = ' scale(0.7)';
                    break;
                case "elongated":
                    morphTransform = ' scaleY(1.5)';
                    break;
            }

            player.element.style.transform = `translateX(-50%) translateY(-50%) scaleX(${player.direction})${morphTransform}`;

            // Visual effects
            if (player.colorChangeTimer > 0) {
                player.colorChangeTimer--;
                player.element.style.filter = `brightness(${1 + player.colorChangeTimer/10})`;
            } else if (player.invincibilityTimer > 0) {
                player.invincibilityTimer--;
            } else {
                player.element.style.filter = '';
            }

            if (player.specialCooldown > 0) {
                player.specialCooldown--;
            }

            // Level completion check
            if (game.sparksCollected >= game.totalSparks) {
                levelComplete();
            }
        }

        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }

        function handlePlatformCollision(player, platform) {
            if (game.currentColor === 'blue' && keys.special) return;
            const { overlapX, overlapY } = getOverlap(player, platform);
            if (overlapX > overlapY) {
                if (player.y < platform.y) {
                    player.y = platform.y - player.height;
                    player.velocityY = 0;
                    player.isOnGround = true;
                    player.isJumping = false;
                } else {
                    player.y = platform.y + platform.height;
                    player.velocityY = 0;
                    player.isOnCeiling = true;
                }
            } else {
                if (player.x < platform.x) {
                    player.x = platform.x - player.width;
                } else {
                    player.x = platform.x + platform.width;
                }
                player.velocityX = 0;
                player.isOnWall = true;
            }
        }

        function takeDamage() {
            game.health--;
            updateUI();
            playSoundEffect('hit');
            if (game.health <= 0) {
                gameOver();
            }
        }

        function updateEnemies() {
            for (const enemy of enemies) {
                enemy.update();
            }
        }

        function updatePlatforms() {
            for (const platform of platforms) {
                if (platform.update) {
                    platform.update();
                }
            }
        }

        function updatePowerups() {
            // Handle active powerups
            if (game.unlockedPowerups.zippyZapperHat && keys.special) {
                // Create energy burst projectile
                if (player.specialCooldown <= 0) {
                    const burst = document.createElement('div');
                    burst.className = 'energy-burst';
                    burst.style.position = 'absolute';
                    burst.style.width = '20px';
                    burst.style.height = '20px';
                    burst.style.backgroundColor = game.currentColor;
                    burst.style.borderRadius = '50%';
                    burst.style.boxShadow = `0 0 10px ${game.currentColor}`;
                    burst.style.left = `${player.x + (player.direction > 0 ? player.width : 0)}px`;
                    burst.style.top = `${player.y + player.height/2}px`;
                    burst.style.zIndex = '3';
                    gameCanvas.appendChild(burst);

                    // Animate the burst
                    const burstSpeed = 8;
                    const burstInterval = setInterval(() => {
                        const left = parseFloat(burst.style.left);
                        burst.style.left = `${left + (burstSpeed * player.direction)}px`;

                        // Check collision with enemies
                        for (const enemy of enemies) {
                            if (left > enemy.x && 
                                left < enemy.x + enemy.width && 
                                parseFloat(burst.style.top) > enemy.y && 
                                parseFloat(burst.style.top) < enemy.y + enemy.height) {

                                enemy.takeDamage();
                                clearInterval(burstInterval);
                                burst.remove();
                                break;
                            }
                        }

                        // Remove if offscreen
                        if (left < 0 || left > 800) {
                            clearInterval(burstInterval);
                            burst.remove();
                        }
                    }, 16);

                    player.specialCooldown = 30;
                }
            }

            if (game.unlockedPowerups.puffPodBoots && keys.jump && player.jumpCount < 3) {
                if (!player.isOnGround && !player.isJumping && player.jumpCount < 3) {
                    player.velocityY = game.jumpForce * 0.8;
                    player.jumpCount++;
                    playSoundEffect('jump');

                    // Visual effect for triple jump
                    const jumpEffect = document.createElement('div');
                    jumpEffect.className = 'jump-effect';
                    jumpEffect.style.position = 'absolute';
                    jumpEffect.style.width = '40px';
                    jumpEffect.style.height = '10px';
                    jumpEffect.style.backgroundColor = '#fff';
                    jumpEffect.style.borderRadius = '50%';
                    jumpEffect.style.opacity = '0.7';
                    jumpEffect.style.left = `${player.x + player.width/2 - 20}px`;
                    jumpEffect.style.top = `${player.y + player.height}px`;
                    gameCanvas.appendChild(jumpEffect);

                    setTimeout(() => {
                        jumpEffect.remove();
                    }, 300);
                }
            }

            if (game.unlockedPowerups.echoOrb && keys.special) {
                // Echo Orb - mimic nearby enemy attacks
                const nearbyEnemies = enemies.filter(enemy => 
                    Math.abs(enemy.x - player.x) < 150 && 
                    Math.abs(enemy.y - player.y) < 150
                );

                if (nearbyEnemies.length > 0 && player.specialCooldown <= 0) {
                    // Create mimic attack based on closest enemy type
                    const closestEnemy = nearbyEnemies[0];

                    if (closestEnemy.type === 'ticktock') {
                        // Speed boost
                        player.speed *= 1.5;
                        setTimeout(() => {
                            player.speed = modeSettings[game.currentColor].speed;
                        }, 3000);
                    } else if (closestEnemy.element.classList.contains('mad-maestro')) {
                        // Create musical note projectiles
                        for (let i = 0; i < 3; i++) {
                            const note = document.createElement('div');
                            note.className = 'musical-note player-note';
                            note.style.position = 'absolute';
                            note.style.width = '20px';
                            note.style.height = '30px';
                            note.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=musical%20note%20pixel%20art&resize=20x30&transparency=true') no-repeat";
                            note.style.backgroundSize = 'contain';
                            note.style.filter = 'hue-rotate(90deg)'; // Player notes are different color
                            note.style.left = `${player.x + player.width/2}px`;
                            note.style.top = `${player.y + player.height/2}px`;
                            gameCanvas.appendChild(note);

                            // Animate the note
                            const angle = (i * 45) - 45;
                            const rad = angle * Math.PI / 180;
                            const vx = Math.cos(rad) * 3;
                            const vy = Math.sin(rad) * 3;

                            const noteInterval = setInterval(() => {
                                const left = parseFloat(note.style.left);
                                const top = parseFloat(note.style.top);
                                note.style.left = `${left + vx}px`;
                                note.style.top = `${top + vy}px`;

                                // Check collision with enemies
                                for (const enemy of enemies) {
                                    if (left > enemy.x && 
                                        left < enemy.x + enemy.width && 
                                        top > enemy.y && 
                                        top < enemy.y + enemy.height) {

                                        enemy.takeDamage();
                                        clearInterval(noteInterval);
                                        note.remove();
                                        break;
                                    }
                                }

                                // Remove note if it goes off screen
                                if (left < 0 || left > 800 || top < 0 || top > 600) {
                                    clearInterval(noteInterval);
                                    note.remove();
                                }
                            }, 16);
                        }
                    }

                    player.specialCooldown = 120;
                }
            }
        }

        function loadBonusRoom() {
            clearLevel();

            // Create a special bonus room
            background = document.createElement('div');
            background.className = 'background';
            background.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=magical%20treasure%20room%20pixel%20art&resize=800x600') no-repeat center center";
            background.style.backgroundSize = 'cover';
            gameCanvas.appendChild(background);

            // Add platforms
            createPlatform(100, 500, 600, 20);
            createPlatform(300, 400, 200, 20);
            createPlatform(200, 300, 150, 20);
            createPlatform(450, 300, 150, 20);

            // Add extra collectibles
            for (let i = 0; i < 5; i++) {
                createCollectible(
                    150 + Math.random() * 500,
                    250 + Math.random() * 200
                );
            }

            // Add a powerup
            const powerup = new Collectible(400, 270, 'powerup');
            collectibles.push(powerup);

            // Add exit door
            const exitDoor = document.createElement('div');
            exitDoor.className = 'exit-door';
            exitDoor.style.position = 'absolute';
            exitDoor.style.width = '50px';
            exitDoor.style.height = '80px';
            exitDoor.style.background = "url('https://images.fuzzycode.dev/fast_ai?search=exit%20door%20pixel%20art&resize=50x80&transparency=true') no-repeat";
            exitDoor.style.backgroundSize = 'contain';
            exitDoor.style.left = '700px';
            exitDoor.style.top = '420px';
            exitDoor.style.zIndex = '1';
            gameCanvas.appendChild(exitDoor);

            // Exit door collision detection
            const exitInterval = setInterval(() => {
                if (checkCollision(player, {
                    x: 700,
                    y: 420,
                    width: 50,
                    height: 80
                })) {
                    clearInterval(exitInterval);
                    exitDoor.remove();
                    showDialog("Returning to the main level...");
                    setTimeout(() => {
                        hideDialog();
                        loadLevel(game.currentWorld, game.currentLevel);
                    }, 1000);
                }
            }, 100);

            // Reset player position
            player.x = 150;
            player.y = 450;
            player.velocityX = 0;
            player.velocityY = 0;

            showDialog("You found a secret bonus room! Collect the treasures and find the exit door.");
        }

        function gameLoop() {
            if (game.isRunning) {
                if (!game.isPaused) {
                    updatePlayer();
                    updateEnemies();
                    updatePlatforms();
                    updatePowerups();
                }
            }
            requestAnimationFrame(gameLoop);
        }

        init();
    </script>

    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.2/dist/nipplejs.js" crossorigin="anonymous"></script>
    <script>
(function (root, factory) {
    if (typeof module === "object" && module.exports) {
        module.exports = factory();
    } else {
        root.TouchpadControls = factory();
        root.touchpadControls = root.TouchpadControls;
    }
}(typeof self !== "undefined" ? self : this, function () {
    "use strict";

    const sections = {
        CENTER_LEFT: { top: "50%", left: "130px", transform: "translate(-50%, -50%)" },
        CENTER_TOP: { top: "130px", left: "50%", transform: "translate(-50%, -50%)" },
        CENTER_RIGHT: { top: "50%", left: "calc(100% - 130px)", transform: "translate(-50%, -50%)" },
        CENTER_BOTTOM: { top: "calc(100% - 130px)", left: "50%", transform: "translate(-50%, -50%)" }
    };

    const buttonPositions = {
        CENTER_LEFT: { top: "0", left: "-50px" },
        CENTER_TOP: { top: "-50px", left: "0" },
        CENTER_RIGHT: { top: "0", left: "50px" },
        CENTER_BOTTOM: { top: "50px", left: "0" }
    };

    const STYLE_ID = "touchpad-controls-style";
    const MIN_TOUCH_TARGET = 48;

    const injectTouchpadStyles = () => {
        if (typeof document === "undefined") return;
        if (document.getElementById(STYLE_ID)) return;

        const style = document.createElement("style");
        style.id = STYLE_ID;
        style.textContent = `
            :root {
                --touchpad-size: 72px;
                --touchpad-radius: 50%;
                --touchpad-bg: radial-gradient(135% 135% at 25% 20%, rgba(255,255,255,0.15), rgba(0,0,0,0.6));
                --touchpad-bg-image: none;
                --touchpad-bg-image-size: cover;
                --touchpad-bg-image-position: center;
                --touchpad-bg-blend: soft-light;
                --touchpad-border: 1px solid rgba(255,255,255,0.12);
                --touchpad-shadow: 0 12px 40px rgba(0,0,0,0.7), inset 0 1px 1px rgba(255,255,255,0.1);
                --touchpad-shadow-active: 0 4px 15px rgba(0,0,0,0.9), inset 0 1px 0 rgba(0,0,0,0.3);
                --touchpad-icon: none;
                --touchpad-icon-size: 52%;
                --touchpad-icon-opacity: 0.9;
                --touchpad-foreground-image: none;
                --touchpad-foreground-size: 60%;
                --touchpad-foreground-opacity: 0.8;
                --touchpad-foreground-blend: normal;
                --touchpad-label-color: #E2E8F0;
                --touchpad-label-size: 12px;
            }

            .touchpad {
                position: absolute;
                width: var(--touchpad-size);
                height: var(--touchpad-size);
                padding: 0;
                box-sizing: border-box;
                border-radius: var(--touchpad-radius);
                background-image: var(--touchpad-bg-image, none), var(--touchpad-bg);
                background-size: var(--touchpad-bg-image-size, cover), 100%;
                background-position: var(--touchpad-bg-image-position, center), center;
                background-repeat: no-repeat, no-repeat;
                background-blend-mode: var(--touchpad-bg-blend, soft-light), normal;
                border: var(--touchpad-border);
                box-shadow: var(--touchpad-shadow);
                display: flex;
                justify-content: center;
                align-items: center;
                touch-action: none;
                user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                font-size: 0;
                color: transparent;
                z-index: 9999;
                overflow: visible;
                backdrop-filter: blur(12px) saturate(180%);
                -webkit-backdrop-filter: blur(12px) saturate(180%);
                transition:
                    transform 120ms cubic-bezier(0.2, 0, 0, 1),
                    box-shadow 150ms ease,
                    background 200ms ease,
                    filter 150ms linear;
                background-position: center;
                background-repeat: no-repeat;
                background-size: 45%;
            }

            .touchpad::after {
                content: "";
                position: absolute;
                width: var(--touchpad-icon-size, 52%);
                height: var(--touchpad-icon-size, 52%);
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background-image: var(--touchpad-icon, none);
                background-repeat: no-repeat;
                background-position: center;
                background-size: contain;
                opacity: var(--touchpad-icon-opacity, 0.9);
                pointer-events: none;
                filter: drop-shadow(0 2px 6px rgba(0,0,0,0.6));
            }

            .touchpad::before {
                content: "";
                position: absolute;
                width: var(--touchpad-foreground-size, 60%);
                height: var(--touchpad-foreground-size, 60%);
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background-image: var(--touchpad-foreground-image, none);
                background-repeat: no-repeat;
                background-position: center;
                background-size: contain;
                opacity: var(--touchpad-foreground-opacity, 0.8);
                mix-blend-mode: var(--touchpad-foreground-blend, normal);
                pointer-events: none;
            }

            .touchpad--label {
                font-size: var(--touchpad-label-size, 12px);
                color: var(--touchpad-label-color, #E2E8F0);
            }

            .touchpad-label {
                position: absolute;
                left: 0;
                right: 0;
                bottom: 10%;
                text-align: center;
                font-weight: 600;
                pointer-events: none;
                text-shadow: 0 2px 8px rgba(0,0,0,0.7);
            }

            .touchpad.is-active {
                transform: scale(0.94) translate3d(0, 1px, 0);
                box-shadow: var(--touchpad-shadow-active);
            }

            .touchpad:hover {
                box-shadow: 0 12px 32px rgba(0,0,0,0.95);
            }

            .touchpad--button {
                font-size: 18px;
            }

            .touchpad--joystick {
                font-size: 14px;
            }

            .touchpad .nipple,
            .touchpad .nipple * {
                overflow: visible;
            }

            .touchpad .nipple .back {
                box-shadow:
                    0 0 0 1px rgba(15,23,42,0.85),
                    0 0 0 6px rgba(148,163,184,0.12),
                    0 10px 30px rgba(15,23,42,0.85);
            }

            .touchpad .nipple .front {
                box-shadow:
                    0 0 0 1px rgba(148,163,184,0.9),
                    0 8px 18px rgba(15,23,42,0.9);
            }
        `;
        document.head.appendChild(style);
    };

    const safeEntries = (obj) => {
        if (!obj || typeof obj !== "object") return [];
        return Object.entries(obj);
    };

    const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

    const formatCssValue = (value) => {
        if (typeof value === "number" && Number.isFinite(value)) {
            return `${value}px`;
        }
        return value;
    };

    const ICON_COLOR_DEFAULT = "#E2E8F0";
    const ICON_STROKE = 4;

    const svgToDataUri = (svg) => {
        const encoded = encodeURIComponent(svg)
            .replace(/%0A/g, "");
        return `url(\"data:image/svg+xml,${encoded}\")`;
    };

    const iconArrow = (direction, color) => {
        const stroke = color || ICON_COLOR_DEFAULT;
        if (direction === "left") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M40 16 L24 32 L40 48"/><path d="M26 32 H50"/></svg>`
            );
        }
        if (direction === "right") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M24 16 L40 32 L24 48"/><path d="M14 32 H38"/></svg>`
            );
        }
        if (direction === "up") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M16 30 L32 14 L48 30"/><path d="M32 16 V52"/></svg>`
            );
        }
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M16 34 L32 50 L48 34"/><path d="M32 12 V48"/></svg>`
        );
    };

    const iconHorizontal = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M18 22 L8 32 L18 42"/><path d="M46 22 L56 32 L46 42"/><path d="M14 32 H50"/></svg>`
    );

    const iconVertical = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M22 18 L32 8 L42 18"/><path d="M22 46 L32 56 L42 46"/><path d="M32 14 V50"/></svg>`
    );

    const iconDpad = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M32 16 V48"/><path d="M16 32 H48"/><path d="M24 22 L32 14 L40 22"/><path d="M24 42 L32 50 L40 42"/><path d="M22 24 L14 32 L22 40"/><path d="M42 24 L50 32 L42 40"/></svg>`
    );

    const iconCircle = (filled, color) => {
        const fillColor = color || ICON_COLOR_DEFAULT;
        if (filled) {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="14" fill="${fillColor}"/></svg>`
            );
        }
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="14" fill="none" stroke="${fillColor}" stroke-width="${ICON_STROKE}"/></svg>`
        );
    };

    const iconSquare = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="20" y="20" width="24" height="24" rx="4" fill="${color || ICON_COLOR_DEFAULT}"/></svg>`
    );

    const iconTriangle = (direction, color) => {
        const fillColor = color || ICON_COLOR_DEFAULT;
        if (direction === "left") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M22 32 L42 18 V46 Z" fill="${fillColor}"/></svg>`
            );
        }
        if (direction === "right") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M42 32 L22 18 V46 Z" fill="${fillColor}"/></svg>`
            );
        }
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 18 L18 42 H46 Z" fill="${fillColor}"/></svg>`
        );
    };

    const iconChevron = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M22 18 L34 32 L22 46"/><path d="M34 18 L46 32 L34 46"/></svg>`
    );

    const iconPause = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="20" y="18" width="8" height="28" rx="2" fill="${color || ICON_COLOR_DEFAULT}"/><rect x="36" y="18" width="8" height="28" rx="2" fill="${color || ICON_COLOR_DEFAULT}"/></svg>`
    );

    const keyLabel = (key) => {
        if (!key) return "";
        if (key.startsWith("Key") && key.length === 4) return key.slice(3);
        if (key.startsWith("Digit") && key.length === 6) return key.slice(5);
        if (key === "Space") return "SP";
        if (key === "Escape") return "ESC";
        if (key === "Enter") return "ENT";
        if (key === "Tab") return "TAB";
        if (key === "Backspace") return "BK";
        if (key === "ShiftLeft" || key === "ShiftRight") return "SH";
        if (key === "ControlLeft" || key === "ControlRight") return "CT";
        if (key === "AltLeft" || key === "AltRight") return "AL";
        if (key === "MetaLeft" || key === "MetaRight") return "MD";
        return key.slice(0, 3).toUpperCase();
    };

    const normalizeTheme = (theme) => {
        if (!theme || typeof theme !== "object") {
            return {
                iconColor: ICON_COLOR_DEFAULT,
                iconOpacity: 0.9,
                iconScale: 0.52,
                labelMode: "none",
                labelColor: ICON_COLOR_DEFAULT,
                labelSize: 12,
                background: null,
                backgroundImage: null,
                backgroundBlend: "soft-light",
                backgroundSize: "cover",
                backgroundPosition: "center",
                foregroundImage: null,
                foregroundOpacity: 0.8,
                foregroundSize: "60%",
                foregroundBlend: "normal"
            };
        }
        return {
            iconColor: theme.iconColor || ICON_COLOR_DEFAULT,
            iconOpacity: typeof theme.iconOpacity === "number" ? theme.iconOpacity : 0.9,
            iconScale: typeof theme.iconScale === "number" ? theme.iconScale : 0.52,
            labelMode: theme.labelMode || "none",
            labelColor: theme.labelColor || ICON_COLOR_DEFAULT,
            labelSize: typeof theme.labelSize === "number" ? theme.labelSize : 12,
            background: theme.background || null,
            backgroundImage: theme.backgroundImage || null,
            backgroundBlend: theme.backgroundBlend || "soft-light",
            backgroundSize: theme.backgroundSize || "cover",
            backgroundPosition: theme.backgroundPosition || "center",
            foregroundImage: theme.foregroundImage || null,
            foregroundOpacity: typeof theme.foregroundOpacity === "number" ? theme.foregroundOpacity : 0.8,
            foregroundSize: theme.foregroundSize || "60%",
            foregroundBlend: theme.foregroundBlend || "normal"
        };
    };

    const mergeTheme = (base, override) => {
        if (!override || typeof override !== "object") return base;
        return normalizeTheme(Object.assign({}, base, override));
    };

    const normalizeImageValue = (value) => {
        if (!value) return null;
        if (value.includes("url(")) return value;
        return `url(\"${value}\")`;
    };

    const applyThemeVars = (element, theme) => {
        if (!element || !theme) return;
        if (theme.background) {
            element.style.setProperty("--touchpad-bg", theme.background);
        }
        if (theme.backgroundImage) {
            element.style.setProperty("--touchpad-bg-image", normalizeImageValue(theme.backgroundImage));
            element.style.setProperty("--touchpad-bg-blend", theme.backgroundBlend || "soft-light");
            element.style.setProperty("--touchpad-bg-image-size", theme.backgroundSize || "cover");
            element.style.setProperty("--touchpad-bg-image-position", theme.backgroundPosition || "center");
        }
        if (theme.foregroundImage) {
            element.style.setProperty("--touchpad-foreground-image", normalizeImageValue(theme.foregroundImage));
            element.style.setProperty("--touchpad-foreground-opacity", String(theme.foregroundOpacity));
            element.style.setProperty("--touchpad-foreground-size", theme.foregroundSize || "60%");
            element.style.setProperty("--touchpad-foreground-blend", theme.foregroundBlend || "normal");
        }
        if (theme.iconOpacity != null) {
            element.style.setProperty("--touchpad-icon-opacity", String(theme.iconOpacity));
        }
        if (theme.iconScale != null) {
            element.style.setProperty("--touchpad-icon-size", `${Math.round(theme.iconScale * 100)}%`);
        }
        if (theme.labelColor) {
            element.style.setProperty("--touchpad-label-color", theme.labelColor);
        }
        if (theme.labelSize) {
            element.style.setProperty("--touchpad-label-size", `${theme.labelSize}px`);
        }
    };

    const resolveLabelText = (btn, labelMode) => {
        if (!btn) return "";
        if (labelMode === "none") return "";
        if (labelMode === "text") {
            if (btn.label) return String(btn.label);
            if (typeof btn.keys === "string") return keyLabel(btn.keys);
            return "";
        }
        if (labelMode === "key") {
            if (typeof btn.keys === "string") return keyLabel(btn.keys);
            return "";
        }
        if (labelMode === "both") {
            if (btn.label) return String(btn.label);
            if (typeof btn.keys === "string") return keyLabel(btn.keys);
            return "";
        }
        return "";
    };

    const iconKeycap = (label, color) => {
        const fillColor = color || ICON_COLOR_DEFAULT;
        const safe = String(label || "").replace(/[^A-Z0-9]/g, "");
        const text = safe || "";
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="12" y="14" width="40" height="36" rx="8" fill="none" stroke="${fillColor}" stroke-width="${ICON_STROKE}"/><text x="32" y="38" font-size="16" text-anchor="middle" fill="${fillColor}" font-family="monospace">${text}</text></svg>`
        );
    };

    const resolveDirectionForKey = (key, role) => {
        if (key === "ArrowLeft") return "left";
        if (key === "ArrowRight") return "right";
        if (key === "ArrowUp") return "up";
        if (key === "ArrowDown") return "down";
        if (role === "move" || role === "aim") {
            if (key === "KeyA") return "left";
            if (key === "KeyD") return "right";
            if (key === "KeyW") return "up";
            if (key === "KeyS") return "down";
        }
        return null;
    };

    const resolveIcon = (btn, theme) => {
        if (!btn) return null;
        if (btn.icon) return btn.icon;
        const iconColor = theme && theme.iconColor ? theme.iconColor : ICON_COLOR_DEFAULT;
        const meta = btn.meta || null;
        const keys = btn.keys;
        const role = btn.role;

        if (meta && meta.pair_position) {
            return iconTriangle(meta.pair_position === "right" ? "right" : "left", iconColor);
        }

        if (keys && typeof keys === "object" && !Array.isArray(keys)) {
            const hasLeft = !!keys.left;
            const hasRight = !!keys.right;
            const hasUp = !!keys.up;
            const hasDown = !!keys.down;
            if (hasLeft && hasRight && hasUp && hasDown) return iconDpad(iconColor);
            if (hasLeft && hasRight && !hasUp && !hasDown) return iconHorizontal(iconColor);
            if (hasUp && hasDown && !hasLeft && !hasRight) return iconVertical(iconColor);
            if (hasLeft && !hasRight && !hasUp && !hasDown) return iconArrow("left", iconColor);
            if (hasRight && !hasLeft && !hasUp && !hasDown) return iconArrow("right", iconColor);
            if (hasUp && !hasLeft && !hasRight && !hasDown) return iconArrow("up", iconColor);
            if (hasDown && !hasLeft && !hasRight && !hasUp) return iconArrow("down", iconColor);
        }

        if (typeof keys === "string") {
            const direction = resolveDirectionForKey(keys, role);
            if (direction) return iconArrow(direction, iconColor);
        }

        if (role === "jump") return iconArrow("up", iconColor);
        if (role === "pause") return iconPause(iconColor);
        if (role === "primary") return iconCircle(true, iconColor);
        if (role === "secondary") return iconCircle(false, iconColor);
        if (role === "tertiary") return iconSquare(iconColor);
        if (role === "modifier") return iconChevron(iconColor);
        if (role === "magnitude") return iconArrow("up", iconColor);

        if (typeof keys === "string") {
            return iconKeycap(keyLabel(keys), iconColor);
        }

        return null;
    };

    const KEY_ALIASES = {
        " ": "Space",
        "space": "Space",
        "Spacebar": "Space",
        "Esc": "Escape",
        "Return": "Enter",
        "Left": "ArrowLeft",
        "Right": "ArrowRight",
        "Up": "ArrowUp",
        "Down": "ArrowDown",
        "Del": "Delete",
        "Shift": "ShiftLeft",
        "Control": "ControlLeft",
        "Alt": "AltLeft",
        "Meta": "MetaLeft"
    };

    const KEY_DESCRIPTORS = {
        ArrowLeft: { key: "ArrowLeft", keyCode: 37 },
        ArrowRight: { key: "ArrowRight", keyCode: 39 },
        ArrowUp: { key: "ArrowUp", keyCode: 38 },
        ArrowDown: { key: "ArrowDown", keyCode: 40 },
        Space: { key: " ", keyCode: 32 },
        Enter: { key: "Enter", keyCode: 13 },
        Tab: { key: "Tab", keyCode: 9 },
        Escape: { key: "Escape", keyCode: 27 },
        Backspace: { key: "Backspace", keyCode: 8 },
        Delete: { key: "Delete", keyCode: 46 },
        Insert: { key: "Insert", keyCode: 45 },
        Home: { key: "Home", keyCode: 36 },
        End: { key: "End", keyCode: 35 },
        PageUp: { key: "PageUp", keyCode: 33 },
        PageDown: { key: "PageDown", keyCode: 34 },
        CapsLock: { key: "CapsLock", keyCode: 20 },
        NumLock: { key: "NumLock", keyCode: 144 },
        ScrollLock: { key: "ScrollLock", keyCode: 145 },
        Pause: { key: "Pause", keyCode: 19 },
        PrintScreen: { key: "PrintScreen", keyCode: 44 },
        ContextMenu: { key: "ContextMenu", keyCode: 93 },
        ShiftLeft: { key: "Shift", keyCode: 16, location: 1 },
        ShiftRight: { key: "Shift", keyCode: 16, location: 2 },
        ControlLeft: { key: "Control", keyCode: 17, location: 1 },
        ControlRight: { key: "Control", keyCode: 17, location: 2 },
        AltLeft: { key: "Alt", keyCode: 18, location: 1 },
        AltRight: { key: "Alt", keyCode: 18, location: 2 },
        MetaLeft: { key: "Meta", keyCode: 91, location: 1 },
        MetaRight: { key: "Meta", keyCode: 91, location: 2 },
        Minus: { key: "-", keyCode: 189 },
        Equal: { key: "=", keyCode: 187 },
        BracketLeft: { key: "[", keyCode: 219 },
        BracketRight: { key: "]", keyCode: 221 },
        Backslash: { key: "\\", keyCode: 220 },
        Semicolon: { key: ";", keyCode: 186 },
        Quote: { key: "'", keyCode: 222 },
        Backquote: { key: "`", keyCode: 192 },
        Comma: { key: ",", keyCode: 188 },
        Period: { key: ".", keyCode: 190 },
        Slash: { key: "/", keyCode: 191 }
    };

    const NUMPAD_DESCRIPTORS = {
        NumpadAdd: { key: "+", keyCode: 107, location: 3 },
        NumpadSubtract: { key: "-", keyCode: 109, location: 3 },
        NumpadMultiply: { key: "*", keyCode: 106, location: 3 },
        NumpadDivide: { key: "/", keyCode: 111, location: 3 },
        NumpadDecimal: { key: ".", keyCode: 110, location: 3 },
        NumpadEnter: { key: "Enter", keyCode: 13, location: 3 },
        NumpadEqual: { key: "=", keyCode: 187, location: 3 }
    };

    const resolveKeyDescriptor = (rawKey) => {
        const raw = String(rawKey);
        const key = KEY_ALIASES[raw] || raw;
        let keyCode;
        let code;
        let keyValue = key;
        let location;

        const preset = KEY_DESCRIPTORS[key];
        if (preset) {
            keyCode = preset.keyCode;
            code = key;
            keyValue = preset.key;
            location = preset.location;
        }

        if (keyCode == null) {
            if (/^Key[a-zA-Z]$/.test(key)) {
                const letter = key.charAt(3).toUpperCase();
                keyCode = letter.charCodeAt(0);
                code = key;
                keyValue = letter.toLowerCase();
            } else if (/^Digit[0-9]$/.test(key)) {
                const digit = key.charAt(5);
                keyCode = 48 + parseInt(digit, 10);
                code = key;
                keyValue = digit;
            } else if (/^F([1-9]|1[0-9]|2[0-4])$/.test(key)) {
                const number = parseInt(key.slice(1), 10);
                keyCode = 111 + number;
                code = key;
                keyValue = key;
            } else if (/^Numpad[0-9]$/.test(key)) {
                const digit = parseInt(key.slice(6), 10);
                keyCode = 96 + digit;
                code = key;
                keyValue = String(digit);
                location = 3;
            } else if (NUMPAD_DESCRIPTORS[key]) {
                const numpadPreset = NUMPAD_DESCRIPTORS[key];
                keyCode = numpadPreset.keyCode;
                code = key;
                keyValue = numpadPreset.key;
                location = numpadPreset.location;
            } else if (key.length === 1) {
                const upper = key.toUpperCase();
                keyCode = upper.charCodeAt(0);
                code = upper;
                keyValue = key;
            } else {
                keyCode = key.toUpperCase().charCodeAt(0);
                code = key;
                keyValue = key;
            }
        }

        return { key: keyValue, code, keyCode, location };
    };

    const simulateKeyEvent = (key, type) => {
        const { key: keyValue, code, keyCode, location } = resolveKeyDescriptor(key);

        if (typeof KeyboardEvent === "undefined") return;

        const eventOptions = {
            key: keyValue,
            code: code,
            keyCode: keyCode,
            which: keyCode,
            bubbles: true,
            cancelable: true
        };
        if (location != null) {
            eventOptions.location = location;
        }
        const event = new KeyboardEvent(type, eventOptions);

        const canvas = typeof document !== "undefined" ? document.querySelector("canvas") : null;
        if (canvas && typeof canvas.focus === "function") {
            canvas.focus();
            canvas.dispatchEvent(event);
        } else if (typeof document !== "undefined") {
            document.dispatchEvent(event);
        }
    };

    const sanitizeActionMeta = (actionMeta) => {
        if (!actionMeta || typeof actionMeta !== "object") return {};
        const allowedBehavior = new Set(["continuous", "discrete"]);
        const allowedInteraction = new Set(["tap", "hold", "repeat"]);
        const allowedControlSpace = new Set(["vector", "rate", "magnitude"]);
        const allowedActivation = new Set(["hold", "latch"]);
        const allowedDirectionMode = new Set(["vector", "cardinal"]);
        const allowedGranularity = new Set(["fine", "coarse"]);
        const allowedPairPosition = new Set(["left", "right"]);

        const sanitized = {};
        Object.entries(actionMeta).forEach(([action, meta]) => {
            if (!meta || typeof meta !== "object") return;
            const cleaned = {};
            Object.entries(meta).forEach(([key, value]) => {
                if (key === "behavior" && allowedBehavior.has(value)) cleaned[key] = value;
                else if (key === "interaction" && allowedInteraction.has(value)) cleaned[key] = value;
                else if (key === "simultaneous" && typeof value === "boolean") cleaned[key] = value;
                else if (key === "control_space" && allowedControlSpace.has(value)) cleaned[key] = value;
                else if (key === "activation" && allowedActivation.has(value)) cleaned[key] = value;
                else if (key === "direction_mode" && allowedDirectionMode.has(value)) cleaned[key] = value;
                else if (key === "granularity" && allowedGranularity.has(value)) cleaned[key] = value;
                else if (key === "pair_id" && typeof value === "string") cleaned[key] = value;
                else if (key === "pair_position" && allowedPairPosition.has(value)) cleaned[key] = value;
                else if (key === "kind" && typeof value === "string") cleaned[key] = value;
            });
            if (Object.keys(cleaned).length) {
                sanitized[action] = cleaned;
            }
        });
        return sanitized;
    };

    const extractMeta = (spec, kind) => {
        const meta = {};
        if (spec && typeof spec === "object") {
            ["behavior", "interaction", "simultaneous", "control_space", "activation", "direction_mode", "granularity", "pair_id", "pair_position"].forEach((field) => {
                if (field in spec) meta[field] = spec[field];
            });
        }
        if (kind) meta.kind = kind;
        return meta;
    };

    const extractActionKeys = (spec) => {
        if (spec && typeof spec === "object") {
            if ("keys" in spec) return spec.keys;
            if ("key" in spec) return spec.key;
        }
        return spec;
    };

    const selectSingleKey = (keys) => {
        if (!keys || typeof keys !== "object") return null;
        const order = ["up", "right", "down", "left"];
        for (let i = 0; i < order.length; i += 1) {
            const key = keys[order[i]];
            if (key) return key;
        }
        return null;
    };

    const axisPriority = (axis) => {
        const priority = axis.priority;
        const priorityScore = priority === "primary" ? 2 : priority === "secondary" ? 1 : 0;
        const controlSpace = axis.control_space;
        const controlScore = controlSpace === "vector" ? 2 : controlSpace === "rate" ? 1 : 0;
        return [priorityScore, controlScore];
    };

    const extractBindingsFromAxesActions = (data) => {
        if (!data || typeof data !== "object") return null;
        const axes = data.axes;
        const actions = data.actions;
        if (!Array.isArray(axes) && (typeof actions !== "object" || actions === null)) {
            return null;
        }

        const bindings = {};
        let actionMeta = {};

        if (actions && typeof actions === "object") {
            Object.entries(actions).forEach(([role, spec]) => {
                const keys = extractActionKeys(spec);
                if (!keys) return;
                bindings[role] = keys;
                const meta = extractMeta(spec, "button");
                if (Object.keys(meta).length) {
                    actionMeta[role] = meta;
                }
            });
        }

        const movementAxes = [];
        const aimAxes = [];

        if (Array.isArray(axes)) {
            axes.forEach((axis) => {
                if (!axis || typeof axis !== "object") return;
                const keys = axis.keys;
                if (!keys || typeof keys !== "object") return;
                const usage = axis.usage;
                const controlSpace = axis.control_space;
                if (usage !== "movement" && usage !== "aim") return;

                if (controlSpace === "magnitude") {
                    if (bindings.magnitude) return;
                    const magKey = selectSingleKey(keys);
                    if (!magKey) return;
                    bindings.magnitude = magKey;
                    const magMeta = extractMeta(axis, "button");
                    magMeta.control_space = "magnitude";
                    actionMeta.magnitude = magMeta;
                    return;
                }

                if (usage === "movement") movementAxes.push(axis);
                if (usage === "aim") aimAxes.push(axis);
            });
        }

        const buildAxisMapping = (axis) => {
            const keys = axis.keys;
            const meta = extractMeta(axis, "axis");
            if (axis.control_space) meta.control_space = axis.control_space;
            return { keys, meta };
        };

        const compareAxis = (a, b) => {
            const [ap, ac] = axisPriority(a);
            const [bp, bc] = axisPriority(b);
            if (ap !== bp) return bp - ap;
            return bc - ac;
        };

        if (movementAxes.length) {
            movementAxes.sort(compareAxis);
            const move = buildAxisMapping(movementAxes[0]);
            bindings.move = move.keys;
            if (Object.keys(move.meta).length) actionMeta.move = move.meta;

            if (aimAxes.length) {
                aimAxes.sort(compareAxis);
                const aim = buildAxisMapping(aimAxes[0]);
                bindings.aim = aim.keys;
                if (Object.keys(aim.meta).length) actionMeta.aim = aim.meta;
            }
        } else if (aimAxes.length) {
            aimAxes.sort(compareAxis);
            const move = buildAxisMapping(aimAxes[0]);
            bindings.move = move.keys;
            if (Object.keys(move.meta).length) actionMeta.move = move.meta;

            if (aimAxes.length > 1) {
                const aim = buildAxisMapping(aimAxes[1]);
                bindings.aim = aim.keys;
                if (Object.keys(aim.meta).length) actionMeta.aim = aim.meta;
            }
        }

        actionMeta = sanitizeActionMeta(actionMeta);
        return { bindings, actionMeta };
    };

    const resolveBindingsAndMeta = (config = {}) => {
        let bindings = config.bindings || {};
        let actionMeta = config.actionMeta || config.action_meta || {};

        let analysis = null;
        if (Array.isArray(config.axes) || (config.actions && typeof config.actions === "object")) {
            analysis = { axes: config.axes || [], actions: config.actions || {} };
        } else if (bindings && typeof bindings === "object" && (bindings.axes || bindings.actions)) {
            analysis = { axes: bindings.axes || [], actions: bindings.actions || {} };
        } else if (actionMeta && typeof actionMeta === "object" && (actionMeta.axes || actionMeta.actions)) {
            analysis = { axes: actionMeta.axes || [], actions: actionMeta.actions || {} };
        }

        if (analysis) {
            const extracted = extractBindingsFromAxesActions(analysis);
            if (extracted) {
                bindings = extracted.bindings || {};
                actionMeta = extracted.actionMeta || {};
            }
        }

        if (!bindings || typeof bindings !== "object") bindings = {};
        if (!actionMeta || typeof actionMeta !== "object") actionMeta = {};

        return { bindings, actionMeta };
    };

    const parseKeys = (keys) => {
        let keyMap = { left: null, right: null, up: null, down: null, key: null };

        if (Array.isArray(keys)) {
            if (keys.length === 2) {
                keyMap.left = keys[0] || null;
                keyMap.right = keys[1] || null;
            } else if (keys.length === 1) {
                keyMap.key = keys[0];
            } else {
                keyMap.left = keys[0] || null;
                keyMap.right = keys[1] || null;
                keyMap.up = keys[2] || null;
                keyMap.down = keys[3] || null;
            }
        } else if (keys && typeof keys === "object") {
            keyMap.left = keys.left || null;
            keyMap.right = keys.right || null;
            keyMap.up = keys.up || null;
            keyMap.down = keys.down || null;
            if (keys.key) keyMap.key = keys.key;
        } else if (typeof keys === "string") {
            keyMap.key = keys;
        }

        return keyMap;
    };

    const createNipple = (element, keys) => {
        if (typeof nipplejs === "undefined") {
            throw new Error(
                "[touchpad_controls] nipplejs is required to create joystick controls. " +
                "Include nipplejs before touchpad-controls.js."
            );
        }

        const options = {
            zone: element,
            mode: "static",
            position: { top: "50%", left: "50%" },
            color: "gray",
            size: 120,
            threshold: 0.25
        };

        const keyMap = parseKeys(keys);

        const hasLeft = keyMap.left != null;
        const hasRight = keyMap.right != null;
        const hasUp = keyMap.up != null;
        const hasDown = keyMap.down != null;
        const hasSingleKey = keyMap.key != null;

        if ((hasLeft || hasRight) && !(hasUp || hasDown)) {
            options.lockX = true;
        } else if ((hasUp || hasDown) && !(hasLeft || hasRight)) {
            options.lockY = true;
        } else if (hasSingleKey) {
            options.lockX = true;
            options.lockY = true;
        } else {
            options.lockX = false;
            options.lockY = false;
        }

        const manager = nipplejs.create(options);

        const activeKeys = {};
        const activeDirections = new Set();

        const getDirections = (direction) => {
            if (!direction) return [];
            const directions = [];
            if (direction.x === "left" || direction.x === "right") {
                directions.push(direction.x);
            }
            if (direction.y === "up" || direction.y === "down") {
                directions.push(direction.y);
            }
            return directions;
        };

        manager.on("start", () => {
            element.classList.add("is-active");
        });

        const syncDirections = (directionsSet) => {
            const toRelease = [];
            activeDirections.forEach((direction) => {
                if (!directionsSet.has(direction)) {
                    toRelease.push(direction);
                }
            });

            toRelease.forEach((direction) => {
                const key = keyMap[direction];
                if (key && activeKeys[key]) {
                    simulateKeyEvent(key, "keyup");
                    activeKeys[key] = false;
                }
                activeDirections.delete(direction);
            });

            directionsSet.forEach((direction) => {
                if (activeDirections.has(direction)) return;
                const key = keyMap[direction];
                if (!key) return;
                if (!activeKeys[key]) {
                    simulateKeyEvent(key, "keydown");
                    activeKeys[key] = true;
                }
                activeDirections.add(direction);
            });
        };

        manager.on("dir", (evt, data) => {
            const directions = getDirections(data && data.direction);
            if (!directions.length) return;
            syncDirections(new Set(directions));
        });

        const releaseAllKeys = () => {
            Object.keys(activeKeys).forEach((key) => {
                if (activeKeys[key]) {
                    simulateKeyEvent(key, "keyup");
                    activeKeys[key] = false;
                }
            });
            activeDirections.clear();
        };

        manager.on("move", (evt, data) => {
            if (!data || !data.direction) {
                releaseAllKeys();
                return;
            }

            const currentDirections = new Set();
            if (data.direction.x) currentDirections.add(data.direction.x);
            if (data.direction.y) currentDirections.add(data.direction.y);

            syncDirections(currentDirections);
        });

        manager.on("end", () => {
            releaseAllKeys();
            element.classList.remove("is-active");
        });

        return manager;
    };

    const createButton = (element, key) => {
        const keys = Array.isArray(key) ? key.filter((k) => k != null) : [key];
        if (!keys.length) return;

        let isActive = false;

        const press = (event) => {
            if (event && typeof event.preventDefault === "function") {
                event.preventDefault();
            }
            if (isActive) return;
            isActive = true;
            element.classList.add("is-active");
            keys.forEach((k) => simulateKeyEvent(k, "keydown"));
        };

        const release = (event) => {
            if (event && typeof event.preventDefault === "function") {
                event.preventDefault();
            }
            if (!isActive) return;
            isActive = false;
            element.classList.remove("is-active");
            keys.forEach((k) => simulateKeyEvent(k, "keyup"));
        };

        const handleMouseDown = (event) => {
            press(event);
            const handleMouseUp = (e) => {
                release(e);
                window.removeEventListener("mouseup", handleMouseUp);
            };
            window.addEventListener("mouseup", handleMouseUp);
        };

        const handleTouchStart = (event) => {
            press(event);
            const handleTouchEndOrCancel = (e) => {
                release(e);
                window.removeEventListener("touchend", handleTouchEndOrCancel);
                window.removeEventListener("touchcancel", handleTouchEndOrCancel);
            };
            window.addEventListener("touchend", handleTouchEndOrCancel);
            window.addEventListener("touchcancel", handleTouchEndOrCancel);
        };

        element.addEventListener("mousedown", handleMouseDown);
        element.addEventListener("touchstart", handleTouchStart, {
            passive: false
        });

        element.addEventListener("mouseup", release);
        element.addEventListener("mouseleave", release);
        element.addEventListener("touchend", release);
        element.addEventListener("touchcancel", release);
    };

    const createTouchpadControls = (config = {}) => {
        if (typeof document === "undefined") {
            throw new Error("[touchpad_controls] document is required to render controls.");
        }

        injectTouchpadStyles();

        const root = config.root || document.body || document.documentElement;
        const baseTheme = normalizeTheme(config.theme);
        const buttons = Array.isArray(config.buttons) ? config.buttons : [];

        const touchpads = [];
        const nippleManagers = [];

        buttons.forEach((btn) => {
            if (!btn) return;

            const theme = mergeTheme(baseTheme, btn.theme);
            const touchpad = document.createElement("div");
            touchpad.id = btn.id || "";
            touchpad.className = "touchpad";

            if (btn.className) {
                touchpad.className += " " + btn.className;
            }
            if (Array.isArray(btn.classList)) {
                btn.classList.forEach((cls) => {
                    if (cls) touchpad.classList.add(cls);
                });
            }

            let type = btn.type;
            if (!type) {
                if (
                    (Array.isArray(btn.keys) && btn.keys.length > 1) ||
                    (btn.keys && typeof btn.keys === "object" && !Array.isArray(btn.keys))
                ) {
                    type = "joystick";
                } else {
                    type = "button";
                }
            }

            const labelMode = btn.labelMode || theme.labelMode || "none";
            const labelText = type === "button" ? resolveLabelText(btn, labelMode) : "";
            if (labelText) {
                const labelEl = document.createElement("span");
                labelEl.className = "touchpad-label";
                labelEl.textContent = labelText;
                touchpad.classList.add("touchpad--label");
                touchpad.appendChild(labelEl);
            }

            const ariaLabel = btn.label != null
                ? String(btn.label)
                : (labelText || (typeof btn.keys === "string" ? keyLabel(btn.keys) : ""));
            if (ariaLabel) {
                touchpad.setAttribute("aria-label", ariaLabel);
            }

            const sectionName = btn.section;
            const section = sectionName && sections[sectionName] ? sections[sectionName] : null;

            safeEntries(section).forEach(([key, value]) => {
                touchpad.style[key] = value;
            });

            const posName = btn.position;
            const buttonPosition =
                posName && buttonPositions[posName]
                    ? buttonPositions[posName]
                    : null;

            if (section && buttonPosition) {
                safeEntries(buttonPosition).forEach(([key, value]) => {
                    const base = section[key] || "0px";
                    touchpad.style[key] = `calc(${base} + ${value})`;
                });
            }

            if (btn.top != null) {
                touchpad.style.top = formatCssValue(btn.top);
            }
            if (btn.left != null) {
                touchpad.style.left = formatCssValue(btn.left);
            }
            if (btn.x != null) {
                touchpad.style.left = formatCssValue(btn.x);
            }
            if (btn.y != null) {
                touchpad.style.top = formatCssValue(btn.y);
            }

            safeEntries(btn.style).forEach(([key, value]) => {
                if (value != null) {
                    touchpad.style[key] = formatCssValue(value);
                }
            });

            applyThemeVars(touchpad, theme);

            const showIcon = labelMode !== "text" && labelMode !== "key";
            if (showIcon) {
                const icon = resolveIcon(btn, theme);
                if (icon) {
                    touchpad.style.setProperty("--touchpad-icon", icon);
                }
            }

            root.appendChild(touchpad);

            touchpad.dataset.touchpadType = type;
            if (type === "joystick") {
                touchpad.classList.add("touchpad--joystick");
            } else {
                touchpad.classList.add("touchpad--button");
            }

            const tp = { element: touchpad, keys: btn.keys, type: type };
            touchpads.push(tp);
        });

        touchpads.forEach((tp) => {
            if (tp.type === "joystick") {
                const manager = createNipple(tp.element, tp.keys);
                if (manager) nippleManagers.push(manager);
            } else {
                createButton(tp.element, tp.keys);
            }
        });

        const destroy = () => {
            nippleManagers.forEach((manager) => {
                if (manager && typeof manager.destroy === "function") {
                    manager.destroy();
                }
            });

            touchpads.forEach((tp) => {
                const el = tp.element;
                if (el && el.parentNode) {
                    el.parentNode.removeChild(el);
                }
            });
        };

        return { touchpads, destroy };
    };

    const getSafeAreaInsets = (viewport) => {
        if (viewport && viewport.safeArea) {
            return {
                top: viewport.safeArea.top || 0,
                right: viewport.safeArea.right || 0,
                bottom: viewport.safeArea.bottom || 0,
                left: viewport.safeArea.left || 0
            };
        }

        if (typeof document === "undefined") {
            return { top: 0, right: 0, bottom: 0, left: 0 };
        }

        const measure = document.createElement("div");
        measure.style.cssText = [
            "position: fixed",
            "top: 0",
            "left: 0",
            "right: 0",
            "bottom: 0",
            "padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)",
            "pointer-events: none",
            "visibility: hidden"
        ].join(";");

        const root = document.body || document.documentElement;
        root.appendChild(measure);
        const style = window.getComputedStyle(measure);
        const insets = {
            top: parseFloat(style.paddingTop) || 0,
            right: parseFloat(style.paddingRight) || 0,
            bottom: parseFloat(style.paddingBottom) || 0,
            left: parseFloat(style.paddingLeft) || 0
        };
        root.removeChild(measure);
        return insets;
    };

    const normalizeBindings = (bindings = {}) => {
        const move = parseKeys(bindings.move || bindings.movement || null);
        const aim = parseKeys(bindings.aim || bindings.look || null);

        const jump = bindings.jump || null;
        const magnitude = bindings.magnitude || null;
        const primary = bindings.primary || bindings.shoot || bindings.fire || null;
        const secondary = bindings.secondary || bindings.attack || null;
        const tertiary = bindings.tertiary || (bindings.shoot && bindings.shoot !== primary ? bindings.shoot : null) || null;
        const modifier = bindings.modifier || bindings.run || null;

        return { move, aim, jump, magnitude, primary, secondary, tertiary, modifier };
    };

    const normalizeActionMeta = (actionMeta = {}) => {
        if (!actionMeta || typeof actionMeta !== "object") return {};
        return actionMeta;
    };

    const hasDirectionalKeys = (keyMap) => !!(keyMap && (keyMap.left || keyMap.right || keyMap.up || keyMap.down));

    const deriveAxisKeys = (keyMap, meta) => {
        if (!keyMap || !meta || typeof meta !== "object") return keyMap;
        const controlSpace = meta.control_space;
        if (controlSpace === "rate") {
            if (!keyMap.left && !keyMap.right) return keyMap;
            return {
                left: keyMap.left || null,
                right: keyMap.right || null,
                up: null,
                down: null
            };
        }
        if (controlSpace === "magnitude") {
            if (!keyMap.up && !keyMap.down) return keyMap;
            return {
                left: null,
                right: null,
                up: keyMap.up || null,
                down: keyMap.down || null
            };
        }
        return keyMap;
    };

    const chooseLayout = (bindings, preferredLayout, actionMeta = {}) => {
        if (preferredLayout && preferredLayout !== "auto") return preferredLayout;

        const moveMeta = actionMeta && actionMeta.move ? actionMeta.move : null;
        const moveKeys = deriveAxisKeys(bindings.move, moveMeta);
        const hasMove = hasDirectionalKeys(moveKeys);
        const hasAim = hasDirectionalKeys(bindings.aim);

        if (hasAim) return "dual-stick";
        if (hasMove) {
            const isCardinal = moveMeta && moveMeta.direction_mode === "cardinal";
            const isDiscrete = moveMeta && (
                moveMeta.behavior === "discrete" ||
                moveMeta.activation === "latch" ||
                moveMeta.granularity === "coarse"
            );
            const requiresChord = moveMeta && moveMeta.simultaneous === true;
            const hasVertical = !!(moveKeys.up || moveKeys.down);
            if (!requiresChord && (isDiscrete || (isCardinal && hasVertical))) {
                return "digital-dpad";
            }
            if (moveKeys.up || moveKeys.down) return "fast-platformer";
            return "safe-platformer";
        }
        return "runner";
    };

    const getLayoutMetrics = (viewport, options = {}) => {
        const width = viewport && Number.isFinite(viewport.width)
            ? viewport.width
            : (typeof window !== "undefined" ? window.innerWidth : 0);
        const height = viewport && Number.isFinite(viewport.height)
            ? viewport.height
            : (typeof window !== "undefined" ? window.innerHeight : 0);

        const safeArea = getSafeAreaInsets(viewport);
        const minDim = Math.max(1, Math.min(width, height));
        const orientation = width >= height ? "landscape" : "portrait";

        const baseSize = clamp(minDim * 0.17, 64, 112);
        const actionSize = clamp(minDim * 0.14, 56, 96);
        const smallActionSize = clamp(minDim * 0.12, MIN_TOUCH_TARGET, 80);
        const miniActionSize = clamp(minDim * 0.1, MIN_TOUCH_TARGET, 72);
        const spacing = clamp(minDim * 0.03, 10, 20);
        const edgePadding = clamp(minDim * 0.05, 16, 32);
        const verticalOffset = orientation === "portrait"
            ? clamp(minDim * 0.04, 8, 16)
            : clamp(minDim * 0.02, 6, 12);

        const bottomY = height - safeArea.bottom - edgePadding;

        return {
            width,
            height,
            orientation,
            safeArea,
            minDim,
            baseSize,
            actionSize,
            smallActionSize,
            miniActionSize,
            spacing,
            edgePadding,
            verticalOffset,
            bottomY
        };
    };

    const clampPosition = (pos, size, metrics) => {
        const minX = metrics.safeArea.left + metrics.edgePadding + size / 2;
        const maxX = metrics.width - metrics.safeArea.right - metrics.edgePadding - size / 2;
        const minY = metrics.safeArea.top + metrics.edgePadding + size / 2;
        const maxY = metrics.height - metrics.safeArea.bottom - metrics.edgePadding - size / 2;
        return {
            x: clamp(pos.x, minX, maxX),
            y: clamp(pos.y, minY, maxY)
        };
    };

    const makeButton = (spec) => {
        const baseStyle = {
            width: spec.size,
            height: spec.size,
            transform: "translate(-50%, -50%)"
        };

        return {
            id: spec.id,
            label: spec.label || "",
            keys: spec.keys,
            x: spec.x,
            y: spec.y,
            size: spec.size,
            role: spec.role,
            type: spec.type,
            meta: spec.meta || null,
            icon: spec.icon || null,
            classList: spec.classList || [],
            style: Object.assign(baseStyle, spec.style || {})
        };
    };

    const getActionSize = (sizes, role) => {
        if (!sizes) return 0;
        return sizes[role] || sizes.secondary || sizes.primary || 0;
    };

    const findPairedActions = (actions = []) => {
        const groups = new Map();
        actions.forEach((action) => {
            const meta = action && action.meta ? action.meta : null;
            const pairId = meta && meta.pair_id;
            if (!pairId) return;
            if (!groups.has(pairId)) groups.set(pairId, []);
            groups.get(pairId).push(action);
        });

        for (const [pairId, group] of groups.entries()) {
            if (group.length < 2) continue;
            let left = group.find((action) => action.meta && action.meta.pair_position === "left");
            let right = group.find((action) => action.meta && action.meta.pair_position === "right");
            if (!left || !right) {
                left = group[0];
                right = group[1];
            }
            if (left === right) continue;
            return { pairId, left, right };
        }
        return null;
    };

    const buildActionCluster = (anchor, actions, sizes, metrics) => {
        const buttons = [];
        if (!actions.length) return buttons;

        const pair = findPairedActions(actions);
        if (!pair) {
            const primary = actions[0];
            const primarySize = sizes.primary;
            const primaryPos = clampPosition(anchor, primarySize, metrics);
            buttons.push(makeButton({
                id: primary.role,
                keys: primary.keys,
                role: primary.role,
                x: primaryPos.x,
                y: primaryPos.y,
                size: primarySize,
                meta: primary.meta || null,
                classList: ["touchpad-role-" + primary.role]
            }));

            if (actions[1]) {
                const secondary = actions[1];
                const secondarySize = sizes.secondary;
                const secondaryPos = clampPosition({
                    x: anchor.x,
                    y: anchor.y - (primarySize / 2 + metrics.spacing + secondarySize / 2)
                }, secondarySize, metrics);
                buttons.push(makeButton({
                    id: secondary.role,
                    keys: secondary.keys,
                    role: secondary.role,
                    x: secondaryPos.x,
                    y: secondaryPos.y,
                    size: secondarySize,
                    meta: secondary.meta || null,
                    classList: ["touchpad-role-" + secondary.role]
                }));
            }

            if (actions[2]) {
                const tertiary = actions[2];
                const tertiarySize = sizes.tertiary;
                const tertiaryPos = clampPosition({
                    x: anchor.x - (primarySize / 2 + metrics.spacing + tertiarySize / 2),
                    y: anchor.y - primarySize * 0.2
                }, tertiarySize, metrics);
                buttons.push(makeButton({
                    id: tertiary.role,
                    keys: tertiary.keys,
                    role: tertiary.role,
                    x: tertiaryPos.x,
                    y: tertiaryPos.y,
                    size: tertiarySize,
                    meta: tertiary.meta || null,
                    classList: ["touchpad-role-" + tertiary.role]
                }));
            }

            if (actions[3]) {
                const modifier = actions[3];
                const modifierSize = sizes.modifier;
                const modifierPos = clampPosition({
                    x: anchor.x - (primarySize / 2 + metrics.spacing + modifierSize / 2),
                    y: anchor.y - (primarySize / 2 + metrics.spacing + modifierSize / 2)
                }, modifierSize, metrics);
                buttons.push(makeButton({
                    id: modifier.role,
                    keys: modifier.keys,
                    role: modifier.role,
                    x: modifierPos.x,
                    y: modifierPos.y,
                    size: modifierSize,
                    meta: modifier.meta || null,
                    classList: ["touchpad-role-" + modifier.role]
                }));
            }

            return buttons;
        }

        const used = new Set();
        const place = (action, pos, size) => {
            if (!action || used.has(action)) return;
            used.add(action);
            const clamped = clampPosition(pos, size, metrics);
            buttons.push(makeButton({
                id: action.role,
                keys: action.keys,
                role: action.role,
                x: clamped.x,
                y: clamped.y,
                size,
                meta: action.meta || null,
                classList: ["touchpad-role-" + action.role]
            }));
        };

        const primary = actions.find((action) => action.role === "primary" && action !== pair.left && action !== pair.right)
            || actions.find((action) => action !== pair.left && action !== pair.right);
        const primarySize = primary ? getActionSize(sizes, primary.role) : 0;

        const leftAction = pair.left;
        const rightAction = pair.right;
        const leftSize = getActionSize(sizes, leftAction.role);
        const rightSize = getActionSize(sizes, rightAction.role);
        const rowHeight = Math.max(leftSize, rightSize);
        const rowWidth = leftSize + rightSize + metrics.spacing;

        const minCenterX = metrics.safeArea.left + metrics.edgePadding + rowWidth / 2;
        const maxCenterX = metrics.width - metrics.safeArea.right - metrics.edgePadding - rowWidth / 2;
        const centerX = clamp(anchor.x, minCenterX, maxCenterX);

        let primaryPos = null;
        if (primary) {
            primaryPos = clampPosition({ x: centerX, y: anchor.y }, primarySize, metrics);
            place(primary, primaryPos, primarySize);
        }

        const baseY = primaryPos ? primaryPos.y : anchor.y;
        const rowY = primaryPos
            ? baseY - (primarySize / 2 + metrics.spacing + rowHeight / 2)
            : baseY;

        const leftX = centerX - rowWidth / 2 + leftSize / 2;
        const rightX = centerX + rowWidth / 2 - rightSize / 2;
        place(leftAction, { x: leftX, y: rowY }, leftSize);
        place(rightAction, { x: rightX, y: rowY }, rightSize);

        let stackY = rowY - rowHeight / 2 - metrics.spacing;
        actions.forEach((action) => {
            if (used.has(action)) return;
            const size = getActionSize(sizes, action.role);
            place(action, { x: centerX, y: stackY - size / 2 }, size);
            stackY = stackY - size - metrics.spacing;
        });

        return buttons;
    };

    const buildButtonsForLayout = (layout, bindings, metrics, actionMeta) => {
        const buttons = [];
        const actions = [];
        const roleOrder = ["magnitude", "jump", "primary", "secondary", "tertiary", "modifier"];
        const roleBaseScore = {
            magnitude: 5,
            jump: 4,
            primary: 3,
            secondary: 2,
            tertiary: 1,
            modifier: 1
        };

        const moveMeta = actionMeta && actionMeta.move ? actionMeta.move : null;
        const moveKeys = deriveAxisKeys(bindings.move, moveMeta);

        const usedKeys = new Set();
        const addAction = (role, keys) => {
            if (!keys) return;
            const signature = JSON.stringify(keys);
            if (usedKeys.has(signature)) return;
            usedKeys.add(signature);
            actions.push({
                role,
                keys,
                meta: actionMeta && actionMeta[role] ? actionMeta[role] : null
            });
        };

        roleOrder.forEach((role) => addAction(role, bindings[role]));

        actions.forEach((action, index) => {
            const meta = action.meta || {};
            let score = roleBaseScore[action.role] || 0;
            if (meta.behavior === "discrete") score += 1;
            if (meta.interaction === "tap") score += 1;
            if (meta.simultaneous === true) score += 1;
            if (meta.control_space === "magnitude") score += 2;
            if (meta.behavior === "continuous" && meta.interaction === "hold" && meta.simultaneous === false) {
                score -= 1;
            }
            action._score = score;
            action._index = index;
        });

        actions.sort((a, b) => {
            if (b._score !== a._score) return b._score - a._score;
            return a._index - b._index;
        });

        const leftAnchor = {
            x: metrics.safeArea.left + metrics.edgePadding + metrics.baseSize / 2,
            y: metrics.bottomY - metrics.baseSize / 2 - metrics.verticalOffset
        };
        const rightAnchor = {
            x: metrics.width - metrics.safeArea.right - metrics.edgePadding - metrics.baseSize / 2,
            y: metrics.bottomY - metrics.baseSize / 2 - metrics.verticalOffset
        };

        if (!actions.length && !hasDirectionalKeys(moveKeys) && !hasDirectionalKeys(bindings.aim)) {
            return buttons;
        }

        if (layout === "digital-dpad") {
            if (hasDirectionalKeys(moveKeys)) {
                const dpadSize = clamp(metrics.baseSize * 0.5, MIN_TOUCH_TARGET, metrics.baseSize * 0.75);
                const dpadGap = clamp(dpadSize * 0.2, 6, 14);
                const offset = dpadSize + dpadGap;
                const radius = offset + dpadSize / 2;
                const minCenterX = metrics.safeArea.left + metrics.edgePadding + radius;
                const maxCenterX = metrics.width - metrics.safeArea.right - metrics.edgePadding - radius;
                const minCenterY = metrics.safeArea.top + metrics.edgePadding + radius;
                const maxCenterY = metrics.height - metrics.safeArea.bottom - metrics.edgePadding - radius;
                const center = {
                    x: clamp(leftAnchor.x, minCenterX, maxCenterX),
                    y: clamp(leftAnchor.y, minCenterY, maxCenterY)
                };
                const directions = [
                    { name: "up", x: center.x, y: center.y - offset },
                    { name: "down", x: center.x, y: center.y + offset },
                    { name: "left", x: center.x - offset, y: center.y },
                    { name: "right", x: center.x + offset, y: center.y }
                ];

                directions.forEach((dir) => {
                    const key = moveKeys[dir.name];
                    if (!key) return;
                    buttons.push(makeButton({
                        id: `move-${dir.name}`,
                        keys: key,
                        role: "move",
                        x: dir.x,
                        y: dir.y,
                        size: dpadSize,
                        type: "button",
                        meta: actionMeta && actionMeta.move ? actionMeta.move : null,
                        classList: ["touchpad-role-move", "touchpad--dpad", `touchpad-move-${dir.name}`]
                    }));
                });
            }

            const clusterButtons = buildActionCluster(
                rightAnchor,
                actions,
                {
                    primary: metrics.actionSize,
                    secondary: metrics.smallActionSize,
                    tertiary: metrics.smallActionSize,
                    modifier: metrics.miniActionSize
                },
                metrics
            );
            buttons.push(...clusterButtons);
        } else if (layout === "safe-platformer" || layout === "fast-platformer") {
            if (hasDirectionalKeys(moveKeys)) {
                const moveSize = metrics.baseSize;
                const movePos = clampPosition(leftAnchor, moveSize, metrics);
                buttons.push(makeButton({
                    id: "move",
                    keys: moveKeys,
                    role: "move",
                    x: movePos.x,
                    y: movePos.y,
                    size: moveSize,
                    meta: actionMeta && actionMeta.move ? actionMeta.move : null,
                    classList: ["touchpad-role-move"]
                }));
            }

            const clusterButtons = buildActionCluster(
                rightAnchor,
                actions,
                {
                    primary: metrics.actionSize,
                    secondary: metrics.smallActionSize,
                    tertiary: metrics.smallActionSize,
                    modifier: metrics.miniActionSize
                },
                metrics
            );
            buttons.push(...clusterButtons);
        } else if (layout === "dual-stick") {
            const moveSize = clamp(metrics.baseSize * 1.05, 64, 120);
            const aimSize = clamp(metrics.baseSize * 0.95, 60, 112);

            if (hasDirectionalKeys(moveKeys)) {
                const leftPos = clampPosition({
                    x: metrics.safeArea.left + metrics.edgePadding + moveSize / 2,
                    y: metrics.bottomY - moveSize / 2 - metrics.verticalOffset
                }, moveSize, metrics);
                buttons.push(makeButton({
                    id: "move",
                    keys: moveKeys,
                    role: "move",
                    x: leftPos.x,
                    y: leftPos.y,
                    size: moveSize,
                    meta: actionMeta && actionMeta.move ? actionMeta.move : null,
                    classList: ["touchpad-role-move"]
                }));
            }

            if (hasDirectionalKeys(bindings.aim)) {
                const rightPos = clampPosition({
                    x: metrics.width - metrics.safeArea.right - metrics.edgePadding - aimSize / 2,
                    y: metrics.bottomY - aimSize / 2 - metrics.verticalOffset
                }, aimSize, metrics);
                buttons.push(makeButton({
                    id: "aim",
                    keys: bindings.aim,
                    role: "aim",
                    x: rightPos.x,
                    y: rightPos.y,
                    size: aimSize,
                    meta: actionMeta && actionMeta.aim ? actionMeta.aim : null,
                    classList: ["touchpad-role-aim"]
                }));

                if (actions[0]) {
                    const fireSize = metrics.actionSize;
                    const firePos = clampPosition({
                        x: rightPos.x,
                        y: rightPos.y - (aimSize / 2 + metrics.spacing + fireSize / 2)
                    }, fireSize, metrics);
                    buttons.push(makeButton({
                        id: actions[0].role,
                        keys: actions[0].keys,
                        role: actions[0].role,
                        x: firePos.x,
                        y: firePos.y,
                        size: fireSize,
                        meta: actions[0].meta || null,
                        classList: ["touchpad-role-" + actions[0].role]
                    }));
                }
            }
        } else if (layout === "runner") {
            const actionCount = Math.min(actions.length || 1, 4);
            const slots = actionCount === 1
                ? [0.5]
                : actionCount === 2
                    ? [0.35, 0.65]
                    : actionCount === 3
                        ? [0.2, 0.5, 0.8]
                        : [0.15, 0.4, 0.6, 0.85];

            const size = metrics.actionSize;
            const availableWidth = metrics.width - metrics.safeArea.left - metrics.safeArea.right - metrics.edgePadding * 2;
            const bandY = metrics.bottomY - size / 2 - metrics.verticalOffset;

            for (let i = 0; i < actionCount; i += 1) {
                const action = actions[i] || actions[0] || { role: "primary", keys: bindings.primary };
                const x = metrics.safeArea.left + metrics.edgePadding + availableWidth * slots[i];
                const pos = clampPosition({ x, y: bandY }, size, metrics);
                buttons.push(makeButton({
                    id: action.role,
                    keys: action.keys,
                    role: action.role,
                    x: pos.x,
                    y: pos.y,
                    size: size,
                    meta: action.meta || null,
                    classList: ["touchpad-role-" + action.role]
                }));
            }
        }

        return buttons;
    };

    const buildLayout = (config = {}) => {
        const resolved = resolveBindingsAndMeta(config);
        const normalized = normalizeBindings(resolved.bindings || {});
        const actionMeta = normalizeActionMeta(resolved.actionMeta || {});
        const layout = chooseLayout(normalized, config.layout, actionMeta);
        const metrics = getLayoutMetrics(config.viewport, config);
        const buttons = buildButtonsForLayout(layout, normalized, metrics, actionMeta);
        return { layout, buttons, metrics, bindings: normalized, actionMeta };
    };

    const roundLayoutValue = (value) => {
        if (typeof value !== "number" || !Number.isFinite(value)) return value;
        return Math.round(value * 10) / 10;
    };

    const summarizeLayout = (layoutConfig) => {
        if (!layoutConfig || typeof layoutConfig !== "object") return null;
        const buttons = Array.isArray(layoutConfig.buttons) ? layoutConfig.buttons : [];
        return {
            layout: layoutConfig.layout || null,
            buttons: buttons.map((btn) => ({
                id: btn.id || null,
                role: btn.role || null,
                type: btn.type || (btn.keys && typeof btn.keys === "object" ? "joystick" : "button"),
                keys: btn.keys || null,
                x: roundLayoutValue(btn.x),
                y: roundLayoutValue(btn.y),
                size: roundLayoutValue(btn.size)
            }))
        };
    };

    const createGesturePrevention = (options = {}) => {
        if (typeof document === "undefined") return () => {};

        const extraExclusions = Array.isArray(options.excludeSelectors) ? options.excludeSelectors : [];
        const handler = (event) => {
            if (!event || typeof event.preventDefault !== "function") return;
            const target = event.target;
            if (!target) {
                event.preventDefault();
                return;
            }

            const tagName = target.tagName;
            const blockedTags = ["SELECT", "OPTION", "BUTTON", "INPUT", "TEXTAREA", "A"];
            if (tagName && blockedTags.includes(tagName)) return;

            if (extraExclusions.some((selector) => target.closest && target.closest(selector))) return;

            event.preventDefault();
        };

        document.addEventListener("touchmove", handler, { passive: false });
        document.addEventListener("touchstart", handler, { passive: false });
        document.addEventListener("gesturestart", handler);
        document.addEventListener("gesturechange", handler);
        document.addEventListener("gestureend", handler);

        return () => {
            document.removeEventListener("touchmove", handler);
            document.removeEventListener("touchstart", handler);
            document.removeEventListener("gesturestart", handler);
            document.removeEventListener("gesturechange", handler);
            document.removeEventListener("gestureend", handler);
        };
    };

    const create = (config = {}) => {
        const layoutConfig = buildLayout(config);
        if (config.debug && typeof console !== "undefined" && typeof console.info === "function") {
            console.info("[touchpad_controls] layout", summarizeLayout(layoutConfig));
        }
        const hasCustomButtons = Array.isArray(config.buttons) && config.buttons.length > 0;
        const buttons = hasCustomButtons ? config.buttons : layoutConfig.buttons;
        const root = config.root;

        if (config.preventGestures !== false) {
            const excludeSelectors = config.excludeSelectors || [];
            var removeGesturePrevention = createGesturePrevention({ excludeSelectors });
        }

        let instance = createTouchpadControls({ root, buttons });
        let resizeTimer = null;

        const rebuild = () => {
            if (instance && typeof instance.destroy === "function") {
                instance.destroy();
            }
            const nextLayout = buildLayout(config);
            if (config.debug && typeof console !== "undefined" && typeof console.info === "function") {
                console.info("[touchpad_controls] layout", summarizeLayout(nextLayout));
            }
            const nextButtons = hasCustomButtons ? config.buttons : nextLayout.buttons;
            instance = createTouchpadControls({ root, buttons: nextButtons });
        };

        const handleResize = () => {
            if (resizeTimer) window.clearTimeout(resizeTimer);
            resizeTimer = window.setTimeout(rebuild, 120);
        };

        if (config.responsive !== false && typeof window !== "undefined") {
            window.addEventListener("resize", handleResize);
        }

        return {
            layout: layoutConfig.layout,
            buttons,
            diagnostics: config.debug ? summarizeLayout(layoutConfig) : null,
            destroy: () => {
                if (resizeTimer && typeof window !== "undefined") {
                    window.clearTimeout(resizeTimer);
                }
                if (config.responsive !== false && typeof window !== "undefined") {
                    window.removeEventListener("resize", handleResize);
                }
                if (instance && typeof instance.destroy === "function") {
                    instance.destroy();
                }
                if (typeof removeGesturePrevention === "function") {
                    removeGesturePrevention();
                }
            },
            rebuild
        };
    };

    return {
        createTouchpadControls,
        create,
        buildLayout,
        chooseLayout,
        getLayoutMetrics,
        parseKeys,
        simulateKeyEvent,
        resolveKeyDescriptor,
        _internal: {
            buildButtonsForLayout,
            normalizeBindings,
            clampPosition,
            summarizeLayout,
            extractBindingsFromAxesActions,
            resolveBindingsAndMeta
        }
    };
}));

</script>
    <script>
    const touchBindings = {
        "jump": "Space",
        "primary": "ShiftLeft",
        "pause": "Escape",
        "move": {
            "left": "KeyA",
            "right": "KeyD"
        }
    };
    const touchActionMeta = {
        "jump": {
            "behavior": "discrete",
            "interaction": "tap",
            "simultaneous": true,
            "kind": "button"
        },
        "primary": {
            "behavior": "continuous",
            "interaction": "hold",
            "simultaneous": true,
            "kind": "button"
        },
        "pause": {
            "behavior": "discrete",
            "interaction": "tap",
            "simultaneous": false,
            "kind": "button"
        },
        "move": {
            "behavior": "continuous",
            "interaction": "hold",
            "simultaneous": false,
            "control_space": "vector",
            "activation": "hold",
            "direction_mode": "cardinal",
            "granularity": "fine",
            "kind": "axis"
        }
    };

    TouchpadControls.create({
        layout: "auto",
        bindings: touchBindings,
        actionMeta: touchActionMeta,
        debug: true,
    });
</script>
</body>
</html>