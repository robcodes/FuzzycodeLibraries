<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Koala vs Kangaroos Platformer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            background-color: #87CEEB;
        }
        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        #score-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Comic Sans MS', cursive, sans-serif;
            font-size: 36px;
            color: #ffcc00;
            text-shadow: 3px 3px 5px rgba(0, 0, 0, 0.7),
                         -1px -1px 0 #000,  
                          1px -1px 0 #000,
                         -1px 1px 0 #000,
                          1px 1px 0 #000;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 5px 20px;
            border-radius: 20px;
            z-index: 5;
        }
        @keyframes scorePopup {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }
        .score-animation {
            animation: scorePopup 0.5s ease;
        }
        #music-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 10px;
            color: white;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            z-index: 5;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s ease;
        }
        #music-controls:hover {
            background-color: rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
        }
        #music-title {
            margin-bottom: 5px;
            font-size: 14px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }
        #music-buttons {
            display: flex;
            justify-content: center;
            gap: 5px;
        }
        .music-button {
            background-color: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s ease;
        }
        .music-button:hover {
            background-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
        }
        .music-button:active {
            transform: scale(0.95);
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
        }
        #start-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ffcc00;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
        }
        #start-screen p {
            font-size: 24px;
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
        }
        #start-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #start-button:hover {
            background-color: #45a049;
        }
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
        }
        #game-over-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff6666;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
        }
        #restart-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-top: 20px;
        }
        #restart-button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="score-display">SCORE: 0</div>
        <div id="ui-container">
            <div id="health">Health: 3</div>
            <div id="hunger">Hunger: 100%</div>
        </div>
        <div id="music-controls">
            <div id="music-title">Music: Off</div>
            <div id="music-buttons">
                <button id="prev-track" class="music-button">‚èÆÔ∏è</button>
                <button id="play-pause" class="music-button">‚ñ∂Ô∏è</button>
                <button id="next-track" class="music-button">‚è≠Ô∏è</button>
            </div>
        </div>
        <div id="start-screen">
            <h1>Koala vs Kangaroos</h1>
            <p>Help Koala defeat the angry kangaroos by throwing boomerangs at them! Collect bamboo to stay alive as your hunger constantly decreases. Use the arrow keys to move and jump, and press SPACE to throw boomerangs.</p>
            <button id="start-button">Start Game</button>
        </div>
        <div id="game-over-screen">
            <h1>Game Over</h1>
            <div id="final-score">Score: 0</div>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Game elements
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const scoreElement = document.getElementById('score-display');
            const healthElement = document.getElementById('health');
            const hungerElement = document.getElementById('hunger');
            const startScreen = document.getElementById('start-screen');
            const startButton = document.getElementById('start-button');
            const gameOverScreen = document.getElementById('game-over-screen');
            const finalScoreElement = document.getElementById('final-score');
            const restartButton = document.getElementById('restart-button');

            // Game state
            let gameRunning = false;
            let score = 0;
            let scoreMultiplier = 1;
            let survivalTimer = 0;
            let health = 3;
            let hunger = 100; // Hunger meter (100 = full, 0 = starving)
            let explosions = [];
            let bamboos = [];
            let iceProjectiles = [];
            let isBossFight = false;
            let bossSpawned = false;
            let playerFrozen = false;
            let freezeTimer = 0;
            const freezeDuration = 180; // 3 seconds at 60 FPS

            // Canvas setup
            canvas.width = 800;
            canvas.height = 500;

            // Load assets
            const koalaImg = new Image();
            koalaImg.src = 'https://images.fuzzycode.dev/fast_ai?search=cartoon%20koala%20character%20side%20view&resize=64x64&transparency=true';

            const koalaFrozenImg = new Image();
            koalaFrozenImg.src = 'https://images.fuzzycode.dev/fast_ai?search=cartoon%20koala%20character%20frozen%20blue%20icy&resize=64x64&transparency=true';

            const kangarooImg = new Image();
            kangarooImg.src = 'https://aws.fuzzycode.dev/image_buddy_365day_cache/uploads/1c159ab3-db18-4cfe-847d-0342d6f3038c/angry cartoon kangaroo side view!resize_64x64_843c9713a7.png';

            const superKangarooImg = new Image();
            superKangarooImg.src = 'https://images.fuzzycode.dev/fast_ai?search=giant%20muscular%20kangaroo%20boss%20with%20ice%20powers%20cartoon&resize=128x128&transparency=true';

            const iceProjectileImg = new Image();
            iceProjectileImg.src = 'https://images.fuzzycode.dev/fast_ai?search=blue%20ice%20shard%20projectile&resize=32x32&transparency=true';

            const boomerangImg = new Image();
            boomerangImg.src = 'https://images.fuzzycode.dev/fast_ai?search=wooden%20boomerang&resize=32x32&transparency=true';

            const platformImg = new Image();
            platformImg.src = 'https://aws.fuzzycode.dev/image_buddy_365day_cache/uploads/1c159ab3-db18-4cfe-847d-0342d6f3038c/grass platform pixel art!resize_128x32.png';

            const bambooImg = new Image();
            bambooImg.src = 'https://aws.fuzzycode.dev/image_buddy_365day_cache/uploads/1c159ab3-db18-4cfe-847d-0342d6f3038c/bamboo shoot cartoon lush green!resize_48x48.png';

            const backgroundImg = new Image();
            backgroundImg.src = 'https://images.fuzzycode.dev/fast_ai?search=australian%20outback%20landscape%20cartoon&resize=800x500';

            // Explosion sprite sheet
            const explosionImg = new Image();
            explosionImg.src = 'https://images.fuzzycode.dev/fast_ai?search=cartoon%20explosion%20sprite%20sheet%20sequence&resize=384x64&transparency=true';

            // Sound effects
            const jumpSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=koala%20jump%20sound&duration=0.5&ext=.mp3');
            const throwSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=boomerang%20throw%20whoosh&duration=0.5&ext=.mp3');
            const hitSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=kangaroo%20hurt%20sound&duration=0.5&ext=.mp3');
            const hurtSound = new Audio('https://aws.fuzzycode.dev/generated_sound_effects/cartoonish-koala-cry.wav');
            const explosionSound = new Audio('https://aws.fuzzycode.dev/generated_sound_effects/boomerang-hit-then-explosion.wav');
            const eatSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=koala%20eating%20bamboo%20crunch&duration=0.5&ext=.mp3');
            const hungerSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=stomach%20growling%20hungry&duration=1&ext=.mp3');
            const bossAppearSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=dramatic%20boss%20appearance%20stinger&duration=2&ext=.mp3');
            const iceThrowSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=ice%20shard%20throw%20cold%20whoosh&duration=0.5&ext=.mp3');
            const freezeSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=freezing%20ice%20crystallization&duration=1&ext=.mp3');
            const unfreezeSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=ice%20breaking%20thawing&duration=0.5&ext=.mp3');
            const bossDamageSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=large%20kangaroo%20boss%20roar%20in%20pain&duration=1&ext=.mp3');
            const bossDefeatSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=epic%20boss%20defeat%20explosion&duration=2&ext=.mp3');

            // Game music tracks
            const musicTracks = [
                {
                    name: "Adventure",
                    audio: new Audio('https://sounds.fuzzycode.dev/music?prompt=upbeat%20australian%20adventure%20game%20music&duration=30&ext=.mp3'),
                    icon: "üå¥"
                },
                {
                    name: "Action",
                    audio: new Audio('https://sounds.fuzzycode.dev/music?prompt=energetic%20koala%20action%20game%20music&duration=30&ext=.mp3'),
                    icon: "‚ö°"
                },
                {
                    name: "Chill",
                    audio: new Audio('https://sounds.fuzzycode.dev/music?prompt=relaxing%20bamboo%20forest%20ambient%20music&duration=30&ext=.mp3'),
                    icon: "üéã"
                }
            ];

            // Set all tracks to loop
            musicTracks.forEach(track => {
                track.audio.loop = true;
            });

            let currentMusicIndex = 0;
            let isMusicPlaying = false;
            let currentMusic = musicTracks[currentMusicIndex].audio;

            // Player
            const player = {
                x: 100,
                y: 300,
                width: 64,
                height: 64,
                velocityX: 0,
                velocityY: 0,
                jumping: false,
                facingRight: true,
                canThrow: true,
                throwCooldown: 500, // ms
                lastThrowTime: 0,
                invincible: false,
                invincibleTimer: 0,
                isFlashing: false,
                flashTimer: 0
            };

            // Platforms
            const platforms = [
                { x: 0, y: 450, width: 300, height: 32 },
                { x: 350, y: 400, width: 200, height: 32 },
                { x: 600, y: 350, width: 200, height: 32 },
                { x: 200, y: 300, width: 150, height: 32 },
                { x: 400, y: 250, width: 150, height: 32 },
                { x: 100, y: 200, width: 150, height: 32 },
                { x: 600, y: 150, width: 200, height: 32 }
            ];

            // Enemies
            let enemies = [];

            // Boomerang
            let boomerang = null;

            // Controls
            const keys = {
                left: false,
                right: false,
                up: false,
                space: false
            };

            // Game constants
            const gravity = 0.5;
            const playerSpeed = 5;
            const jumpStrength = 12;
            const boomerangSpeed = 8;
            const boomerangReturnSpeed = 10;
            const enemySpeed = 2;
            const hungerDecreaseRate = 0.1; // How fast hunger decreases
            const hungerDamageThreshold = 20; // Below this hunger level, health decreases
            const hungerHealthDamageRate = 180; // Frames before taking damage when hungry
            let hungerDamageCounter = 0;
            const bambooSpawnRate = 300; // Frames between bamboo spawns
            let bambooSpawnCounter = 0;

            // Event listeners
            window.addEventListener('keydown', function(e) {
                // Don't process arrow keys if a music control button is focused
                const activeElement = document.activeElement;
                const isMusicControlFocused = activeElement && activeElement.classList.contains('music-button');

                if (!isMusicControlFocused) {
                    if (e.key === 'ArrowLeft') keys.left = true;
                    if (e.key === 'ArrowRight') keys.right = true;
                    if (e.key === 'ArrowUp') keys.up = true;
                    if (e.key === ' ') keys.space = true;
                }
            });

            window.addEventListener('keyup', function(e) {
                if (e.key === 'ArrowLeft') keys.left = false;
                if (e.key === 'ArrowRight') keys.right = false;
                if (e.key === 'ArrowUp') keys.up = false;
                if (e.key === ' ') keys.space = false;
            });

            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartGame);

            // Game functions
            function startGame() {
                gameRunning = true;
                startScreen.style.display = 'none';
                score = 0;
                health = 3;
                hunger = 100;
                updateUI();
                resetGame();
                if (isMusicPlaying) {
                    playCurrentMusic();
                }
                gameLoop();
            }

            function restartGame() {
                gameRunning = true;
                gameOverScreen.style.display = 'none';
                score = 0;
                health = 3;
                hunger = 100;
                updateUI();
                resetGame();
                if (isMusicPlaying) {
                    playCurrentMusic();
                }
                gameLoop();
            }

            function resetGame() {
                player.x = 100;
                player.y = 300;
                player.velocityX = 0;
                player.velocityY = 0;
                player.jumping = false;
                player.facingRight = true;

                enemies = [];
                boomerang = null;
                explosions = [];
                bamboos = [];
                iceProjectiles = [];
                hungerDamageCounter = 0;
                bambooSpawnCounter = 0;
                isBossFight = false;
                bossSpawned = false;
                playerFrozen = false;
                freezeTimer = 0;

                // Spawn initial enemies
                spawnEnemy();

                // Spawn initial bamboo
                spawnBamboo();
            }

            function gameLoop() {
                if (!gameRunning) return;

                update();
                render();

                requestAnimationFrame(gameLoop);
            }

            function update() {
                // Update survival timer and score multiplier
                if (gameRunning) {
                    survivalTimer++;

                    // Increase score just for surviving
                    if (survivalTimer % 60 === 0) { // Every second (assuming 60 FPS)
                        increaseScore(1 * scoreMultiplier);
                    }

                    // Increase multiplier over time
                    if (survivalTimer % 600 === 0) { // Every 10 seconds
                        scoreMultiplier += 0.1;
                    }

                    // Check if we should start boss fight
                    if (score >= 500 && !bossSpawned) {
                        startBossFight();
                    }
                    
                    // Safety check for boss - ensure it stays on screen
                    const bossIndex = enemies.findIndex(e => e.isBoss);
                    if (bossIndex !== -1) {
                        const boss = enemies[bossIndex];
                        
                        // If boss somehow got off screen, bring it back
                        if (boss.x < -50 || boss.x > canvas.width + 50 || 
                            boss.y < -100 || boss.y > canvas.height + 100) {
                            console.log("Boss recovery triggered - boss was off screen");
                            
                            // Find best platform for boss to stand on
                            let bestPlatform = platforms[0];
                            for (let platform of platforms) {
                                if (platform.width > bestPlatform.width) {
                                    bestPlatform = platform;
                                }
                            }
                            
                            // Reset boss to a safe position
                            boss.x = bestPlatform.x + bestPlatform.width/2 - boss.width/2;
                            boss.y = bestPlatform.y - boss.height;
                            boss.velocityY = 0;
                            boss.velocityX = boss.velocityX > 0 ? -3 : 3; // Ensure it's moving
                            boss.isEntering = false;
                            boss.currentPlatform = bestPlatform;
                            boss.aiState = 'patrol';
                        }
                    }
                }

                // Update freeze state if player is frozen
                if (playerFrozen) {
                    freezeTimer--;
                    if (freezeTimer <= 0) {
                        playerFrozen = false;
                        unfreezeSound.cloneNode().play();
                    }
                }

                // Update hunger
                hunger = Math.max(0, hunger - hungerDecreaseRate);

                // Check if hunger is below threshold and damage health
                if (hunger <= hungerDamageThreshold) {
                    hungerDamageCounter++;
                    if (hungerDamageCounter >= hungerHealthDamageRate) {
                        health--;
                        updateUI();
                        hungerSound.cloneNode().play();
                        hungerDamageCounter = 0;

                        if (health <= 0) {
                            gameOver();
                            return;
                        }
                    }
                }

                // Spawn bamboo periodically
                bambooSpawnCounter++;
                if (bambooSpawnCounter >= bambooSpawnRate) {
                    spawnBamboo();
                    bambooSpawnCounter = 0;
                }

                // Update explosions
                for (let i = explosions.length - 1; i >= 0; i--) {
                    explosions[i].update();
                    if (explosions[i].finished) {
                        explosions.splice(i, 1);
                    }
                }

                // Player movement - only if not frozen
                if (!playerFrozen) {
                    if (keys.left) {
                        player.velocityX = -playerSpeed;
                        player.facingRight = false;
                    } else if (keys.right) {
                        player.velocityX = playerSpeed;
                        player.facingRight = true;
                    } else {
                        player.velocityX = 0;
                    }

                    // Jumping
                    if (keys.up && !player.jumping) {
                        player.velocityY = -jumpStrength;
                        player.jumping = true;
                        jumpSound.cloneNode().play();
                    }
                } else {
                    // When frozen, player can't move
                    player.velocityX = 0;
                }

                // Apply gravity
                player.velocityY += gravity;

                // Update player position
                player.x += player.velocityX;
                player.y += player.velocityY;

                // Keep player in bounds
                if (player.x < 0) player.x = 0;
                if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
                
                // Update invincibility state
                if (player.invincible) {
                    player.invincibleTimer--;
                    if (player.invincibleTimer <= 0) {
                        player.invincible = false;
                        player.isFlashing = false;
                    }
                }

                // Check for platform collisions
                player.jumping = true;
                for (let platform of platforms) {
                    if (player.y + player.height > platform.y && 
                        player.y < platform.y + platform.height &&
                        player.x + player.width > platform.x && 
                        player.x < platform.x + platform.width) {

                        // Landing on platform
                        if (player.velocityY > 0 && player.y + player.height - player.velocityY <= platform.y) {
                            player.y = platform.y - player.height;
                            player.velocityY = 0;
                            player.jumping = false;
                        } 
                        // Hitting platform from below
                        else if (player.velocityY < 0 && player.y >= platform.y + platform.height) {
                            player.y = platform.y + platform.height;
                            player.velocityY = 0;
                        }
                    }
                }

                // Check if player fell off the screen
                if (player.y > canvas.height) {
                    health--;
                    updateUI();
                    hurtSound.cloneNode().play();
                    player.x = 100;
                    player.y = 300;
                    player.velocityY = 0;

                    if (health <= 0) {
                        gameOver();
                    }
                }

                // Throw boomerang - only if not frozen
                if (keys.space && player.canThrow && boomerang === null && !playerFrozen) {
                    throwBoomerang();
                    player.lastThrowTime = Date.now();
                    throwSound.cloneNode().play();
                }

                // Update boomerang
                if (boomerang !== null) {
                    // Rotate boomerang
                    boomerang.rotation += 0.2;

                    if (!boomerang.returning) {
                        // Outward flight
                        boomerang.x += boomerang.velocityX;

                        // Check if boomerang should return (reached max distance or edge of screen)
                        if ((boomerang.initialDirection > 0 && boomerang.x > boomerang.maxDistance) || 
                            (boomerang.initialDirection < 0 && boomerang.x < boomerang.maxDistance) ||
                            boomerang.x < 0 || 
                            boomerang.x > canvas.width) {

                            boomerang.returning = true;
                            // Play return sound
                            throwSound.cloneNode().play();
                        }

                        // Check for collisions with enemies
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            let enemy = enemies[j];

                            if (boomerang && enemy &&
                                boomerang.x + boomerang.width > enemy.x && 
                                boomerang.x < enemy.x + enemy.width && 
                                boomerang.y + boomerang.height > enemy.y && 
                                boomerang.y < enemy.y + enemy.height) {

                                // Handle boss differently
                                if (enemy.isBoss) {
                                    enemy.health--;
                                    bossDamageSound.cloneNode().play();

                                    // Start return journey
                                    boomerang.returning = true;

                                    // Increase score for hitting boss
                                    increaseScore(20 * scoreMultiplier);

                                    // If boss health is depleted
                                    if (enemy.health <= 0) {
                                        // Create explosion at boss position
                                        createExplosion(enemy.x, enemy.y);
                                        createExplosion(enemy.x + 50, enemy.y + 20);
                                        createExplosion(enemy.x + 25, enemy.y + 50);

                                        // Remove boss
                                        enemies.splice(j, 1);

                                        // End boss fight
                                        isBossFight = false;

                                        // Increase score for defeating boss
                                        increaseScore(500 * scoreMultiplier);

                                        // Play boss defeat sound
                                        bossDefeatSound.cloneNode().play();

                                        // Spawn regular enemies
                                        setTimeout(spawnEnemy, 2000);
                                        setTimeout(spawnEnemy, 4000);
                                    }
                                } else {
                                    // Regular enemy handling
                                    // Create explosion at enemy position
                                    createExplosion(enemy.x, enemy.y);

                                    // Remove enemy
                                    enemies.splice(j, 1);

                                    // Start return journey
                                    boomerang.returning = true;

                                    // Increase score for defeating enemy
                                    increaseScore(50 * scoreMultiplier);

                                    // Play hit sound
                                    hitSound.cloneNode().play();

                                    // Spawn a new enemy
                                    setTimeout(spawnEnemy, 2000);
                                }
                            }
                        }
                    } else {
                        // Return flight - move toward player
                        const dx = (player.x + player.width / 2) - (boomerang.x + boomerang.width / 2);
                        const dy = (player.y + player.height / 2) - (boomerang.y + boomerang.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > boomerangReturnSpeed) {
                            // Move toward player
                            boomerang.x += (dx / distance) * boomerangReturnSpeed;
                            boomerang.y += (dy / distance) * boomerangReturnSpeed;
                        } else {
                            // Check if close enough to catch
                            if (distance < 30) {
                                // Boomerang caught
                                boomerang = null;
                                return; // Exit early to prevent accessing null boomerang
                            } else {
                                // Final approach
                                boomerang.x += dx * 0.2;
                                boomerang.y += dy * 0.2;
                            }
                        }

                        // Check for collisions with enemies during return
                        if (boomerang) { // Additional null check
                            for (let j = enemies.length - 1; j >= 0; j--) {
                                let enemy = enemies[j];

                                if (enemy && boomerang &&
                                    boomerang.x + boomerang.width > enemy.x && 
                                    boomerang.x < enemy.x + enemy.width && 
                                    boomerang.y + boomerang.height > enemy.y && 
                                    boomerang.y < enemy.y + enemy.height) {

                                    // Handle boss differently
                                    if (enemy.isBoss) {
                                        enemy.health--;
                                        bossDamageSound.cloneNode().play();

                                        // Increase score for hitting boss
                                        increaseScore(20 * scoreMultiplier);

                                        // If boss health is depleted
                                        if (enemy.health <= 0) {
                                            // Create multiple explosions at boss position
                                            createExplosion(enemy.x, enemy.y);
                                            createExplosion(enemy.x + 50, enemy.y + 20);
                                            createExplosion(enemy.x + 25, enemy.y + 50);

                                            // Remove boss
                                            enemies.splice(j, 1);

                                            // End boss fight
                                            isBossFight = false;

                                            // Increase score for defeating boss
                                            increaseScore(500 * scoreMultiplier);

                                            // Play boss defeat sound
                                            bossDefeatSound.cloneNode().play();

                                            // Spawn regular enemies
                                            setTimeout(spawnEnemy, 2000);
                                            setTimeout(spawnEnemy, 4000);
                                        }
                                    } else {
                                        // Regular enemy handling
                                        // Create explosion at enemy position
                                        createExplosion(enemy.x, enemy.y);

                                        // Remove enemy
                                        enemies.splice(j, 1);

                                        // Increase score
                                        increaseScore(50 * scoreMultiplier);

                                        // Play hit sound
                                        hitSound.cloneNode().play();

                                        // Spawn a new enemy
                                        setTimeout(spawnEnemy, 2000);
                                    }
                                }
                            }
                        }
                    }
                }

                // Update ice projectiles
                for (let i = iceProjectiles.length - 1; i >= 0; i--) {
                    let ice = iceProjectiles[i];

                    // Move ice projectile
                    ice.x += ice.velocityX;
                    ice.y += ice.velocityY;

                    // Rotate ice projectile
                    ice.rotation += 0.1;

                    // Check if ice is off screen
                    if (ice.x < -50 || ice.x > canvas.width + 50 || 
                        ice.y < -50 || ice.y > canvas.height + 50) {
                        iceProjectiles.splice(i, 1);
                        continue;
                    }

                    // Check for collision with player
                    if (!playerFrozen && 
                        player.x + player.width > ice.x && 
                        player.x < ice.x + ice.width && 
                        player.y + player.height > ice.y && 
                        player.y < ice.y + ice.height) {

                        // Freeze player
                        playerFrozen = true;
                        freezeTimer = freezeDuration;
                        freezeSound.cloneNode().play();

                        // Remove ice projectile
                        iceProjectiles.splice(i, 1);
                    }
                }

                // Update enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    let enemy = enemies[i];

                    // Special boss behavior
                    if (enemy.isBoss) {
                        // Manage boss AI state
                        if (enemy.isEntering) {
                            // Boss is still entering - handled by entry code below
                        } else {
                            // Decrement cooldowns
                            if (enemy.jumpCooldown > 0) enemy.jumpCooldown--;

                            // Update movement timer and handle state transitions
                            enemy.movementTimer++;
                            if (enemy.movementTimer >= enemy.movementDuration) {
                                // Change state periodically
                                enemy.movementTimer = 0;

                                // Decide next state based on player position and current state
                                const distToPlayer = Math.abs((player.x + player.width/2) - (enemy.x + enemy.width/2));

                                if (distToPlayer < 300) {
                                    // Close to player - attack
                                    enemy.aiState = 'attack';
                                } else if (Math.random() < 0.7) {
                                    // Mostly patrol
                                    enemy.aiState = 'patrol';
                                } else {
                                    // Sometimes approach player
                                    enemy.aiState = 'approach';
                                }
                            }

                            // Execute behavior based on current state
                            switch (enemy.aiState) {
                                case 'patrol':
                                    // Just move back and forth on platform
                                    // Direction changes handled by platform edge detection
                                    break;

                                case 'approach':
                                    // Move toward player
                                    if (player.x + player.width/2 < enemy.x + enemy.width/2) {
                                        enemy.velocityX = -3;
                                    } else {
                                        enemy.velocityX = 3;
                                    }

                                    // Jump to player's platform if needed and cooldown allows
                                    if (enemy.jumpCooldown === 0) {
                                        // Find player's platform
                                        let playerPlatform = null;
                                        for (let platform of platforms) {
                                            if (player.y + player.height >= platform.y && 
                                                player.y + player.height <= platform.y + 10 &&
                                                player.x + player.width > platform.x && 
                                                player.x < platform.x + platform.width) {
                                                playerPlatform = platform;
                                                break;
                                            }
                                        }

                                        // If player is on a different platform and it's reasonably close
                                        if (playerPlatform && playerPlatform !== enemy.currentPlatform) {
                                            const horizontalDist = Math.abs((playerPlatform.x + playerPlatform.width/2) - 
                                                                          (enemy.x + enemy.width/2));
                                            const verticalDist = Math.abs(playerPlatform.y - enemy.currentPlatform.y);

                                            // Only jump if platform is not too far
                                            if (horizontalDist < 400 && verticalDist < 200) {
                                                // Calculate jump strength based on height difference
                                                const jumpStrength = 12 + (verticalDist / 10);
                                                enemy.velocityY = -jumpStrength;
                                                enemy.isJumping = true;
                                                enemy.jumpCooldown = 90; // 1.5 second cooldown
                                            }
                                        }
                                    }
                                    break;

                                case 'attack':
                                    // Throw ice more frequently in attack mode
                                    if (Math.random() < 0.05) {
                                        throwIceProjectile(enemy);
                                    }

                                    // Move toward player more aggressively
                                    if (player.x + player.width/2 < enemy.x + enemy.width/2) {
                                        enemy.velocityX = -4;
                                    } else {
                                        enemy.velocityX = 4;
                                    }
                                    break;
                            }

                            // Always throw ice projectiles occasionally
                            if (Math.random() < 0.02) {
                                throwIceProjectile(enemy);
                            }
                        }
                    }

                    // Move enemy
                    enemy.x += enemy.velocityX;

                    // Handle entry animation and physics
                    if (enemy.isEntering) {
                        // Apply gravity during jump
                        enemy.velocityY += enemy.gravity;

                        // Store previous position for collision detection
                        const prevY = enemy.y;
                        const prevX = enemy.x;

                        // Update position
                        enemy.y += enemy.velocityY;
                        enemy.x += enemy.velocityX;

                        // Special handling for boss entry
                        if (enemy.isBoss) {
                            // Check if boss is above the target platform
                            const isAbovePlatform = enemy.x + enemy.width > enemy.targetPlatform.x && 
                                                   enemy.x < enemy.targetPlatform.x + enemy.targetPlatform.width;

                            if (isAbovePlatform) {
                                // Ensure boss lands perfectly on the platform when directly above it
                                if (enemy.y + enemy.height >= enemy.targetPlatform.y - 5 && 
                                    enemy.y + enemy.height <= enemy.targetPlatform.y + 10) {
                                    // Snap to platform surface
                                    enemy.y = enemy.targetPlatform.y - enemy.height;
                                    enemy.velocityY = 0;
                                    enemy.isEntering = false;
                                    enemy.velocityX = -3; // Start moving left
                                    enemy.currentPlatform = enemy.targetPlatform;
                                    enemy.aiState = 'patrol';
                                } else if (enemy.y + enemy.height < enemy.targetPlatform.y - 5) {
                                    // Still approaching from above, carefully guide to platform
                                    // Calculate how many frames until we reach the platform horizontally
                                    const timeToReachX = Math.abs((enemy.targetPlatform.x + enemy.targetPlatform.width/2 - enemy.width/2 - enemy.x) / enemy.velocityX);

                                    // Calculate ideal Y velocity to land perfectly
                                    const targetY = enemy.targetPlatform.y - enemy.height;
                                    const distanceY = targetY - enemy.y;
                                    const idealVelocityY = distanceY / timeToReachX;

                                    // Apply a weighted adjustment to current velocity (stronger than before)
                                    enemy.velocityY = enemy.velocityY * 0.7 + idealVelocityY * 0.3;
                                }
                            } else {
                                // Not yet above platform, maintain horizontal movement
                                // Adjust trajectory to aim for platform center
                                const platformCenterX = enemy.targetPlatform.x + enemy.targetPlatform.width/2 - enemy.width/2;
                                const distToCenter = platformCenterX - enemy.x;

                                // Slow down if getting close to ensure we don't overshoot
                                if (Math.abs(distToCenter) < 100) {
                                    enemy.velocityX = Math.sign(enemy.velocityX) * Math.min(Math.abs(enemy.velocityX), 2);
                                }

                                // Adjust vertical position to line up with platform
                                const idealY = enemy.targetPlatform.y - enemy.height - 100; // Aim to be 100px above platform
                                const yDiff = idealY - enemy.y;

                                // Apply gentle vertical adjustment
                                enemy.velocityY = enemy.velocityY * 0.9 + (yDiff * 0.02);
                            }

                            // Safety check - if somehow boss gets below all platforms or off screen
                            if (enemy.y > canvas.height - 200 || enemy.y < -100 || 
                                enemy.x < -100 || enemy.x > canvas.width + 100) {
                                // Emergency teleport to above the target platform
                                enemy.y = enemy.targetPlatform.y - enemy.height - 50;
                                enemy.x = Math.max(50, Math.min(canvas.width - enemy.width - 50, enemy.x));
                                enemy.velocityY = 0;
                                enemy.velocityX = enemy.velocityX > 0 ? -2 : 2; // Reverse direction
                            }
                        } else {
                            // Regular enemy handling
                            // Check if landed on target platform
                            if (enemy.velocityY > 0 && 
                                prevY + enemy.height <= enemy.targetPlatform.y &&
                                enemy.y + enemy.height >= enemy.targetPlatform.y && 
                                enemy.x + enemy.width > enemy.targetPlatform.x && 
                                enemy.x < enemy.targetPlatform.x + enemy.targetPlatform.width) {

                                // Landed on platform
                                enemy.y = enemy.targetPlatform.y - enemy.height;
                                enemy.velocityY = 0;
                                enemy.isEntering = false;
                                enemy.velocityX = enemy.velocityX > 0 ? enemySpeed : -enemySpeed;
                            }

                            // Check if landed on any other platform
                            for (let platform of platforms) {
                                if (platform !== enemy.targetPlatform && 
                                    enemy.velocityY > 0 && 
                                    prevY + enemy.height <= platform.y &&
                                    enemy.y + enemy.height >= platform.y && 
                                    enemy.x + enemy.width > platform.x && 
                                    enemy.x < platform.x + platform.width) {

                                    // Landed on a different platform
                                    enemy.y = platform.y - enemy.height;
                                    enemy.velocityY = 0;
                                    enemy.isEntering = false;
                                    enemy.velocityX = enemy.velocityX > 0 ? enemySpeed : -enemySpeed;
                                    break;
                                }
                            }

                            // If missed platform or went off-screen, remove and spawn new
                            if (enemy.y > canvas.height || 
                                (enemy.velocityX > 0 && enemy.x > canvas.width + 100) || 
                                (enemy.velocityX < 0 && enemy.x < -100)) {
                                enemies.splice(i, 1);
                                setTimeout(spawnEnemy, 1000);
                                continue;
                            }
                        }
                    } else {
                        // Apply gravity
                        enemy.velocityY += gravity;

                        // Store previous position for collision detection
                        const prevY = enemy.y;
                        const prevX = enemy.x;

                        // First move horizontally
                        enemy.x += enemy.velocityX;

                        // Then check vertical movement
                        enemy.y += enemy.velocityY;

                        // Handle platform collisions
                        let onPlatform = false;
                        let onPlatformEdge = true;
                        let currentPlatform = null;

                        for (let platform of platforms) {
                            // Check if enemy is on or falling onto this platform
                            if (prevY + enemy.height <= platform.y && 
                                enemy.y + enemy.height >= platform.y &&
                                enemy.x + enemy.width > platform.x && 
                                enemy.x < platform.x + platform.width) {

                                // Land on platform
                                enemy.y = platform.y - enemy.height;
                                enemy.velocityY = 0;
                                onPlatform = true;
                                currentPlatform = platform;

                                // For boss, update current platform
                                if (enemy.isBoss) {
                                    enemy.currentPlatform = platform;
                                    enemy.isJumping = false;
                                }

                                // Check if enemy is not at the edge
                                const leftEdge = platform.x + 5; // 5px buffer
                                const rightEdge = platform.x + platform.width - 5; // 5px buffer

                                if (enemy.velocityX < 0 && enemy.x > leftEdge || 
                                    enemy.velocityX > 0 && enemy.x + enemy.width < rightEdge) {
                                    onPlatformEdge = false;
                                }

                                break; // Found a platform to stand on, no need to check others
                            }
                        }

                        // Check for side collisions with platforms
                        for (let platform of platforms) {
                            if (enemy.y + enemy.height > platform.y + 5 && 
                                enemy.y < platform.y + platform.height - 5) {

                                // Hitting platform from the side
                                if (prevX + enemy.width <= platform.x && enemy.x + enemy.width > platform.x) {
                                    // Hitting from left
                                    enemy.x = platform.x - enemy.width;
                                    enemy.velocityX *= -1;
                                }
                                else if (prevX >= platform.x + platform.width && enemy.x < platform.x + platform.width) {
                                    // Hitting from right
                                    enemy.x = platform.x + platform.width;
                                    enemy.velocityX *= -1;
                                }
                            }
                        }

                        // If not on any platform and not falling, start falling
                        if (!onPlatform && enemy.velocityY === 0) {
                            enemy.velocityY = 0.1; // Start falling gently
                        }

                        // Change direction if at platform edge or wall
                        if (onPlatformEdge || enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) {
                            enemy.velocityX *= -1;

                            // Move slightly away from the edge to prevent falling
                            if (enemy.x <= 0) {
                                enemy.x = 1;
                            } else if (enemy.x + enemy.width >= canvas.width) {
                                enemy.x = canvas.width - enemy.width - 1;
                            }
                        }

                        // Additional check for boss to ensure it stays on screen
                        if (enemy.isBoss) {
                            // Ensure boss stays within screen boundaries
                            if (enemy.x < 0) {
                                enemy.x = 0;
                                enemy.velocityX = Math.abs(enemy.velocityX); // Force move right
                            } else if (enemy.x + enemy.width > canvas.width) {
                                enemy.x = canvas.width - enemy.width;
                                enemy.velocityX = -Math.abs(enemy.velocityX); // Force move left
                            }

                            // Ensure boss stays on its platform or a valid platform
                            if (!onPlatform && enemy.velocityY > 5) {
                                // Boss is falling too fast, find nearest platform
                                let nearestPlatform = null;
                                let minDistance = Infinity;

                                for (let platform of platforms) {
                                    if (enemy.x + enemy.width > platform.x && 
                                        enemy.x < platform.x + platform.width) {
                                        const distance = Math.abs(platform.y - (enemy.y + enemy.height));
                                        if (distance < minDistance) {
                                            minDistance = distance;
                                            nearestPlatform = platform;
                                        }
                                    }
                                }

                                // Teleport to nearest platform if falling off screen
                                if (nearestPlatform && enemy.y > canvas.height - 200) {
                                    enemy.y = nearestPlatform.y - enemy.height;
                                    enemy.velocityY = 0;
                                    enemy.currentPlatform = nearestPlatform;
                                }
                            }
                        }
                    }

                    // Check for collision with player - only if not invincible
                    if (!player.invincible && 
                        player.x + player.width > enemy.x && 
                        player.x < enemy.x + enemy.width && 
                        player.y + player.height > enemy.y && 
                        player.y < enemy.y + enemy.height) {

                        health--;
                        updateUI();
                        hurtSound.cloneNode().play();

                        // Push player away from enemy
                        if (player.x < enemy.x) {
                            player.velocityX = -10;
                        } else {
                            player.velocityX = 10;
                        }
                        player.velocityY = -5;
                        
                        // Make player temporarily invincible
                        player.invincible = true;
                        player.invincibleTimer = 90; // 1.5 seconds at 60 FPS
                        
                        // Visual feedback for invincibility
                        player.flashTimer = 0;
                        player.isFlashing = true;

                        if (health <= 0) {
                            gameOver();
                        }
                    }
                }

                // Spawn new enemy if there are none
                if (enemies.length === 0) {
                    spawnEnemy();
                }

                // Check for bamboo collection
                for (let i = bamboos.length - 1; i >= 0; i--) {
                    if (player.x + player.width > bamboos[i].x && 
                        player.x < bamboos[i].x + bamboos[i].width && 
                        player.y + player.height > bamboos[i].y && 
                        player.y < bamboos[i].y + bamboos[i].height) {

                        // Collect bamboo
                        hunger = Math.min(100, hunger + bamboos[i].nutritionValue);
                        increaseScore(20 * scoreMultiplier);
                        eatSound.cloneNode().play();
                        bamboos.splice(i, 1);
                    }
                }
            }

            function render() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw background
                ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);

                // If boss fight, add dark overlay
                if (isBossFight) {
                    ctx.fillStyle = 'rgba(0, 0, 100, 0.2)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                // Draw platforms
                for (let platform of platforms) {
                    // Draw platform with repetition
                    let segments = Math.ceil(platform.width / 128);
                    for (let i = 0; i < segments; i++) {
                        let segmentWidth = Math.min(128, platform.width - i * 128);
                        ctx.drawImage(platformImg, 0, 0, segmentWidth, 32, platform.x + i * 128, platform.y, segmentWidth, 32);
                    }
                }

                // Draw player - choose frozen or normal sprite
                const playerImage = playerFrozen ? koalaFrozenImg : koalaImg;
                
                // Handle invincibility flashing effect
                let shouldDrawPlayer = true;
                if (player.invincible) {
                    player.flashTimer++;
                    if (player.flashTimer % 6 < 3) { // Flash every few frames
                        shouldDrawPlayer = false;
                    }
                }
                
                if (shouldDrawPlayer) {
                    if (player.facingRight) {
                        ctx.save();
                        ctx.scale(-1, 1);
                        ctx.drawImage(playerImage, -player.x - player.width, player.y, player.width, player.height);
                        ctx.restore();
                    } else {
                        ctx.drawImage(playerImage, player.x, player.y, player.width, player.height);
                    }
                }

                // If player is frozen, draw ice effect
                if (playerFrozen) {
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = 'rgba(150, 217, 250, 0.3)';
                    ctx.fillRect(player.x, player.y, player.width, player.height);

                    // Draw ice crystals
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    for (let i = 0; i < 10; i++) {
                        const x = player.x + Math.random() * player.width;
                        const y = player.y + Math.random() * player.height;
                        const size = 2 + Math.random() * 4;
                        ctx.fillRect(x, y, size, size);
                    }
                    ctx.restore();
                }

                // Draw boomerang
                if (boomerang !== null) {
                    ctx.save();
                    ctx.translate(boomerang.x + boomerang.width / 2, boomerang.y + boomerang.height / 2);
                    ctx.rotate(boomerang.rotation);
                    ctx.drawImage(boomerangImg, -boomerang.width / 2, -boomerang.height / 2, boomerang.width, boomerang.height);
                    ctx.restore();
                }

                // Draw enemies
                for (let enemy of enemies) {
                    if (enemy.isBoss) {
                        // Draw boss with appropriate facing
                        if (enemy.velocityX > 0) {
                            ctx.drawImage(superKangarooImg, enemy.x, enemy.y, enemy.width, enemy.height);
                        } else {
                            ctx.save();
                            ctx.scale(-1, 1);
                            ctx.drawImage(superKangarooImg, -enemy.x - enemy.width, enemy.y, enemy.width, enemy.height);
                            ctx.restore();
                        }

                        // Draw boss health bar
                        const healthBarWidth = enemy.width;
                        const healthBarHeight = 10;
                        const healthPercentage = enemy.health / enemy.maxHealth;

                        // Background of health bar
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(enemy.x, enemy.y - 20, healthBarWidth, healthBarHeight);

                        // Health bar color based on remaining health
                        if (healthPercentage > 0.6) {
                            ctx.fillStyle = 'lime';
                        } else if (healthPercentage > 0.3) {
                            ctx.fillStyle = 'yellow';
                        } else {
                            ctx.fillStyle = 'red';
                        }

                        // Health bar
                        ctx.fillRect(enemy.x, enemy.y - 20, healthBarWidth * healthPercentage, healthBarHeight);

                        // Ice aura effect for boss
                        ctx.save();
                        ctx.globalAlpha = 0.3;
                        ctx.fillStyle = 'rgba(150, 217, 250, 0.5)';

                        // Draw aura
                        ctx.beginPath();
                        ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 
                                enemy.width/1.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    } else {
                        // Regular enemies
                        if (enemy.velocityX > 0) {
                            ctx.drawImage(kangarooImg, enemy.x, enemy.y, enemy.width, enemy.height);
                        } else {
                            ctx.save();
                            ctx.scale(-1, 1);
                            ctx.drawImage(kangarooImg, -enemy.x - enemy.width, enemy.y, enemy.width, enemy.height);
                            ctx.restore();
                        }
                    }
                }

                // Draw ice projectiles
                for (let ice of iceProjectiles) {
                    ctx.save();
                    ctx.translate(ice.x + ice.width/2, ice.y + ice.height/2);
                    ctx.rotate(ice.rotation);
                    ctx.drawImage(iceProjectileImg, -ice.width/2, -ice.height/2, ice.width, ice.height);
                    ctx.restore();

                    // Draw ice trail effect
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    for (let i = 0; i < 3; i++) {
                        const trailX = ice.x - ice.velocityX * (i * 0.5);
                        const trailY = ice.y - ice.velocityY * (i * 0.5);
                        const trailSize = ice.width * (1 - i * 0.2);

                        ctx.globalAlpha = 0.3 - (i * 0.1);
                        ctx.translate(trailX + trailSize/2, trailY + trailSize/2);
                        ctx.rotate(ice.rotation - (i * 0.2));
                        ctx.drawImage(iceProjectileImg, -trailSize/2, -trailSize/2, trailSize, trailSize);
                        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
                    }
                    ctx.restore();
                }

                // Draw explosions
                for (let explosion of explosions) {
                    explosion.draw(ctx);
                }

                // Draw bamboo with glow effect
                for (let bamboo of bamboos) {
                    // Update glow animation
                    bamboo.glowSize += 0.05 * bamboo.glowDirection;
                    if (bamboo.glowSize >= 1.5) bamboo.glowDirection = -1;
                    if (bamboo.glowSize <= 0) bamboo.glowDirection = 1;

                    // Draw glow effect
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    const glowSize = bamboo.width * (1 + bamboo.glowSize * 0.3);
                    const glowX = bamboo.x - (glowSize - bamboo.width) / 2;
                    const glowY = bamboo.y - (glowSize - bamboo.height) / 2;

                    // Create glow gradient
                    const gradient = ctx.createRadialGradient(
                        bamboo.x + bamboo.width/2, bamboo.y + bamboo.height/2, bamboo.width/4,
                        bamboo.x + bamboo.width/2, bamboo.y + bamboo.height/2, bamboo.width
                    );
                    gradient.addColorStop(0, 'rgba(144, 238, 144, 0.8)');
                    gradient.addColorStop(1, 'rgba(144, 238, 144, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(bamboo.x + bamboo.width/2, bamboo.y + bamboo.height/2, glowSize/1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    ctx.restore();

                    // Draw bamboo image
                    ctx.drawImage(bambooImg, bamboo.x, bamboo.y, bamboo.width, bamboo.height);
                }

                // Draw hunger bar
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(player.x, player.y - 15, player.width, 5);

                // Color changes based on hunger level
                if (hunger > 60) {
                    ctx.fillStyle = 'green';
                } else if (hunger > 30) {
                    ctx.fillStyle = 'yellow';
                } else {
                    ctx.fillStyle = 'red';
                }

                ctx.fillRect(player.x, player.y - 15, player.width * (hunger / 100), 5);
            }

            function throwBoomerang() {
                const direction = player.facingRight ? 1 : -1;
                boomerang = {
                    x: player.facingRight ? player.x + player.width : player.x,
                    y: player.y + player.height / 2 - 16,
                    width: 32,
                    height: 32,
                    velocityX: direction * boomerangSpeed,
                    rotation: 0,
                    returning: false,
                    initialDirection: direction,
                    maxDistance: player.facingRight ? 
                        Math.min(player.x + 300, canvas.width) : 
                        Math.max(player.x - 300, 0)
                };
            }

            function createExplosion(x, y) {
                // Create a new explosion at the given position
                const explosion = {
                    x: x,
                    y: y,
                    width: 64,
                    height: 64,
                    frameWidth: 64, // Width of each frame in the sprite sheet
                    frameHeight: 64, // Height of each frame
                    currentFrame: 0,
                    totalFrames: 6, // Total number of frames in the explosion animation
                    frameDelay: 4, // Frames to wait before showing next sprite
                    frameCounter: 0,
                    finished: false,

                    update: function() {
                        this.frameCounter++;
                        if (this.frameCounter >= this.frameDelay) {
                            this.frameCounter = 0;
                            this.currentFrame++;
                            if (this.currentFrame >= this.totalFrames) {
                                this.finished = true;
                            }
                        }
                    },

                    draw: function(ctx) {
                        if (!this.finished) {
                            // Draw the current frame from the sprite sheet
                            ctx.drawImage(
                                explosionImg,
                                this.currentFrame * this.frameWidth, 0, // Source x, y
                                this.frameWidth, this.frameHeight, // Source width, height
                                this.x, this.y, // Destination x, y
                                this.width, this.height // Destination width, height
                            );
                        }
                    }
                };

                explosions.push(explosion);
                explosionSound.cloneNode().play();
            }

            function spawnBamboo() {
                // Find a random platform to place bamboo on
                const platformIndex = Math.floor(Math.random() * platforms.length);
                const platform = platforms[platformIndex];

                // Place bamboo at a random position on the platform
                const bambooX = platform.x + Math.random() * (platform.width - 48);
                const bambooY = platform.y - 48; // Place on top of platform

                const bamboo = {
                    x: bambooX,
                    y: bambooY - 10, // Position it a bit higher to account for bigger size
                    width: 48,
                    height: 48,
                    nutritionValue: 20 + Math.floor(Math.random() * 20), // 20-40 hunger points
                    glowSize: 0, // For glow animation
                    glowDirection: 1 // Direction of glow animation (growing or shrinking)
                };

                bamboos.push(bamboo);
            }

            function startBossFight() {
                // Only spawn boss if not already in boss fight
                if (!isBossFight) {
                    isBossFight = true;
                    bossSpawned = true;

                    // Clear regular enemies
                    enemies = [];

                    // Display boss warning
                    const bossWarning = document.createElement('div');
                    bossWarning.textContent = "‚ö†Ô∏è SUPER KANGAROO BOSS INCOMING! ‚ö†Ô∏è";
                    bossWarning.style.position = 'absolute';
                    bossWarning.style.top = '100px';
                    bossWarning.style.left = '50%';
                    bossWarning.style.transform = 'translateX(-50%)';
                    bossWarning.style.color = 'red';
                    bossWarning.style.fontSize = '36px';
                    bossWarning.style.fontWeight = 'bold';
                    bossWarning.style.textShadow = '2px 2px 4px black';
                    bossWarning.style.zIndex = '100';
                    bossWarning.style.fontFamily = "'Comic Sans MS', cursive, sans-serif";
                    document.getElementById('game-container').appendChild(bossWarning);

                    // Play boss appear sound
                    bossAppearSound.cloneNode().play();

                    // Remove warning after 3 seconds
                    setTimeout(() => {
                        bossWarning.remove();
                        spawnBoss();
                    }, 3000);
                }
            }

            function spawnBoss() {
                // Find the largest platform to spawn boss on
                let largestPlatform = platforms[0];
                for (let platform of platforms) {
                    if (platform.width > largestPlatform.width) {
                        largestPlatform = platform;
                    }
                }

                // Calculate a good entry position above and to the right of the platform
                const entryY = Math.min(largestPlatform.y - 200, 100); // Higher position for more controlled descent

                // Create boss enemy
                const boss = {
                    x: canvas.width + 100, // Start off-screen
                    y: entryY, // Position well above platform for a controlled descent
                    width: 128,
                    height: 128,
                    velocityX: -2, // Move left initially, slower for better control
                    velocityY: 0,
                    targetPlatform: largestPlatform,
                    isEntering: true,
                    gravity: 0.1, // Even lower gravity for boss for better control
                    isBoss: true,
                    health: 10, // Boss has more health
                    maxHealth: 10,
                    isJumping: false,
                    lastIceThrow: 0,
                    iceThrowCooldown: 1500, // ms
                    movementTimer: 0,
                    movementDuration: 120, // 2 seconds at 60FPS
                    currentPlatform: largestPlatform,
                    jumpCooldown: 0,
                    aiState: 'approach', // approach, patrol, attack
                    entryPhase: 'approach', // Tracking the phase of entry: approach, descend, land
                    stuckCounter: 0 // Counter to detect if boss gets stuck
                };

                enemies.push(boss);

                // Add a safety timeout to ensure boss doesn't get stuck in entering state
                setTimeout(() => {
                    // Find the boss in the enemies array
                    const bossIndex = enemies.findIndex(e => e.isBoss && e.isEntering);
                    if (bossIndex !== -1) {
                        // Force boss to land if still in entering state after 10 seconds
                        enemies[bossIndex].isEntering = false;
                        enemies[bossIndex].y = enemies[bossIndex].targetPlatform.y - enemies[bossIndex].height;
                        enemies[bossIndex].velocityY = 0;
                        enemies[bossIndex].velocityX = -3;
                        enemies[bossIndex].currentPlatform = enemies[bossIndex].targetPlatform;
                        enemies[bossIndex].aiState = 'patrol';
                    }
                }, 10000);
            }

            function throwIceProjectile(boss) {
                // Only throw if cooldown has passed
                const now = Date.now();
                if (now - boss.lastIceThrow < boss.iceThrowCooldown) return;

                boss.lastIceThrow = now;

                // Calculate direction to player
                const dx = (player.x + player.width / 2) - (boss.x + boss.width / 2);
                const dy = (player.y + player.height / 2) - (boss.y + boss.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Create ice projectile
                const ice = {
                    x: boss.x + boss.width / 2 - 16, // Center of boss
                    y: boss.y + boss.height / 3, // Upper part of boss
                    width: 32,
                    height: 32,
                    velocityX: (dx / distance) * 6, // Speed in direction of player
                    velocityY: (dy / distance) * 6,
                    rotation: 0
                };

                iceProjectiles.push(ice);
                iceThrowSound.cloneNode().play();
            }

            function spawnEnemy() {
                // Don't spawn regular enemies during boss fight
                if (isBossFight) return;

                // Decide which side to spawn from
                const spawnFromRight = Math.random() > 0.5;

                // Pick a random platform to target
                const platformIndex = Math.floor(Math.random() * platforms.length);
                const platform = platforms[platformIndex];

                // Make sure we pick a platform with enough room
                let safeEntryPlatform = platform;
                if (platform.width < 150) { // Increase minimum width requirement
                    // Find a wider platform as fallback
                    for (let p of platforms) {
                        if (p.width >= 150) {
                            safeEntryPlatform = p;
                            break;
                        }
                    }
                }

                // Calculate a safe landing position (not too close to the edge)
                const buffer = 30; // Buffer from platform edge
                const safeX = spawnFromRight ? 
                    safeEntryPlatform.x + buffer : 
                    safeEntryPlatform.x + safeEntryPlatform.width - 64 - buffer;

                // Calculate jump arc to land properly
                const horizontalDistance = spawnFromRight ? 
                    canvas.width - safeX + 64 : 
                    safeX + 64;

                // Adjust initial velocity based on distance
                const initialVelX = (spawnFromRight ? -1 : 1) * Math.min(enemySpeed * 1.5, horizontalDistance / 60);

                const enemy = {
                    x: spawnFromRight ? canvas.width : -64, // Start off-screen
                    y: safeEntryPlatform.y - 150, // Start higher to create jumping arc
                    width: 64,
                    height: 64,
                    velocityX: initialVelX,
                    velocityY: -5, // Initial upward velocity for jump arc
                    targetPlatform: safeEntryPlatform,
                    targetX: safeX, // Target landing X position (center of platform)
                    isEntering: true, // Flag to track entry animation
                    gravity: 0.3, // Slightly less gravity than player for smoother arc
                    lastX: spawnFromRight ? canvas.width : -64, // Track previous X position
                    lastY: safeEntryPlatform.y - 150 // Track previous Y position
                };

                enemies.push(enemy);
            }

            function updateUI() {
                scoreElement.textContent = `SCORE: ${Math.floor(score)}`;
                healthElement.textContent = `Health: ${health}`;
                hungerElement.textContent = `Hunger: ${Math.floor(hunger)}%`;
            }

            function increaseScore(amount) {
                const oldScore = score;
                score += amount;
                updateUI();

                // Animate score element
                scoreElement.classList.remove('score-animation');
                void scoreElement.offsetWidth; // Trigger reflow to restart animation
                scoreElement.classList.add('score-animation');

                // Display floating score text
                const floatingScore = document.createElement('div');
                floatingScore.textContent = `+${Math.floor(amount)}`;
                floatingScore.style.position = 'absolute';
                floatingScore.style.color = '#ffcc00';
                floatingScore.style.fontFamily = "'Comic Sans MS', cursive, sans-serif";
                floatingScore.style.fontSize = '24px';
                floatingScore.style.fontWeight = 'bold';
                floatingScore.style.textShadow = '2px 2px 3px rgba(0,0,0,0.7)';
                floatingScore.style.zIndex = '100';

                // Random position near the score display
                floatingScore.style.top = `${Math.random() * 30 + 70}px`;
                floatingScore.style.left = `${Math.random() * 100 + canvas.width/2 - 50}px`;

                document.getElementById('game-container').appendChild(floatingScore);

                // Animate and remove
                floatingScore.animate([
                    { transform: 'translateY(0)', opacity: 1 },
                    { transform: 'translateY(-50px)', opacity: 0 }
                ], {
                    duration: 1000,
                    easing: 'ease-out'
                }).onfinish = () => floatingScore.remove();
            }

            function gameOver() {
                gameRunning = false;
                pauseAllMusic();

                finalScoreElement.textContent = `Score: ${score}`;
                gameOverScreen.style.display = 'flex';
            }

            // Music control functions
            function setupMusicControls() {
                const musicTitle = document.getElementById('music-title');
                const playPauseBtn = document.getElementById('play-pause');
                const prevTrackBtn = document.getElementById('prev-track');
                const nextTrackBtn = document.getElementById('next-track');

                // Play/Pause button
                playPauseBtn.addEventListener('click', () => {
                    if (isMusicPlaying) {
                        pauseCurrentMusic();
                        playPauseBtn.textContent = '‚ñ∂Ô∏è';
                        musicTitle.textContent = 'Music: Off';
                        isMusicPlaying = false;
                    } else {
                        playCurrentMusic();
                        playPauseBtn.textContent = '‚è∏Ô∏è';
                        updateMusicTitle();
                        isMusicPlaying = true;
                    }
                });

                // Previous track button
                prevTrackBtn.addEventListener('click', () => {
                    pauseCurrentMusic();
                    currentMusicIndex = (currentMusicIndex - 1 + musicTracks.length) % musicTracks.length;
                    currentMusic = musicTracks[currentMusicIndex].audio;

                    if (isMusicPlaying) {
                        playCurrentMusic();
                    }
                    updateMusicTitle();
                });

                // Next track button
                nextTrackBtn.addEventListener('click', () => {
                    pauseCurrentMusic();
                    currentMusicIndex = (currentMusicIndex + 1) % musicTracks.length;
                    currentMusic = musicTracks[currentMusicIndex].audio;

                    if (isMusicPlaying) {
                        playCurrentMusic();
                    }
                    updateMusicTitle();
                });
            }

            function updateMusicTitle() {
                const musicTitle = document.getElementById('music-title');
                if (isMusicPlaying) {
                    const track = musicTracks[currentMusicIndex];
                    musicTitle.textContent = `${track.icon} ${track.name}`;
                } else {
                    musicTitle.textContent = 'Music: Off';
                }
            }

            function playCurrentMusic() {
                currentMusic.play();
            }

            function pauseCurrentMusic() {
                currentMusic.pause();
                currentMusic.currentTime = 0;
            }

            function pauseAllMusic() {
                musicTracks.forEach(track => {
                    track.audio.pause();
                    track.audio.currentTime = 0;
                });
            }

            // Make sure canvas resizes with window
            function resizeCanvas() {
                const container = document.getElementById('game-container');
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;

                const scale = Math.min(containerWidth / 800, containerHeight / 500);

                canvas.style.width = `${800 * scale}px`;
                canvas.style.height = `${500 * scale}px`;
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Wait for assets to load
            let assetsLoaded = 0;
            const totalAssets = 10; // 11 images

            function checkAllAssetsLoaded() {
                assetsLoaded++;
                if (assetsLoaded === totalAssets) {
                    // All assets loaded, game is ready to start
                    startButton.disabled = false;
                }
            }

            koalaImg.onload = checkAllAssetsLoaded;
            koalaFrozenImg.onload = checkAllAssetsLoaded;
            kangarooImg.onload = checkAllAssetsLoaded;
            superKangarooImg.onload = checkAllAssetsLoaded;
            iceProjectileImg.onload = checkAllAssetsLoaded;
            boomerangImg.onload = checkAllAssetsLoaded;
            platformImg.onload = checkAllAssetsLoaded;
            backgroundImg.onload = checkAllAssetsLoaded;
            explosionImg.onload = checkAllAssetsLoaded;
            bambooImg.onload = checkAllAssetsLoaded;

            // Disable start button until assets are loaded
            startButton.disabled = true;

            // Setup music controls
            setupMusicControls();
        });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.2/dist/nipplejs.js" crossorigin="anonymous"></script>
    <script>
(function (root, factory) {
    if (typeof module === "object" && module.exports) {
        module.exports = factory();
    } else {
        root.TouchpadControls = factory();
        root.touchpadControls = root.TouchpadControls;
    }
}(typeof self !== "undefined" ? self : this, function () {
    "use strict";

    const sections = {
        CENTER_LEFT: { top: "50%", left: "130px", transform: "translate(-50%, -50%)" },
        CENTER_TOP: { top: "130px", left: "50%", transform: "translate(-50%, -50%)" },
        CENTER_RIGHT: { top: "50%", left: "calc(100% - 130px)", transform: "translate(-50%, -50%)" },
        CENTER_BOTTOM: { top: "calc(100% - 130px)", left: "50%", transform: "translate(-50%, -50%)" }
    };

    const buttonPositions = {
        CENTER_LEFT: { top: "0", left: "-50px" },
        CENTER_TOP: { top: "-50px", left: "0" },
        CENTER_RIGHT: { top: "0", left: "50px" },
        CENTER_BOTTOM: { top: "50px", left: "0" }
    };

    const STYLE_ID = "touchpad-controls-style";
    const MIN_TOUCH_TARGET = 48;

    const injectTouchpadStyles = () => {
        if (typeof document === "undefined") return;
        if (document.getElementById(STYLE_ID)) return;

        const style = document.createElement("style");
        style.id = STYLE_ID;
        style.textContent = `
            :root {
                --touchpad-size: 72px;
                --touchpad-radius: 50%;
                --touchpad-bg: radial-gradient(135% 135% at 25% 20%, rgba(255,255,255,0.15), rgba(0,0,0,0.6));
                --touchpad-bg-image: none;
                --touchpad-bg-image-size: cover;
                --touchpad-bg-image-position: center;
                --touchpad-bg-blend: soft-light;
                --touchpad-border: 1px solid rgba(255,255,255,0.12);
                --touchpad-shadow: 0 12px 40px rgba(0,0,0,0.7), inset 0 1px 1px rgba(255,255,255,0.1);
                --touchpad-shadow-active: 0 4px 15px rgba(0,0,0,0.9), inset 0 1px 0 rgba(0,0,0,0.3);
                --touchpad-icon: none;
                --touchpad-icon-size: 52%;
                --touchpad-icon-opacity: 0.9;
                --touchpad-foreground-image: none;
                --touchpad-foreground-size: 60%;
                --touchpad-foreground-opacity: 0.8;
                --touchpad-foreground-blend: normal;
                --touchpad-label-color: #E2E8F0;
                --touchpad-label-size: 12px;
            }

            .touchpad {
                position: absolute;
                width: var(--touchpad-size);
                height: var(--touchpad-size);
                padding: 0;
                box-sizing: border-box;
                border-radius: var(--touchpad-radius);
                background-image: var(--touchpad-bg-image, none), var(--touchpad-bg);
                background-size: var(--touchpad-bg-image-size, cover), 100%;
                background-position: var(--touchpad-bg-image-position, center), center;
                background-repeat: no-repeat, no-repeat;
                background-blend-mode: var(--touchpad-bg-blend, soft-light), normal;
                border: var(--touchpad-border);
                box-shadow: var(--touchpad-shadow);
                display: flex;
                justify-content: center;
                align-items: center;
                touch-action: none;
                user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                font-size: 0;
                color: transparent;
                z-index: 9999;
                overflow: visible;
                backdrop-filter: blur(12px) saturate(180%);
                -webkit-backdrop-filter: blur(12px) saturate(180%);
                transition:
                    transform 120ms cubic-bezier(0.2, 0, 0, 1),
                    box-shadow 150ms ease,
                    background 200ms ease,
                    filter 150ms linear;
                background-position: center;
                background-repeat: no-repeat;
                background-size: 45%;
            }

            .touchpad::after {
                content: "";
                position: absolute;
                width: var(--touchpad-icon-size, 52%);
                height: var(--touchpad-icon-size, 52%);
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background-image: var(--touchpad-icon, none);
                background-repeat: no-repeat;
                background-position: center;
                background-size: contain;
                opacity: var(--touchpad-icon-opacity, 0.9);
                pointer-events: none;
                filter: drop-shadow(0 2px 6px rgba(0,0,0,0.6));
            }

            .touchpad::before {
                content: "";
                position: absolute;
                width: var(--touchpad-foreground-size, 60%);
                height: var(--touchpad-foreground-size, 60%);
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background-image: var(--touchpad-foreground-image, none);
                background-repeat: no-repeat;
                background-position: center;
                background-size: contain;
                opacity: var(--touchpad-foreground-opacity, 0.8);
                mix-blend-mode: var(--touchpad-foreground-blend, normal);
                pointer-events: none;
            }

            .touchpad--label {
                font-size: var(--touchpad-label-size, 12px);
                color: var(--touchpad-label-color, #E2E8F0);
            }

            .touchpad-label {
                position: absolute;
                left: 0;
                right: 0;
                bottom: 10%;
                text-align: center;
                font-weight: 600;
                pointer-events: none;
                text-shadow: 0 2px 8px rgba(0,0,0,0.7);
            }

            .touchpad.is-active {
                transform: scale(0.94) translate3d(0, 1px, 0);
                box-shadow: var(--touchpad-shadow-active);
            }

            .touchpad:hover {
                box-shadow: 0 12px 32px rgba(0,0,0,0.95);
            }

            .touchpad--button {
                font-size: 18px;
            }

            .touchpad--joystick {
                font-size: 14px;
            }

            .touchpad .nipple,
            .touchpad .nipple * {
                overflow: visible;
            }

            .touchpad .nipple .back {
                box-shadow:
                    0 0 0 1px rgba(15,23,42,0.85),
                    0 0 0 6px rgba(148,163,184,0.12),
                    0 10px 30px rgba(15,23,42,0.85);
            }

            .touchpad .nipple .front {
                box-shadow:
                    0 0 0 1px rgba(148,163,184,0.9),
                    0 8px 18px rgba(15,23,42,0.9);
            }
        `;
        document.head.appendChild(style);
    };

    const safeEntries = (obj) => {
        if (!obj || typeof obj !== "object") return [];
        return Object.entries(obj);
    };

    const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

    const formatCssValue = (value) => {
        if (typeof value === "number" && Number.isFinite(value)) {
            return `${value}px`;
        }
        return value;
    };

    const ICON_COLOR_DEFAULT = "#E2E8F0";
    const ICON_STROKE = 4;

    const svgToDataUri = (svg) => {
        const encoded = encodeURIComponent(svg)
            .replace(/%0A/g, "");
        return `url(\"data:image/svg+xml,${encoded}\")`;
    };

    const iconArrow = (direction, color) => {
        const stroke = color || ICON_COLOR_DEFAULT;
        if (direction === "left") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M40 16 L24 32 L40 48"/><path d="M26 32 H50"/></svg>`
            );
        }
        if (direction === "right") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M24 16 L40 32 L24 48"/><path d="M14 32 H38"/></svg>`
            );
        }
        if (direction === "up") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M16 30 L32 14 L48 30"/><path d="M32 16 V52"/></svg>`
            );
        }
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M16 34 L32 50 L48 34"/><path d="M32 12 V48"/></svg>`
        );
    };

    const iconHorizontal = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M18 22 L8 32 L18 42"/><path d="M46 22 L56 32 L46 42"/><path d="M14 32 H50"/></svg>`
    );

    const iconVertical = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M22 18 L32 8 L42 18"/><path d="M22 46 L32 56 L42 46"/><path d="M32 14 V50"/></svg>`
    );

    const iconDpad = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M32 16 V48"/><path d="M16 32 H48"/><path d="M24 22 L32 14 L40 22"/><path d="M24 42 L32 50 L40 42"/><path d="M22 24 L14 32 L22 40"/><path d="M42 24 L50 32 L42 40"/></svg>`
    );

    const iconCircle = (filled, color) => {
        const fillColor = color || ICON_COLOR_DEFAULT;
        if (filled) {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="14" fill="${fillColor}"/></svg>`
            );
        }
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="14" fill="none" stroke="${fillColor}" stroke-width="${ICON_STROKE}"/></svg>`
        );
    };

    const iconSquare = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="20" y="20" width="24" height="24" rx="4" fill="${color || ICON_COLOR_DEFAULT}"/></svg>`
    );

    const iconTriangle = (direction, color) => {
        const fillColor = color || ICON_COLOR_DEFAULT;
        if (direction === "left") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M22 32 L42 18 V46 Z" fill="${fillColor}"/></svg>`
            );
        }
        if (direction === "right") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M42 32 L22 18 V46 Z" fill="${fillColor}"/></svg>`
            );
        }
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 18 L18 42 H46 Z" fill="${fillColor}"/></svg>`
        );
    };

    const iconChevron = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M22 18 L34 32 L22 46"/><path d="M34 18 L46 32 L34 46"/></svg>`
    );

    const iconPause = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="20" y="18" width="8" height="28" rx="2" fill="${color || ICON_COLOR_DEFAULT}"/><rect x="36" y="18" width="8" height="28" rx="2" fill="${color || ICON_COLOR_DEFAULT}"/></svg>`
    );

    const keyLabel = (key) => {
        if (!key) return "";
        if (key.startsWith("Key") && key.length === 4) return key.slice(3);
        if (key.startsWith("Digit") && key.length === 6) return key.slice(5);
        if (key === "Space") return "SP";
        if (key === "Escape") return "ESC";
        if (key === "Enter") return "ENT";
        if (key === "Tab") return "TAB";
        if (key === "Backspace") return "BK";
        if (key === "ShiftLeft" || key === "ShiftRight") return "SH";
        if (key === "ControlLeft" || key === "ControlRight") return "CT";
        if (key === "AltLeft" || key === "AltRight") return "AL";
        if (key === "MetaLeft" || key === "MetaRight") return "MD";
        return key.slice(0, 3).toUpperCase();
    };

    const normalizeTheme = (theme) => {
        if (!theme || typeof theme !== "object") {
            return {
                iconColor: ICON_COLOR_DEFAULT,
                iconOpacity: 0.9,
                iconScale: 0.52,
                labelMode: "none",
                labelColor: ICON_COLOR_DEFAULT,
                labelSize: 12,
                background: null,
                backgroundImage: null,
                backgroundBlend: "soft-light",
                backgroundSize: "cover",
                backgroundPosition: "center",
                foregroundImage: null,
                foregroundOpacity: 0.8,
                foregroundSize: "60%",
                foregroundBlend: "normal"
            };
        }
        return {
            iconColor: theme.iconColor || ICON_COLOR_DEFAULT,
            iconOpacity: typeof theme.iconOpacity === "number" ? theme.iconOpacity : 0.9,
            iconScale: typeof theme.iconScale === "number" ? theme.iconScale : 0.52,
            labelMode: theme.labelMode || "none",
            labelColor: theme.labelColor || ICON_COLOR_DEFAULT,
            labelSize: typeof theme.labelSize === "number" ? theme.labelSize : 12,
            background: theme.background || null,
            backgroundImage: theme.backgroundImage || null,
            backgroundBlend: theme.backgroundBlend || "soft-light",
            backgroundSize: theme.backgroundSize || "cover",
            backgroundPosition: theme.backgroundPosition || "center",
            foregroundImage: theme.foregroundImage || null,
            foregroundOpacity: typeof theme.foregroundOpacity === "number" ? theme.foregroundOpacity : 0.8,
            foregroundSize: theme.foregroundSize || "60%",
            foregroundBlend: theme.foregroundBlend || "normal"
        };
    };

    const mergeTheme = (base, override) => {
        if (!override || typeof override !== "object") return base;
        return normalizeTheme(Object.assign({}, base, override));
    };

    const normalizeImageValue = (value) => {
        if (!value) return null;
        if (value.includes("url(")) return value;
        return `url(\"${value}\")`;
    };

    const applyThemeVars = (element, theme) => {
        if (!element || !theme) return;
        if (theme.background) {
            element.style.setProperty("--touchpad-bg", theme.background);
        }
        if (theme.backgroundImage) {
            element.style.setProperty("--touchpad-bg-image", normalizeImageValue(theme.backgroundImage));
            element.style.setProperty("--touchpad-bg-blend", theme.backgroundBlend || "soft-light");
            element.style.setProperty("--touchpad-bg-image-size", theme.backgroundSize || "cover");
            element.style.setProperty("--touchpad-bg-image-position", theme.backgroundPosition || "center");
        }
        if (theme.foregroundImage) {
            element.style.setProperty("--touchpad-foreground-image", normalizeImageValue(theme.foregroundImage));
            element.style.setProperty("--touchpad-foreground-opacity", String(theme.foregroundOpacity));
            element.style.setProperty("--touchpad-foreground-size", theme.foregroundSize || "60%");
            element.style.setProperty("--touchpad-foreground-blend", theme.foregroundBlend || "normal");
        }
        if (theme.iconOpacity != null) {
            element.style.setProperty("--touchpad-icon-opacity", String(theme.iconOpacity));
        }
        if (theme.iconScale != null) {
            element.style.setProperty("--touchpad-icon-size", `${Math.round(theme.iconScale * 100)}%`);
        }
        if (theme.labelColor) {
            element.style.setProperty("--touchpad-label-color", theme.labelColor);
        }
        if (theme.labelSize) {
            element.style.setProperty("--touchpad-label-size", `${theme.labelSize}px`);
        }
    };

    const resolveLabelText = (btn, labelMode) => {
        if (!btn) return "";
        if (labelMode === "none") return "";
        if (labelMode === "text") {
            if (btn.label) return String(btn.label);
            if (typeof btn.keys === "string") return keyLabel(btn.keys);
            return "";
        }
        if (labelMode === "key") {
            if (typeof btn.keys === "string") return keyLabel(btn.keys);
            return "";
        }
        if (labelMode === "both") {
            if (btn.label) return String(btn.label);
            if (typeof btn.keys === "string") return keyLabel(btn.keys);
            return "";
        }
        return "";
    };

    const iconKeycap = (label, color) => {
        const fillColor = color || ICON_COLOR_DEFAULT;
        const safe = String(label || "").replace(/[^A-Z0-9]/g, "");
        const text = safe || "";
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="12" y="14" width="40" height="36" rx="8" fill="none" stroke="${fillColor}" stroke-width="${ICON_STROKE}"/><text x="32" y="38" font-size="16" text-anchor="middle" fill="${fillColor}" font-family="monospace">${text}</text></svg>`
        );
    };

    const resolveDirectionForKey = (key, role) => {
        if (key === "ArrowLeft") return "left";
        if (key === "ArrowRight") return "right";
        if (key === "ArrowUp") return "up";
        if (key === "ArrowDown") return "down";
        if (role === "move" || role === "aim") {
            if (key === "KeyA") return "left";
            if (key === "KeyD") return "right";
            if (key === "KeyW") return "up";
            if (key === "KeyS") return "down";
        }
        return null;
    };

    const resolveIcon = (btn, theme) => {
        if (!btn) return null;
        if (btn.icon) return btn.icon;
        const iconColor = theme && theme.iconColor ? theme.iconColor : ICON_COLOR_DEFAULT;
        const meta = btn.meta || null;
        const keys = btn.keys;
        const role = btn.role;

        if (meta && meta.pair_position) {
            return iconTriangle(meta.pair_position === "right" ? "right" : "left", iconColor);
        }

        if (keys && typeof keys === "object" && !Array.isArray(keys)) {
            const hasLeft = !!keys.left;
            const hasRight = !!keys.right;
            const hasUp = !!keys.up;
            const hasDown = !!keys.down;
            if (hasLeft && hasRight && hasUp && hasDown) return iconDpad(iconColor);
            if (hasLeft && hasRight && !hasUp && !hasDown) return iconHorizontal(iconColor);
            if (hasUp && hasDown && !hasLeft && !hasRight) return iconVertical(iconColor);
            if (hasLeft && !hasRight && !hasUp && !hasDown) return iconArrow("left", iconColor);
            if (hasRight && !hasLeft && !hasUp && !hasDown) return iconArrow("right", iconColor);
            if (hasUp && !hasLeft && !hasRight && !hasDown) return iconArrow("up", iconColor);
            if (hasDown && !hasLeft && !hasRight && !hasUp) return iconArrow("down", iconColor);
        }

        if (typeof keys === "string") {
            const direction = resolveDirectionForKey(keys, role);
            if (direction) return iconArrow(direction, iconColor);
        }

        if (role === "jump") return iconArrow("up", iconColor);
        if (role === "pause") return iconPause(iconColor);
        if (role === "primary") return iconCircle(true, iconColor);
        if (role === "secondary") return iconCircle(false, iconColor);
        if (role === "tertiary") return iconSquare(iconColor);
        if (role === "modifier") return iconChevron(iconColor);
        if (role === "magnitude") return iconArrow("up", iconColor);

        if (typeof keys === "string") {
            return iconKeycap(keyLabel(keys), iconColor);
        }

        return null;
    };

    const KEY_ALIASES = {
        " ": "Space",
        "space": "Space",
        "Spacebar": "Space",
        "Esc": "Escape",
        "Return": "Enter",
        "Left": "ArrowLeft",
        "Right": "ArrowRight",
        "Up": "ArrowUp",
        "Down": "ArrowDown",
        "Del": "Delete",
        "Shift": "ShiftLeft",
        "Control": "ControlLeft",
        "Alt": "AltLeft",
        "Meta": "MetaLeft"
    };

    const KEY_DESCRIPTORS = {
        ArrowLeft: { key: "ArrowLeft", keyCode: 37 },
        ArrowRight: { key: "ArrowRight", keyCode: 39 },
        ArrowUp: { key: "ArrowUp", keyCode: 38 },
        ArrowDown: { key: "ArrowDown", keyCode: 40 },
        Space: { key: " ", keyCode: 32 },
        Enter: { key: "Enter", keyCode: 13 },
        Tab: { key: "Tab", keyCode: 9 },
        Escape: { key: "Escape", keyCode: 27 },
        Backspace: { key: "Backspace", keyCode: 8 },
        Delete: { key: "Delete", keyCode: 46 },
        Insert: { key: "Insert", keyCode: 45 },
        Home: { key: "Home", keyCode: 36 },
        End: { key: "End", keyCode: 35 },
        PageUp: { key: "PageUp", keyCode: 33 },
        PageDown: { key: "PageDown", keyCode: 34 },
        CapsLock: { key: "CapsLock", keyCode: 20 },
        NumLock: { key: "NumLock", keyCode: 144 },
        ScrollLock: { key: "ScrollLock", keyCode: 145 },
        Pause: { key: "Pause", keyCode: 19 },
        PrintScreen: { key: "PrintScreen", keyCode: 44 },
        ContextMenu: { key: "ContextMenu", keyCode: 93 },
        ShiftLeft: { key: "Shift", keyCode: 16, location: 1 },
        ShiftRight: { key: "Shift", keyCode: 16, location: 2 },
        ControlLeft: { key: "Control", keyCode: 17, location: 1 },
        ControlRight: { key: "Control", keyCode: 17, location: 2 },
        AltLeft: { key: "Alt", keyCode: 18, location: 1 },
        AltRight: { key: "Alt", keyCode: 18, location: 2 },
        MetaLeft: { key: "Meta", keyCode: 91, location: 1 },
        MetaRight: { key: "Meta", keyCode: 91, location: 2 },
        Minus: { key: "-", keyCode: 189 },
        Equal: { key: "=", keyCode: 187 },
        BracketLeft: { key: "[", keyCode: 219 },
        BracketRight: { key: "]", keyCode: 221 },
        Backslash: { key: "\\", keyCode: 220 },
        Semicolon: { key: ";", keyCode: 186 },
        Quote: { key: "'", keyCode: 222 },
        Backquote: { key: "`", keyCode: 192 },
        Comma: { key: ",", keyCode: 188 },
        Period: { key: ".", keyCode: 190 },
        Slash: { key: "/", keyCode: 191 }
    };

    const NUMPAD_DESCRIPTORS = {
        NumpadAdd: { key: "+", keyCode: 107, location: 3 },
        NumpadSubtract: { key: "-", keyCode: 109, location: 3 },
        NumpadMultiply: { key: "*", keyCode: 106, location: 3 },
        NumpadDivide: { key: "/", keyCode: 111, location: 3 },
        NumpadDecimal: { key: ".", keyCode: 110, location: 3 },
        NumpadEnter: { key: "Enter", keyCode: 13, location: 3 },
        NumpadEqual: { key: "=", keyCode: 187, location: 3 }
    };

    const resolveKeyDescriptor = (rawKey) => {
        const raw = String(rawKey);
        const key = KEY_ALIASES[raw] || raw;
        let keyCode;
        let code;
        let keyValue = key;
        let location;

        const preset = KEY_DESCRIPTORS[key];
        if (preset) {
            keyCode = preset.keyCode;
            code = key;
            keyValue = preset.key;
            location = preset.location;
        }

        if (keyCode == null) {
            if (/^Key[a-zA-Z]$/.test(key)) {
                const letter = key.charAt(3).toUpperCase();
                keyCode = letter.charCodeAt(0);
                code = key;
                keyValue = letter.toLowerCase();
            } else if (/^Digit[0-9]$/.test(key)) {
                const digit = key.charAt(5);
                keyCode = 48 + parseInt(digit, 10);
                code = key;
                keyValue = digit;
            } else if (/^F([1-9]|1[0-9]|2[0-4])$/.test(key)) {
                const number = parseInt(key.slice(1), 10);
                keyCode = 111 + number;
                code = key;
                keyValue = key;
            } else if (/^Numpad[0-9]$/.test(key)) {
                const digit = parseInt(key.slice(6), 10);
                keyCode = 96 + digit;
                code = key;
                keyValue = String(digit);
                location = 3;
            } else if (NUMPAD_DESCRIPTORS[key]) {
                const numpadPreset = NUMPAD_DESCRIPTORS[key];
                keyCode = numpadPreset.keyCode;
                code = key;
                keyValue = numpadPreset.key;
                location = numpadPreset.location;
            } else if (key.length === 1) {
                const upper = key.toUpperCase();
                keyCode = upper.charCodeAt(0);
                code = upper;
                keyValue = key;
            } else {
                keyCode = key.toUpperCase().charCodeAt(0);
                code = key;
                keyValue = key;
            }
        }

        return { key: keyValue, code, keyCode, location };
    };

    const simulateKeyEvent = (key, type) => {
        const { key: keyValue, code, keyCode, location } = resolveKeyDescriptor(key);

        if (typeof KeyboardEvent === "undefined") return;

        const eventOptions = {
            key: keyValue,
            code: code,
            keyCode: keyCode,
            which: keyCode,
            bubbles: true,
            cancelable: true
        };
        if (location != null) {
            eventOptions.location = location;
        }
        const event = new KeyboardEvent(type, eventOptions);

        const canvas = typeof document !== "undefined" ? document.querySelector("canvas") : null;
        if (canvas && typeof canvas.focus === "function") {
            canvas.focus();
            canvas.dispatchEvent(event);
        } else if (typeof document !== "undefined") {
            document.dispatchEvent(event);
        }
    };

    const sanitizeActionMeta = (actionMeta) => {
        if (!actionMeta || typeof actionMeta !== "object") return {};
        const allowedBehavior = new Set(["continuous", "discrete"]);
        const allowedInteraction = new Set(["tap", "hold", "repeat"]);
        const allowedControlSpace = new Set(["vector", "rate", "magnitude"]);
        const allowedActivation = new Set(["hold", "latch"]);
        const allowedDirectionMode = new Set(["vector", "cardinal"]);
        const allowedGranularity = new Set(["fine", "coarse"]);
        const allowedPairPosition = new Set(["left", "right"]);

        const sanitized = {};
        Object.entries(actionMeta).forEach(([action, meta]) => {
            if (!meta || typeof meta !== "object") return;
            const cleaned = {};
            Object.entries(meta).forEach(([key, value]) => {
                if (key === "behavior" && allowedBehavior.has(value)) cleaned[key] = value;
                else if (key === "interaction" && allowedInteraction.has(value)) cleaned[key] = value;
                else if (key === "simultaneous" && typeof value === "boolean") cleaned[key] = value;
                else if (key === "control_space" && allowedControlSpace.has(value)) cleaned[key] = value;
                else if (key === "activation" && allowedActivation.has(value)) cleaned[key] = value;
                else if (key === "direction_mode" && allowedDirectionMode.has(value)) cleaned[key] = value;
                else if (key === "granularity" && allowedGranularity.has(value)) cleaned[key] = value;
                else if (key === "pair_id" && typeof value === "string") cleaned[key] = value;
                else if (key === "pair_position" && allowedPairPosition.has(value)) cleaned[key] = value;
                else if (key === "kind" && typeof value === "string") cleaned[key] = value;
            });
            if (Object.keys(cleaned).length) {
                sanitized[action] = cleaned;
            }
        });
        return sanitized;
    };

    const extractMeta = (spec, kind) => {
        const meta = {};
        if (spec && typeof spec === "object") {
            ["behavior", "interaction", "simultaneous", "control_space", "activation", "direction_mode", "granularity", "pair_id", "pair_position"].forEach((field) => {
                if (field in spec) meta[field] = spec[field];
            });
        }
        if (kind) meta.kind = kind;
        return meta;
    };

    const extractActionKeys = (spec) => {
        if (spec && typeof spec === "object") {
            if ("keys" in spec) return spec.keys;
            if ("key" in spec) return spec.key;
        }
        return spec;
    };

    const selectSingleKey = (keys) => {
        if (!keys || typeof keys !== "object") return null;
        const order = ["up", "right", "down", "left"];
        for (let i = 0; i < order.length; i += 1) {
            const key = keys[order[i]];
            if (key) return key;
        }
        return null;
    };

    const axisPriority = (axis) => {
        const priority = axis.priority;
        const priorityScore = priority === "primary" ? 2 : priority === "secondary" ? 1 : 0;
        const controlSpace = axis.control_space;
        const controlScore = controlSpace === "vector" ? 2 : controlSpace === "rate" ? 1 : 0;
        return [priorityScore, controlScore];
    };

    const extractBindingsFromAxesActions = (data) => {
        if (!data || typeof data !== "object") return null;
        const axes = data.axes;
        const actions = data.actions;
        if (!Array.isArray(axes) && (typeof actions !== "object" || actions === null)) {
            return null;
        }

        const bindings = {};
        let actionMeta = {};

        if (actions && typeof actions === "object") {
            Object.entries(actions).forEach(([role, spec]) => {
                const keys = extractActionKeys(spec);
                if (!keys) return;
                bindings[role] = keys;
                const meta = extractMeta(spec, "button");
                if (Object.keys(meta).length) {
                    actionMeta[role] = meta;
                }
            });
        }

        const movementAxes = [];
        const aimAxes = [];

        if (Array.isArray(axes)) {
            axes.forEach((axis) => {
                if (!axis || typeof axis !== "object") return;
                const keys = axis.keys;
                if (!keys || typeof keys !== "object") return;
                const usage = axis.usage;
                const controlSpace = axis.control_space;
                if (usage !== "movement" && usage !== "aim") return;

                if (controlSpace === "magnitude") {
                    if (bindings.magnitude) return;
                    const magKey = selectSingleKey(keys);
                    if (!magKey) return;
                    bindings.magnitude = magKey;
                    const magMeta = extractMeta(axis, "button");
                    magMeta.control_space = "magnitude";
                    actionMeta.magnitude = magMeta;
                    return;
                }

                if (usage === "movement") movementAxes.push(axis);
                if (usage === "aim") aimAxes.push(axis);
            });
        }

        const buildAxisMapping = (axis) => {
            const keys = axis.keys;
            const meta = extractMeta(axis, "axis");
            if (axis.control_space) meta.control_space = axis.control_space;
            return { keys, meta };
        };

        const compareAxis = (a, b) => {
            const [ap, ac] = axisPriority(a);
            const [bp, bc] = axisPriority(b);
            if (ap !== bp) return bp - ap;
            return bc - ac;
        };

        if (movementAxes.length) {
            movementAxes.sort(compareAxis);
            const move = buildAxisMapping(movementAxes[0]);
            bindings.move = move.keys;
            if (Object.keys(move.meta).length) actionMeta.move = move.meta;

            if (aimAxes.length) {
                aimAxes.sort(compareAxis);
                const aim = buildAxisMapping(aimAxes[0]);
                bindings.aim = aim.keys;
                if (Object.keys(aim.meta).length) actionMeta.aim = aim.meta;
            }
        } else if (aimAxes.length) {
            aimAxes.sort(compareAxis);
            const move = buildAxisMapping(aimAxes[0]);
            bindings.move = move.keys;
            if (Object.keys(move.meta).length) actionMeta.move = move.meta;

            if (aimAxes.length > 1) {
                const aim = buildAxisMapping(aimAxes[1]);
                bindings.aim = aim.keys;
                if (Object.keys(aim.meta).length) actionMeta.aim = aim.meta;
            }
        }

        actionMeta = sanitizeActionMeta(actionMeta);
        return { bindings, actionMeta };
    };

    const resolveBindingsAndMeta = (config = {}) => {
        let bindings = config.bindings || {};
        let actionMeta = config.actionMeta || config.action_meta || {};

        let analysis = null;
        if (Array.isArray(config.axes) || (config.actions && typeof config.actions === "object")) {
            analysis = { axes: config.axes || [], actions: config.actions || {} };
        } else if (bindings && typeof bindings === "object" && (bindings.axes || bindings.actions)) {
            analysis = { axes: bindings.axes || [], actions: bindings.actions || {} };
        } else if (actionMeta && typeof actionMeta === "object" && (actionMeta.axes || actionMeta.actions)) {
            analysis = { axes: actionMeta.axes || [], actions: actionMeta.actions || {} };
        }

        if (analysis) {
            const extracted = extractBindingsFromAxesActions(analysis);
            if (extracted) {
                bindings = extracted.bindings || {};
                actionMeta = extracted.actionMeta || {};
            }
        }

        if (!bindings || typeof bindings !== "object") bindings = {};
        if (!actionMeta || typeof actionMeta !== "object") actionMeta = {};

        return { bindings, actionMeta };
    };

    const parseKeys = (keys) => {
        let keyMap = { left: null, right: null, up: null, down: null, key: null };

        if (Array.isArray(keys)) {
            if (keys.length === 2) {
                keyMap.left = keys[0] || null;
                keyMap.right = keys[1] || null;
            } else if (keys.length === 1) {
                keyMap.key = keys[0];
            } else {
                keyMap.left = keys[0] || null;
                keyMap.right = keys[1] || null;
                keyMap.up = keys[2] || null;
                keyMap.down = keys[3] || null;
            }
        } else if (keys && typeof keys === "object") {
            keyMap.left = keys.left || null;
            keyMap.right = keys.right || null;
            keyMap.up = keys.up || null;
            keyMap.down = keys.down || null;
            if (keys.key) keyMap.key = keys.key;
        } else if (typeof keys === "string") {
            keyMap.key = keys;
        }

        return keyMap;
    };

    const createNipple = (element, keys) => {
        if (typeof nipplejs === "undefined") {
            throw new Error(
                "[touchpad_controls] nipplejs is required to create joystick controls. " +
                "Include nipplejs before touchpad-controls.js."
            );
        }

        const options = {
            zone: element,
            mode: "static",
            position: { top: "50%", left: "50%" },
            color: "gray",
            size: 120,
            threshold: 0.25
        };

        const keyMap = parseKeys(keys);

        const hasLeft = keyMap.left != null;
        const hasRight = keyMap.right != null;
        const hasUp = keyMap.up != null;
        const hasDown = keyMap.down != null;
        const hasSingleKey = keyMap.key != null;

        if ((hasLeft || hasRight) && !(hasUp || hasDown)) {
            options.lockX = true;
        } else if ((hasUp || hasDown) && !(hasLeft || hasRight)) {
            options.lockY = true;
        } else if (hasSingleKey) {
            options.lockX = true;
            options.lockY = true;
        } else {
            options.lockX = false;
            options.lockY = false;
        }

        const manager = nipplejs.create(options);

        const activeKeys = {};
        const activeDirections = new Set();

        const getDirections = (direction) => {
            if (!direction) return [];
            const directions = [];
            if (direction.x === "left" || direction.x === "right") {
                directions.push(direction.x);
            }
            if (direction.y === "up" || direction.y === "down") {
                directions.push(direction.y);
            }
            return directions;
        };

        manager.on("start", () => {
            element.classList.add("is-active");
        });

        const syncDirections = (directionsSet) => {
            const toRelease = [];
            activeDirections.forEach((direction) => {
                if (!directionsSet.has(direction)) {
                    toRelease.push(direction);
                }
            });

            toRelease.forEach((direction) => {
                const key = keyMap[direction];
                if (key && activeKeys[key]) {
                    simulateKeyEvent(key, "keyup");
                    activeKeys[key] = false;
                }
                activeDirections.delete(direction);
            });

            directionsSet.forEach((direction) => {
                if (activeDirections.has(direction)) return;
                const key = keyMap[direction];
                if (!key) return;
                if (!activeKeys[key]) {
                    simulateKeyEvent(key, "keydown");
                    activeKeys[key] = true;
                }
                activeDirections.add(direction);
            });
        };

        manager.on("dir", (evt, data) => {
            const directions = getDirections(data && data.direction);
            if (!directions.length) return;
            syncDirections(new Set(directions));
        });

        const releaseAllKeys = () => {
            Object.keys(activeKeys).forEach((key) => {
                if (activeKeys[key]) {
                    simulateKeyEvent(key, "keyup");
                    activeKeys[key] = false;
                }
            });
            activeDirections.clear();
        };

        manager.on("move", (evt, data) => {
            if (!data || !data.direction) {
                releaseAllKeys();
                return;
            }

            const currentDirections = new Set();
            if (data.direction.x) currentDirections.add(data.direction.x);
            if (data.direction.y) currentDirections.add(data.direction.y);

            syncDirections(currentDirections);
        });

        manager.on("end", () => {
            releaseAllKeys();
            element.classList.remove("is-active");
        });

        return manager;
    };

    const createButton = (element, key) => {
        const keys = Array.isArray(key) ? key.filter((k) => k != null) : [key];
        if (!keys.length) return;

        let isActive = false;

        const press = (event) => {
            if (event && typeof event.preventDefault === "function") {
                event.preventDefault();
            }
            if (isActive) return;
            isActive = true;
            element.classList.add("is-active");
            keys.forEach((k) => simulateKeyEvent(k, "keydown"));
        };

        const release = (event) => {
            if (event && typeof event.preventDefault === "function") {
                event.preventDefault();
            }
            if (!isActive) return;
            isActive = false;
            element.classList.remove("is-active");
            keys.forEach((k) => simulateKeyEvent(k, "keyup"));
        };

        const handleMouseDown = (event) => {
            press(event);
            const handleMouseUp = (e) => {
                release(e);
                window.removeEventListener("mouseup", handleMouseUp);
            };
            window.addEventListener("mouseup", handleMouseUp);
        };

        const handleTouchStart = (event) => {
            press(event);
            const handleTouchEndOrCancel = (e) => {
                release(e);
                window.removeEventListener("touchend", handleTouchEndOrCancel);
                window.removeEventListener("touchcancel", handleTouchEndOrCancel);
            };
            window.addEventListener("touchend", handleTouchEndOrCancel);
            window.addEventListener("touchcancel", handleTouchEndOrCancel);
        };

        element.addEventListener("mousedown", handleMouseDown);
        element.addEventListener("touchstart", handleTouchStart, {
            passive: false
        });

        element.addEventListener("mouseup", release);
        element.addEventListener("mouseleave", release);
        element.addEventListener("touchend", release);
        element.addEventListener("touchcancel", release);
    };

    const createTouchpadControls = (config = {}) => {
        if (typeof document === "undefined") {
            throw new Error("[touchpad_controls] document is required to render controls.");
        }

        injectTouchpadStyles();

        const root = config.root || document.body || document.documentElement;
        const baseTheme = normalizeTheme(config.theme);
        const buttons = Array.isArray(config.buttons) ? config.buttons : [];

        const touchpads = [];
        const nippleManagers = [];

        buttons.forEach((btn) => {
            if (!btn) return;

            const theme = mergeTheme(baseTheme, btn.theme);
            const touchpad = document.createElement("div");
            touchpad.id = btn.id || "";
            touchpad.className = "touchpad";

            if (btn.className) {
                touchpad.className += " " + btn.className;
            }
            if (Array.isArray(btn.classList)) {
                btn.classList.forEach((cls) => {
                    if (cls) touchpad.classList.add(cls);
                });
            }

            let type = btn.type;
            if (!type) {
                if (
                    (Array.isArray(btn.keys) && btn.keys.length > 1) ||
                    (btn.keys && typeof btn.keys === "object" && !Array.isArray(btn.keys))
                ) {
                    type = "joystick";
                } else {
                    type = "button";
                }
            }

            const labelMode = btn.labelMode || theme.labelMode || "none";
            const labelText = type === "button" ? resolveLabelText(btn, labelMode) : "";
            if (labelText) {
                const labelEl = document.createElement("span");
                labelEl.className = "touchpad-label";
                labelEl.textContent = labelText;
                touchpad.classList.add("touchpad--label");
                touchpad.appendChild(labelEl);
            }

            const ariaLabel = btn.label != null
                ? String(btn.label)
                : (labelText || (typeof btn.keys === "string" ? keyLabel(btn.keys) : ""));
            if (ariaLabel) {
                touchpad.setAttribute("aria-label", ariaLabel);
            }

            const sectionName = btn.section;
            const section = sectionName && sections[sectionName] ? sections[sectionName] : null;

            safeEntries(section).forEach(([key, value]) => {
                touchpad.style[key] = value;
            });

            const posName = btn.position;
            const buttonPosition =
                posName && buttonPositions[posName]
                    ? buttonPositions[posName]
                    : null;

            if (section && buttonPosition) {
                safeEntries(buttonPosition).forEach(([key, value]) => {
                    const base = section[key] || "0px";
                    touchpad.style[key] = `calc(${base} + ${value})`;
                });
            }

            if (btn.top != null) {
                touchpad.style.top = formatCssValue(btn.top);
            }
            if (btn.left != null) {
                touchpad.style.left = formatCssValue(btn.left);
            }
            if (btn.x != null) {
                touchpad.style.left = formatCssValue(btn.x);
            }
            if (btn.y != null) {
                touchpad.style.top = formatCssValue(btn.y);
            }

            safeEntries(btn.style).forEach(([key, value]) => {
                if (value != null) {
                    touchpad.style[key] = formatCssValue(value);
                }
            });

            applyThemeVars(touchpad, theme);

            const showIcon = labelMode !== "text" && labelMode !== "key";
            if (showIcon) {
                const icon = resolveIcon(btn, theme);
                if (icon) {
                    touchpad.style.setProperty("--touchpad-icon", icon);
                }
            }

            root.appendChild(touchpad);

            touchpad.dataset.touchpadType = type;
            if (type === "joystick") {
                touchpad.classList.add("touchpad--joystick");
            } else {
                touchpad.classList.add("touchpad--button");
            }

            const tp = { element: touchpad, keys: btn.keys, type: type };
            touchpads.push(tp);
        });

        touchpads.forEach((tp) => {
            if (tp.type === "joystick") {
                const manager = createNipple(tp.element, tp.keys);
                if (manager) nippleManagers.push(manager);
            } else {
                createButton(tp.element, tp.keys);
            }
        });

        const destroy = () => {
            nippleManagers.forEach((manager) => {
                if (manager && typeof manager.destroy === "function") {
                    manager.destroy();
                }
            });

            touchpads.forEach((tp) => {
                const el = tp.element;
                if (el && el.parentNode) {
                    el.parentNode.removeChild(el);
                }
            });
        };

        return { touchpads, destroy };
    };

    const getSafeAreaInsets = (viewport) => {
        if (viewport && viewport.safeArea) {
            return {
                top: viewport.safeArea.top || 0,
                right: viewport.safeArea.right || 0,
                bottom: viewport.safeArea.bottom || 0,
                left: viewport.safeArea.left || 0
            };
        }

        if (typeof document === "undefined") {
            return { top: 0, right: 0, bottom: 0, left: 0 };
        }

        const measure = document.createElement("div");
        measure.style.cssText = [
            "position: fixed",
            "top: 0",
            "left: 0",
            "right: 0",
            "bottom: 0",
            "padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)",
            "pointer-events: none",
            "visibility: hidden"
        ].join(";");

        const root = document.body || document.documentElement;
        root.appendChild(measure);
        const style = window.getComputedStyle(measure);
        const insets = {
            top: parseFloat(style.paddingTop) || 0,
            right: parseFloat(style.paddingRight) || 0,
            bottom: parseFloat(style.paddingBottom) || 0,
            left: parseFloat(style.paddingLeft) || 0
        };
        root.removeChild(measure);
        return insets;
    };

    const normalizeBindings = (bindings = {}) => {
        const move = parseKeys(bindings.move || bindings.movement || null);
        const aim = parseKeys(bindings.aim || bindings.look || null);

        const jump = bindings.jump || null;
        const magnitude = bindings.magnitude || null;
        const primary = bindings.primary || bindings.shoot || bindings.fire || null;
        const secondary = bindings.secondary || bindings.attack || null;
        const tertiary = bindings.tertiary || (bindings.shoot && bindings.shoot !== primary ? bindings.shoot : null) || null;
        const modifier = bindings.modifier || bindings.run || null;

        return { move, aim, jump, magnitude, primary, secondary, tertiary, modifier };
    };

    const normalizeActionMeta = (actionMeta = {}) => {
        if (!actionMeta || typeof actionMeta !== "object") return {};
        return actionMeta;
    };

    const hasDirectionalKeys = (keyMap) => !!(keyMap && (keyMap.left || keyMap.right || keyMap.up || keyMap.down));

    const deriveAxisKeys = (keyMap, meta) => {
        if (!keyMap || !meta || typeof meta !== "object") return keyMap;
        const controlSpace = meta.control_space;
        if (controlSpace === "rate") {
            if (!keyMap.left && !keyMap.right) return keyMap;
            return {
                left: keyMap.left || null,
                right: keyMap.right || null,
                up: null,
                down: null
            };
        }
        if (controlSpace === "magnitude") {
            if (!keyMap.up && !keyMap.down) return keyMap;
            return {
                left: null,
                right: null,
                up: keyMap.up || null,
                down: keyMap.down || null
            };
        }
        return keyMap;
    };

    const chooseLayout = (bindings, preferredLayout, actionMeta = {}) => {
        if (preferredLayout && preferredLayout !== "auto") return preferredLayout;

        const moveMeta = actionMeta && actionMeta.move ? actionMeta.move : null;
        const moveKeys = deriveAxisKeys(bindings.move, moveMeta);
        const hasMove = hasDirectionalKeys(moveKeys);
        const hasAim = hasDirectionalKeys(bindings.aim);

        if (hasAim) return "dual-stick";
        if (hasMove) {
            const isCardinal = moveMeta && moveMeta.direction_mode === "cardinal";
            const isDiscrete = moveMeta && (
                moveMeta.behavior === "discrete" ||
                moveMeta.activation === "latch" ||
                moveMeta.granularity === "coarse"
            );
            const requiresChord = moveMeta && moveMeta.simultaneous === true;
            const hasVertical = !!(moveKeys.up || moveKeys.down);
            if (!requiresChord && (isDiscrete || (isCardinal && hasVertical))) {
                return "digital-dpad";
            }
            if (moveKeys.up || moveKeys.down) return "fast-platformer";
            return "safe-platformer";
        }
        return "runner";
    };

    const getLayoutMetrics = (viewport, options = {}) => {
        const width = viewport && Number.isFinite(viewport.width)
            ? viewport.width
            : (typeof window !== "undefined" ? window.innerWidth : 0);
        const height = viewport && Number.isFinite(viewport.height)
            ? viewport.height
            : (typeof window !== "undefined" ? window.innerHeight : 0);

        const safeArea = getSafeAreaInsets(viewport);
        const minDim = Math.max(1, Math.min(width, height));
        const orientation = width >= height ? "landscape" : "portrait";

        const baseSize = clamp(minDim * 0.17, 64, 112);
        const actionSize = clamp(minDim * 0.14, 56, 96);
        const smallActionSize = clamp(minDim * 0.12, MIN_TOUCH_TARGET, 80);
        const miniActionSize = clamp(minDim * 0.1, MIN_TOUCH_TARGET, 72);
        const spacing = clamp(minDim * 0.03, 10, 20);
        const edgePadding = clamp(minDim * 0.05, 16, 32);
        const verticalOffset = orientation === "portrait"
            ? clamp(minDim * 0.04, 8, 16)
            : clamp(minDim * 0.02, 6, 12);

        const bottomY = height - safeArea.bottom - edgePadding;

        return {
            width,
            height,
            orientation,
            safeArea,
            minDim,
            baseSize,
            actionSize,
            smallActionSize,
            miniActionSize,
            spacing,
            edgePadding,
            verticalOffset,
            bottomY
        };
    };

    const clampPosition = (pos, size, metrics) => {
        const minX = metrics.safeArea.left + metrics.edgePadding + size / 2;
        const maxX = metrics.width - metrics.safeArea.right - metrics.edgePadding - size / 2;
        const minY = metrics.safeArea.top + metrics.edgePadding + size / 2;
        const maxY = metrics.height - metrics.safeArea.bottom - metrics.edgePadding - size / 2;
        return {
            x: clamp(pos.x, minX, maxX),
            y: clamp(pos.y, minY, maxY)
        };
    };

    const makeButton = (spec) => {
        const baseStyle = {
            width: spec.size,
            height: spec.size,
            transform: "translate(-50%, -50%)"
        };

        return {
            id: spec.id,
            label: spec.label || "",
            keys: spec.keys,
            x: spec.x,
            y: spec.y,
            size: spec.size,
            role: spec.role,
            type: spec.type,
            meta: spec.meta || null,
            icon: spec.icon || null,
            classList: spec.classList || [],
            style: Object.assign(baseStyle, spec.style || {})
        };
    };

    const getActionSize = (sizes, role) => {
        if (!sizes) return 0;
        return sizes[role] || sizes.secondary || sizes.primary || 0;
    };

    const findPairedActions = (actions = []) => {
        const groups = new Map();
        actions.forEach((action) => {
            const meta = action && action.meta ? action.meta : null;
            const pairId = meta && meta.pair_id;
            if (!pairId) return;
            if (!groups.has(pairId)) groups.set(pairId, []);
            groups.get(pairId).push(action);
        });

        for (const [pairId, group] of groups.entries()) {
            if (group.length < 2) continue;
            let left = group.find((action) => action.meta && action.meta.pair_position === "left");
            let right = group.find((action) => action.meta && action.meta.pair_position === "right");
            if (!left || !right) {
                left = group[0];
                right = group[1];
            }
            if (left === right) continue;
            return { pairId, left, right };
        }
        return null;
    };

    const buildActionCluster = (anchor, actions, sizes, metrics) => {
        const buttons = [];
        if (!actions.length) return buttons;

        const pair = findPairedActions(actions);
        if (!pair) {
            const primary = actions[0];
            const primarySize = sizes.primary;
            const primaryPos = clampPosition(anchor, primarySize, metrics);
            buttons.push(makeButton({
                id: primary.role,
                keys: primary.keys,
                role: primary.role,
                x: primaryPos.x,
                y: primaryPos.y,
                size: primarySize,
                meta: primary.meta || null,
                classList: ["touchpad-role-" + primary.role]
            }));

            if (actions[1]) {
                const secondary = actions[1];
                const secondarySize = sizes.secondary;
                const secondaryPos = clampPosition({
                    x: anchor.x,
                    y: anchor.y - (primarySize / 2 + metrics.spacing + secondarySize / 2)
                }, secondarySize, metrics);
                buttons.push(makeButton({
                    id: secondary.role,
                    keys: secondary.keys,
                    role: secondary.role,
                    x: secondaryPos.x,
                    y: secondaryPos.y,
                    size: secondarySize,
                    meta: secondary.meta || null,
                    classList: ["touchpad-role-" + secondary.role]
                }));
            }

            if (actions[2]) {
                const tertiary = actions[2];
                const tertiarySize = sizes.tertiary;
                const tertiaryPos = clampPosition({
                    x: anchor.x - (primarySize / 2 + metrics.spacing + tertiarySize / 2),
                    y: anchor.y - primarySize * 0.2
                }, tertiarySize, metrics);
                buttons.push(makeButton({
                    id: tertiary.role,
                    keys: tertiary.keys,
                    role: tertiary.role,
                    x: tertiaryPos.x,
                    y: tertiaryPos.y,
                    size: tertiarySize,
                    meta: tertiary.meta || null,
                    classList: ["touchpad-role-" + tertiary.role]
                }));
            }

            if (actions[3]) {
                const modifier = actions[3];
                const modifierSize = sizes.modifier;
                const modifierPos = clampPosition({
                    x: anchor.x - (primarySize / 2 + metrics.spacing + modifierSize / 2),
                    y: anchor.y - (primarySize / 2 + metrics.spacing + modifierSize / 2)
                }, modifierSize, metrics);
                buttons.push(makeButton({
                    id: modifier.role,
                    keys: modifier.keys,
                    role: modifier.role,
                    x: modifierPos.x,
                    y: modifierPos.y,
                    size: modifierSize,
                    meta: modifier.meta || null,
                    classList: ["touchpad-role-" + modifier.role]
                }));
            }

            return buttons;
        }

        const used = new Set();
        const place = (action, pos, size) => {
            if (!action || used.has(action)) return;
            used.add(action);
            const clamped = clampPosition(pos, size, metrics);
            buttons.push(makeButton({
                id: action.role,
                keys: action.keys,
                role: action.role,
                x: clamped.x,
                y: clamped.y,
                size,
                meta: action.meta || null,
                classList: ["touchpad-role-" + action.role]
            }));
        };

        const primary = actions.find((action) => action.role === "primary" && action !== pair.left && action !== pair.right)
            || actions.find((action) => action !== pair.left && action !== pair.right);
        const primarySize = primary ? getActionSize(sizes, primary.role) : 0;

        const leftAction = pair.left;
        const rightAction = pair.right;
        const leftSize = getActionSize(sizes, leftAction.role);
        const rightSize = getActionSize(sizes, rightAction.role);
        const rowHeight = Math.max(leftSize, rightSize);
        const rowWidth = leftSize + rightSize + metrics.spacing;

        const minCenterX = metrics.safeArea.left + metrics.edgePadding + rowWidth / 2;
        const maxCenterX = metrics.width - metrics.safeArea.right - metrics.edgePadding - rowWidth / 2;
        const centerX = clamp(anchor.x, minCenterX, maxCenterX);

        let primaryPos = null;
        if (primary) {
            primaryPos = clampPosition({ x: centerX, y: anchor.y }, primarySize, metrics);
            place(primary, primaryPos, primarySize);
        }

        const baseY = primaryPos ? primaryPos.y : anchor.y;
        const rowY = primaryPos
            ? baseY - (primarySize / 2 + metrics.spacing + rowHeight / 2)
            : baseY;

        const leftX = centerX - rowWidth / 2 + leftSize / 2;
        const rightX = centerX + rowWidth / 2 - rightSize / 2;
        place(leftAction, { x: leftX, y: rowY }, leftSize);
        place(rightAction, { x: rightX, y: rowY }, rightSize);

        let stackY = rowY - rowHeight / 2 - metrics.spacing;
        actions.forEach((action) => {
            if (used.has(action)) return;
            const size = getActionSize(sizes, action.role);
            place(action, { x: centerX, y: stackY - size / 2 }, size);
            stackY = stackY - size - metrics.spacing;
        });

        return buttons;
    };

    const buildButtonsForLayout = (layout, bindings, metrics, actionMeta) => {
        const buttons = [];
        const actions = [];
        const roleOrder = ["magnitude", "jump", "primary", "secondary", "tertiary", "modifier"];
        const roleBaseScore = {
            magnitude: 5,
            jump: 4,
            primary: 3,
            secondary: 2,
            tertiary: 1,
            modifier: 1
        };

        const moveMeta = actionMeta && actionMeta.move ? actionMeta.move : null;
        const moveKeys = deriveAxisKeys(bindings.move, moveMeta);

        const usedKeys = new Set();
        const addAction = (role, keys) => {
            if (!keys) return;
            const signature = JSON.stringify(keys);
            if (usedKeys.has(signature)) return;
            usedKeys.add(signature);
            actions.push({
                role,
                keys,
                meta: actionMeta && actionMeta[role] ? actionMeta[role] : null
            });
        };

        roleOrder.forEach((role) => addAction(role, bindings[role]));

        actions.forEach((action, index) => {
            const meta = action.meta || {};
            let score = roleBaseScore[action.role] || 0;
            if (meta.behavior === "discrete") score += 1;
            if (meta.interaction === "tap") score += 1;
            if (meta.simultaneous === true) score += 1;
            if (meta.control_space === "magnitude") score += 2;
            if (meta.behavior === "continuous" && meta.interaction === "hold" && meta.simultaneous === false) {
                score -= 1;
            }
            action._score = score;
            action._index = index;
        });

        actions.sort((a, b) => {
            if (b._score !== a._score) return b._score - a._score;
            return a._index - b._index;
        });

        const leftAnchor = {
            x: metrics.safeArea.left + metrics.edgePadding + metrics.baseSize / 2,
            y: metrics.bottomY - metrics.baseSize / 2 - metrics.verticalOffset
        };
        const rightAnchor = {
            x: metrics.width - metrics.safeArea.right - metrics.edgePadding - metrics.baseSize / 2,
            y: metrics.bottomY - metrics.baseSize / 2 - metrics.verticalOffset
        };

        if (!actions.length && !hasDirectionalKeys(moveKeys) && !hasDirectionalKeys(bindings.aim)) {
            return buttons;
        }

        if (layout === "digital-dpad") {
            if (hasDirectionalKeys(moveKeys)) {
                const dpadSize = clamp(metrics.baseSize * 0.5, MIN_TOUCH_TARGET, metrics.baseSize * 0.75);
                const dpadGap = clamp(dpadSize * 0.2, 6, 14);
                const offset = dpadSize + dpadGap;
                const radius = offset + dpadSize / 2;
                const minCenterX = metrics.safeArea.left + metrics.edgePadding + radius;
                const maxCenterX = metrics.width - metrics.safeArea.right - metrics.edgePadding - radius;
                const minCenterY = metrics.safeArea.top + metrics.edgePadding + radius;
                const maxCenterY = metrics.height - metrics.safeArea.bottom - metrics.edgePadding - radius;
                const center = {
                    x: clamp(leftAnchor.x, minCenterX, maxCenterX),
                    y: clamp(leftAnchor.y, minCenterY, maxCenterY)
                };
                const directions = [
                    { name: "up", x: center.x, y: center.y - offset },
                    { name: "down", x: center.x, y: center.y + offset },
                    { name: "left", x: center.x - offset, y: center.y },
                    { name: "right", x: center.x + offset, y: center.y }
                ];

                directions.forEach((dir) => {
                    const key = moveKeys[dir.name];
                    if (!key) return;
                    buttons.push(makeButton({
                        id: `move-${dir.name}`,
                        keys: key,
                        role: "move",
                        x: dir.x,
                        y: dir.y,
                        size: dpadSize,
                        type: "button",
                        meta: actionMeta && actionMeta.move ? actionMeta.move : null,
                        classList: ["touchpad-role-move", "touchpad--dpad", `touchpad-move-${dir.name}`]
                    }));
                });
            }

            const clusterButtons = buildActionCluster(
                rightAnchor,
                actions,
                {
                    primary: metrics.actionSize,
                    secondary: metrics.smallActionSize,
                    tertiary: metrics.smallActionSize,
                    modifier: metrics.miniActionSize
                },
                metrics
            );
            buttons.push(...clusterButtons);
        } else if (layout === "safe-platformer" || layout === "fast-platformer") {
            if (hasDirectionalKeys(moveKeys)) {
                const moveSize = metrics.baseSize;
                const movePos = clampPosition(leftAnchor, moveSize, metrics);
                buttons.push(makeButton({
                    id: "move",
                    keys: moveKeys,
                    role: "move",
                    x: movePos.x,
                    y: movePos.y,
                    size: moveSize,
                    meta: actionMeta && actionMeta.move ? actionMeta.move : null,
                    classList: ["touchpad-role-move"]
                }));
            }

            const clusterButtons = buildActionCluster(
                rightAnchor,
                actions,
                {
                    primary: metrics.actionSize,
                    secondary: metrics.smallActionSize,
                    tertiary: metrics.smallActionSize,
                    modifier: metrics.miniActionSize
                },
                metrics
            );
            buttons.push(...clusterButtons);
        } else if (layout === "dual-stick") {
            const moveSize = clamp(metrics.baseSize * 1.05, 64, 120);
            const aimSize = clamp(metrics.baseSize * 0.95, 60, 112);

            if (hasDirectionalKeys(moveKeys)) {
                const leftPos = clampPosition({
                    x: metrics.safeArea.left + metrics.edgePadding + moveSize / 2,
                    y: metrics.bottomY - moveSize / 2 - metrics.verticalOffset
                }, moveSize, metrics);
                buttons.push(makeButton({
                    id: "move",
                    keys: moveKeys,
                    role: "move",
                    x: leftPos.x,
                    y: leftPos.y,
                    size: moveSize,
                    meta: actionMeta && actionMeta.move ? actionMeta.move : null,
                    classList: ["touchpad-role-move"]
                }));
            }

            if (hasDirectionalKeys(bindings.aim)) {
                const rightPos = clampPosition({
                    x: metrics.width - metrics.safeArea.right - metrics.edgePadding - aimSize / 2,
                    y: metrics.bottomY - aimSize / 2 - metrics.verticalOffset
                }, aimSize, metrics);
                buttons.push(makeButton({
                    id: "aim",
                    keys: bindings.aim,
                    role: "aim",
                    x: rightPos.x,
                    y: rightPos.y,
                    size: aimSize,
                    meta: actionMeta && actionMeta.aim ? actionMeta.aim : null,
                    classList: ["touchpad-role-aim"]
                }));

                if (actions[0]) {
                    const fireSize = metrics.actionSize;
                    const firePos = clampPosition({
                        x: rightPos.x,
                        y: rightPos.y - (aimSize / 2 + metrics.spacing + fireSize / 2)
                    }, fireSize, metrics);
                    buttons.push(makeButton({
                        id: actions[0].role,
                        keys: actions[0].keys,
                        role: actions[0].role,
                        x: firePos.x,
                        y: firePos.y,
                        size: fireSize,
                        meta: actions[0].meta || null,
                        classList: ["touchpad-role-" + actions[0].role]
                    }));
                }
            }
        } else if (layout === "runner") {
            const actionCount = Math.min(actions.length || 1, 4);
            const slots = actionCount === 1
                ? [0.5]
                : actionCount === 2
                    ? [0.35, 0.65]
                    : actionCount === 3
                        ? [0.2, 0.5, 0.8]
                        : [0.15, 0.4, 0.6, 0.85];

            const size = metrics.actionSize;
            const availableWidth = metrics.width - metrics.safeArea.left - metrics.safeArea.right - metrics.edgePadding * 2;
            const bandY = metrics.bottomY - size / 2 - metrics.verticalOffset;

            for (let i = 0; i < actionCount; i += 1) {
                const action = actions[i] || actions[0] || { role: "primary", keys: bindings.primary };
                const x = metrics.safeArea.left + metrics.edgePadding + availableWidth * slots[i];
                const pos = clampPosition({ x, y: bandY }, size, metrics);
                buttons.push(makeButton({
                    id: action.role,
                    keys: action.keys,
                    role: action.role,
                    x: pos.x,
                    y: pos.y,
                    size: size,
                    meta: action.meta || null,
                    classList: ["touchpad-role-" + action.role]
                }));
            }
        }

        return buttons;
    };

    const buildLayout = (config = {}) => {
        const resolved = resolveBindingsAndMeta(config);
        const normalized = normalizeBindings(resolved.bindings || {});
        const actionMeta = normalizeActionMeta(resolved.actionMeta || {});
        const layout = chooseLayout(normalized, config.layout, actionMeta);
        const metrics = getLayoutMetrics(config.viewport, config);
        const buttons = buildButtonsForLayout(layout, normalized, metrics, actionMeta);
        return { layout, buttons, metrics, bindings: normalized, actionMeta };
    };

    const roundLayoutValue = (value) => {
        if (typeof value !== "number" || !Number.isFinite(value)) return value;
        return Math.round(value * 10) / 10;
    };

    const summarizeLayout = (layoutConfig) => {
        if (!layoutConfig || typeof layoutConfig !== "object") return null;
        const buttons = Array.isArray(layoutConfig.buttons) ? layoutConfig.buttons : [];
        return {
            layout: layoutConfig.layout || null,
            buttons: buttons.map((btn) => ({
                id: btn.id || null,
                role: btn.role || null,
                type: btn.type || (btn.keys && typeof btn.keys === "object" ? "joystick" : "button"),
                keys: btn.keys || null,
                x: roundLayoutValue(btn.x),
                y: roundLayoutValue(btn.y),
                size: roundLayoutValue(btn.size)
            }))
        };
    };

    const createGesturePrevention = (options = {}) => {
        if (typeof document === "undefined") return () => {};

        const extraExclusions = Array.isArray(options.excludeSelectors) ? options.excludeSelectors : [];
        const handler = (event) => {
            if (!event || typeof event.preventDefault !== "function") return;
            const target = event.target;
            if (!target) {
                event.preventDefault();
                return;
            }

            const tagName = target.tagName;
            const blockedTags = ["SELECT", "OPTION", "BUTTON", "INPUT", "TEXTAREA", "A"];
            if (tagName && blockedTags.includes(tagName)) return;

            if (extraExclusions.some((selector) => target.closest && target.closest(selector))) return;

            event.preventDefault();
        };

        document.addEventListener("touchmove", handler, { passive: false });
        document.addEventListener("touchstart", handler, { passive: false });
        document.addEventListener("gesturestart", handler);
        document.addEventListener("gesturechange", handler);
        document.addEventListener("gestureend", handler);

        return () => {
            document.removeEventListener("touchmove", handler);
            document.removeEventListener("touchstart", handler);
            document.removeEventListener("gesturestart", handler);
            document.removeEventListener("gesturechange", handler);
            document.removeEventListener("gestureend", handler);
        };
    };

    const create = (config = {}) => {
        const layoutConfig = buildLayout(config);
        if (config.debug && typeof console !== "undefined" && typeof console.info === "function") {
            console.info("[touchpad_controls] layout", summarizeLayout(layoutConfig));
        }
        const hasCustomButtons = Array.isArray(config.buttons) && config.buttons.length > 0;
        const buttons = hasCustomButtons ? config.buttons : layoutConfig.buttons;
        const root = config.root;

        if (config.preventGestures !== false) {
            const excludeSelectors = config.excludeSelectors || [];
            var removeGesturePrevention = createGesturePrevention({ excludeSelectors });
        }

        let instance = createTouchpadControls({ root, buttons });
        let resizeTimer = null;

        const rebuild = () => {
            if (instance && typeof instance.destroy === "function") {
                instance.destroy();
            }
            const nextLayout = buildLayout(config);
            if (config.debug && typeof console !== "undefined" && typeof console.info === "function") {
                console.info("[touchpad_controls] layout", summarizeLayout(nextLayout));
            }
            const nextButtons = hasCustomButtons ? config.buttons : nextLayout.buttons;
            instance = createTouchpadControls({ root, buttons: nextButtons });
        };

        const handleResize = () => {
            if (resizeTimer) window.clearTimeout(resizeTimer);
            resizeTimer = window.setTimeout(rebuild, 120);
        };

        if (config.responsive !== false && typeof window !== "undefined") {
            window.addEventListener("resize", handleResize);
        }

        return {
            layout: layoutConfig.layout,
            buttons,
            diagnostics: config.debug ? summarizeLayout(layoutConfig) : null,
            destroy: () => {
                if (resizeTimer && typeof window !== "undefined") {
                    window.clearTimeout(resizeTimer);
                }
                if (config.responsive !== false && typeof window !== "undefined") {
                    window.removeEventListener("resize", handleResize);
                }
                if (instance && typeof instance.destroy === "function") {
                    instance.destroy();
                }
                if (typeof removeGesturePrevention === "function") {
                    removeGesturePrevention();
                }
            },
            rebuild
        };
    };

    return {
        createTouchpadControls,
        create,
        buildLayout,
        chooseLayout,
        getLayoutMetrics,
        parseKeys,
        simulateKeyEvent,
        resolveKeyDescriptor,
        _internal: {
            buildButtonsForLayout,
            normalizeBindings,
            clampPosition,
            summarizeLayout,
            extractBindingsFromAxesActions,
            resolveBindingsAndMeta
        }
    };
}));

</script>
    <script>
    const touchBindings = {
        "jump": "ArrowUp",
        "primary": "Space",
        "move": {
            "left": "ArrowLeft",
            "right": "ArrowRight"
        }
    };
    const touchActionMeta = {
        "jump": {
            "behavior": "discrete",
            "interaction": "tap",
            "simultaneous": true,
            "kind": "button"
        },
        "primary": {
            "behavior": "discrete",
            "interaction": "tap",
            "simultaneous": true,
            "kind": "button"
        },
        "move": {
            "behavior": "continuous",
            "interaction": "hold",
            "simultaneous": false,
            "control_space": "vector",
            "activation": "hold",
            "direction_mode": "cardinal",
            "granularity": "fine",
            "kind": "axis"
        }
    };

    TouchpadControls.create({
        layout: "auto",
        bindings: touchBindings,
        actionMeta: touchActionMeta,
        debug: true,
    });
</script>
</body>
</html>