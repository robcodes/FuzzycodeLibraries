<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubblebound!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Press Start 2P', cursive, sans-serif;
            background-color: #0c1445;
            overflow: hidden;
            color: #fff;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            margin: 0 auto;
            background-color: #0c1445;
            border: 4px solid #6a4bc4;
            border-radius: 10px;
            overflow: hidden;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(12, 20, 69, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #title {
            font-size: 48px;
            color: #f8d800;
            text-shadow: 3px 3px 0 #ff4081, 6px 6px 0 #6a4bc4;
            margin-bottom: 20px;
            animation: float 2s infinite ease-in-out;
        }

        #start-button {
            background-color: #ff4081;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-family: 'Press Start 2P', cursive, sans-serif;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
            box-shadow: 0 4px 0 #c60055;
        }

        #start-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 9px 0 #c60055;
        }

        #start-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #c60055;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 5;
            display: none;
        }

        #score, #lives {
            font-size: 14px;
            margin-bottom: 5px;
            color: #f8d800;
            text-shadow: 1px 1px 0 #6a4bc4;
        }

        #pause-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: transparent;
            border: none;
            color: #f8d800;
            font-size: 20px;
            cursor: pointer;
            z-index: 5;
            display: none;
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(12, 20, 69, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #game-over-text {
            font-size: 36px;
            color: #ff4081;
            text-shadow: 2px 2px 0 #6a4bc4;
            margin-bottom: 20px;
        }

        #final-score {
            font-size: 24px;
            color: #f8d800;
            margin-bottom: 20px;
        }

        #restart-button {
            background-color: #6a4bc4;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-family: 'Press Start 2P', cursive, sans-serif;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 0 #3a2380;
        }

        #restart-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 9px 0 #3a2380;
        }

        #restart-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #3a2380;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        .bubble {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.1));
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: float-bubble 3s infinite ease-in-out;
            opacity: 0.6;
            z-index: 0;
        }

        @keyframes float-bubble {
            0%, 100% {
                transform: translateY(0) translateX(0);
            }
            25% {
                transform: translateY(-10px) translateX(5px);
            }
            50% {
                transform: translateY(-20px) translateX(0);
            }
            75% {
                transform: translateY(-10px) translateX(-5px);
            }
        }

        #tagline {
            font-size: 16px;
            color: #fff;
            text-align: center;
            margin-bottom: 30px;
            max-width: 80%;
        }

        .instructions {
            font-size: 12px;
            color: #f8d800;
            margin-top: 20px;
            text-align: center;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="800" height="600"></canvas>

        <div id="title-screen">
            <h1 id="title">Bubblebound!</h1>
            <p id="tagline">"Join Pip, the plucky bubble sprite, on a bouncy, bubbly adventure to restore the flow of magic before it's too late!"</p>
            <button id="start-button">Start Game</button>
            <p class="instructions">Use Arrow Keys to move, Space to bounce, Z to shift bubble state</p>
        </div>

        <div id="hud">
            <div id="score">Score: 0</div>
            <div id="lives">Lives: 3</div>
        </div>

        <button id="pause-button">II</button>

        <div id="game-over">
            <h2 id="game-over-text">Game Over</h2>
            <p id="final-score">Final Score: 0</p>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <script>
        // Game state
        const gameState = {
            score: 0,
            lives: 3,
            level: 1,
            gameActive: false,
            gamePaused: false,
            bubbleState: 'solid', // 'solid' or 'airy'
            powerUp: null,
            bubblesCollected: 0,
            bubblesNeeded: 20, // Bubbles needed to complete a level
            worldIndex: 0, // Current world (0-4)
            levelIndex: 0, // Current level within world (0-5)
            showingBoss: false, // Whether a boss is currently active
            rainbowBubblesFound: 0, // Special rainbow bubbles for secret ending
            keyState: {
                left: false,
                right: false,
                up: false,
                down: false,
                space: false,
                shift: false
            }
        };

        // Game elements
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const titleScreen = document.getElementById('title-screen');
        const startButton = document.getElementById('start-button');
        const hud = document.getElementById('hud');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const pauseButton = document.getElementById('pause-button');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');

        // Game constants
        const GRAVITY = 0.5;
        const JUMP_FORCE = -12;
        const BOUNCE_FACTOR = 0.7;
        const PLAYER_SPEED = 5;
        const PLAYER_SIZE = 40;
        const PLATFORM_HEIGHT = 20;
        const BUBBLE_TYPES = ['blue', 'red', 'yellow', 'green', 'purple'];
        
        // Bubble type descriptions (based on the game premise)
        const BUBBLE_DESCRIPTIONS = {
            'blue': 'Zippy Zap Bubble - Allows Pip to burst upwards',
            'red': 'Explosive Bubble - Turns Pip into a bouncing bomb',
            'yellow': 'Feather Float Bubble - Slows descent for controlled platforming',
            'green': 'Echo Bounce Bubble - Creates a temporary platform',
            'purple': 'Magnet Bubble - Slows down enemies'
        };
        
        // Game worlds data
        const GAME_WORLDS = [
            {
                name: "Cloudspout Heights",
                background: 'https://images.fuzzycode.dev/fast_ai?search=magical%20sky%20kingdom%20pixel%20art%20background%20with%20floating%20islands&resize=800x600',
                music: 'https://sounds.fuzzycode.dev/music?prompt=airy%20upbeat%20chiptune%20platformer%20music&duration=30&ext=.mp3',
                platformColor: '#a8d0ff',
                specialFeature: 'windTunnels', // Upward air currents that boost Pip
                boss: {
                    name: "Gustfang the Tempest Serpent",
                    health: 5,
                    attackPattern: 'wind',
                    sprite: 'https://images.fuzzycode.dev/fast_ai?search=sky%20dragon%20serpent%20pixel%20art&resize=120x120&transparency=true'
                }
            },
            {
                name: "Bubble Grotto",
                background: 'https://images.fuzzycode.dev/fast_ai?search=underground%20cavern%20with%20glowing%20bubbles%20pixel%20art&resize=800x600',
                music: 'https://sounds.fuzzycode.dev/music?prompt=mysterious%20cave%20chiptune%20platformer%20music&duration=30&ext=.mp3',
                platformColor: '#7d92c2',
                specialFeature: 'geysers', // Periodic bursts that launch Pip upward
                boss: {
                    name: "The Ooze Conductor",
                    health: 6,
                    attackPattern: 'slime',
                    sprite: 'https://images.fuzzycode.dev/fast_ai?search=sludge%20monster%20conductor%20pixel%20art&resize=120x120&transparency=true'
                }
            },
            {
                name: "Stormy Skylines",
                background: 'https://images.fuzzycode.dev/fast_ai?search=stormy%20sky%20with%20lightning%20pixel%20art&resize=800x600',
                music: 'https://sounds.fuzzycode.dev/music?prompt=intense%20stormy%20chiptune%20platformer%20music&duration=30&ext=.mp3',
                platformColor: '#9e77c9',
                specialFeature: 'lightning', // Random lightning strikes to avoid
                boss: {
                    name: "General Splotch",
                    health: 7,
                    attackPattern: 'inflate',
                    sprite: 'https://images.fuzzycode.dev/fast_ai?search=inflatable%20bubble%20general%20pixel%20art&resize=120x120&transparency=true'
                }
            },
            {
                name: "Misty Marshlands",
                background: 'https://images.fuzzycode.dev/fast_ai?search=dark%20misty%20swamp%20pixel%20art&resize=800x600',
                music: 'https://sounds.fuzzycode.dev/music?prompt=eerie%20swamp%20chiptune%20platformer%20music&duration=30&ext=.mp3',
                platformColor: '#548a54',
                specialFeature: 'fog', // Reduced visibility, sound-based navigation
                boss: {
                    name: "The Fog Maw",
                    health: 8,
                    attackPattern: 'swallow',
                    sprite: 'https://images.fuzzycode.dev/fast_ai?search=giant%20mist%20monster%20with%20huge%20mouth%20pixel%20art&resize=120x120&transparency=true'
                }
            },
            {
                name: "The Hollow Core",
                background: 'https://images.fuzzycode.dev/fast_ai?search=dark%20void%20with%20reversed%20gravity%20pixel%20art&resize=800x600',
                music: 'https://sounds.fuzzycode.dev/music?prompt=ominous%20final%20boss%20chiptune%20platformer%20music&duration=30&ext=.mp3',
                platformColor: '#5e3a64',
                specialFeature: 'reverseGravity', // Gravity pulls upward
                boss: {
                    name: "Mistweaver, the Final Corruptor",
                    health: 10,
                    attackPattern: 'chaos',
                    sprite: 'https://images.fuzzycode.dev/fast_ai?search=dark%20entity%20corrupting%20bubbles%20pixel%20art&resize=120x120&transparency=true'
                }
            }
        ];

        // Game objects
        let player;
        let platforms = [];
        let bubbles = [];
        let enemies = [];
        let particles = [];
        let specialFeatures = []; // Wind tunnels, geysers, etc.
        let rainbowBubbles = []; // Special collectibles
        let currentBoss = null;
        let lastTime = 0;
        let animationId;
        let worldBackgroundImage = new Image();

        // Sprite images (using AI generated placeholder URLs - in a real game you'd use your own sprite sheets)
        const playerImage = new Image();
        playerImage.src = 'https://images.fuzzycode.dev/fast_ai?search=cute%20round%20blue%20sprite%20character%20with%20glowing%20core%20pixel%20art&resize=40x40&transparency=true';
        
        const bubbleImages = {};
        BUBBLE_TYPES.forEach(type => {
            bubbleImages[type] = new Image();
            bubbleImages[type].src = `https://images.fuzzycode.dev/fast_ai?search=${type}%20bubble%20pixel%20art&resize=30x30&transparency=true`;
        });

        const enemyImage = new Image();
        enemyImage.src = 'https://images.fuzzycode.dev/fast_ai?search=spiky%20dark%20bubble%20enemy%20pixel%20art&resize=40x40&transparency=true';

        const platformImage = new Image();
        platformImage.src = 'https://images.fuzzycode.dev/fast_ai?search=floating%20cloud%20platform%20pixel%20art&resize=150x30&transparency=true';

        const backgroundImage = new Image();
        backgroundImage.src = 'https://images.fuzzycode.dev/fast_ai?search=magical%20sky%20kingdom%20pixel%20art%20background&resize=800x600';

        // Sound effects
        const sounds = {
            bounce: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=bubble%20bounce%20sound&duration=0.5&ext=.mp3'),
            collect: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=bubble%20pop%20collect%20sound&duration=0.5&ext=.mp3'),
            hurt: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=character%20hurt%20sound&duration=0.5&ext=.mp3'),
            gameOver: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=game%20over%20sad%20sound&duration=1&ext=.mp3'),
            shift: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=bubble%20shift%20sound&duration=0.5&ext=.mp3')
        };

        // Background music
        const bgMusic = new Audio('https://sounds.fuzzycode.dev/music?prompt=upbeat%20chiptune%20platformer%20music&duration=30&ext=.mp3');
        bgMusic.loop = true;
        bgMusic.volume = 0.5;

        // Player class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = PLAYER_SIZE;
                this.height = PLAYER_SIZE;
                this.velocity = {
                    x: 0,
                    y: 0
                };
                this.color = '#64c5ff';
                this.isGrounded = false;
                this.canBounce = true;
                this.bubbleState = 'solid'; // 'solid' or 'airy'
                this.powerUp = null;
                this.powerUpTimer = 0;
                this.flickerTimer = 0;
                this.isInvulnerable = false;
                this.isBouncing = false;
                this.frame = 0;
                this.frameCount = 0;
                this.hue = 0;
                this.collisionDebounce = 0; // Add debounce for collision detection
                this.consecutiveBounces = 0; // Track consecutive bounces for momentum-based movement
                this.name = "Pip"; // The protagonist's name
            }

            update(deltaTime) {
                // Movement
                if (gameState.keyState.left) this.velocity.x = -PLAYER_SPEED;
                else if (gameState.keyState.right) this.velocity.x = PLAYER_SPEED;
                else this.velocity.x *= 0.9; // Friction

                // Reset grounded state at the beginning of update
                if (this.collisionDebounce > 0) {
                    this.collisionDebounce--;
                } else {
                    this.isGrounded = false;
                }

                // Reset consecutive bounces if landed
                if (this.isGrounded && this.consecutiveBounces > 0) {
                    // Don't reset immediately to allow for rhythmic bouncing
                    if (!gameState.keyState.space) {
                        this.consecutiveBounces = 0;
                    }
                }

                // Gravity depends on bubble state and power-ups
                let gravityModifier = 1;
                
                if (this.bubbleState === 'airy') {
                    gravityModifier = 0.5; // 50% gravity in airy state
                }
                
                // Feather Float power-up (yellow) effect
                if (this.slowDescent) {
                    gravityModifier *= 0.7; // Further reduce gravity
                }
                
                this.velocity.y += GRAVITY * gravityModifier;

                // Apply velocity
                this.x += this.velocity.x;
                this.y += this.velocity.y;

                // Boundary collisions
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
                
                // Bottom boundary - lose a life
                if (this.y > canvas.height) {
                    this.reset();
                    gameState.lives--;
                    livesDisplay.textContent = `Lives: ${gameState.lives}`;
                    sounds.hurt.play();
                    
                    if (gameState.lives <= 0) {
                        gameOver();
                    }
                }

                // Power-up timer
                if (this.powerUp && this.powerUpTimer > 0) {
                    this.powerUpTimer -= deltaTime;
                    if (this.powerUpTimer <= 0) {
                        this.powerUp = null;
                        this.slowDescent = false; // Make sure to reset any power-up effects
                    }
                }

                // Invulnerability flicker
                if (this.isInvulnerable) {
                    this.flickerTimer -= deltaTime;
                    if (this.flickerTimer <= 0) {
                        this.isInvulnerable = false;
                    }
                }

                // Animation
                this.frameCount++;
                if (this.frameCount >= 5) {
                    this.frame = (this.frame + 1) % 4;
                    this.frameCount = 0;
                }

                // Color cycling for visual effect - changes based on state and power-up
                this.hue = (this.hue + 1) % 360;
            }

            draw() {
                if (this.isInvulnerable && Math.floor(this.flickerTimer / 100) % 2 === 0) {
                    return; // Skip drawing to create flicker effect
                }

                // Create glowing effect
                const glow = this.powerUp ? 20 : 10;
                ctx.shadowBlur = glow;
                ctx.shadowColor = this.getColor();

                // Draw the player
                ctx.fillStyle = this.getColor();
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();

                // Inner glow
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2 - 5, this.y + this.height / 2 - 5, this.width / 4, 0, Math.PI * 2);
                ctx.fill();

                // Reset shadow
                ctx.shadowBlur = 0;

                // Indicate bubble state
                const stateBubbles = this.bubbleState === 'airy' ? 3 : 0;
                if (stateBubbles > 0) {
                    for (let i = 0; i < stateBubbles; i++) {
                        const angle = (i / stateBubbles) * Math.PI * 2 + this.frame * 0.2;
                        const distance = this.width * 0.7;
                        const bubbleX = this.x + this.width / 2 + Math.cos(angle) * distance;
                        const bubbleY = this.y + this.height / 2 + Math.sin(angle) * distance;
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Show power-up effect
                if (this.powerUp) {
                    const pulseSize = 5 + Math.sin(Date.now() * 0.01) * 3;
                    ctx.strokeStyle = this.getPowerUpColor();
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2 + pulseSize, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            getColor() {
                if (this.powerUp) {
                    return this.getPowerUpColor();
                }
                
                if (this.bubbleState === 'airy') {
                    return `hsl(${this.hue}, 80%, 70%)`;
                } else {
                    return `hsl(210, 80%, 60%)`;
                }
            }

            getPowerUpColor() {
                switch (this.powerUp) {
                    case 'blue': return '#1e90ff';
                    case 'red': return '#ff4500';
                    case 'yellow': return '#ffd700';
                    case 'green': return '#32cd32';
                    case 'purple': return '#9370db';
                    default: return '#ffffff';
                }
            }

            bounce() {
                if (this.canBounce) {
                    // Momentum-based bouncing - consecutive bounces get higher
                    this.consecutiveBounces++;
                    let bounceForce = JUMP_FORCE;
                    
                    // Increase bounce height for consecutive bounces (up to a limit)
                    if (this.consecutiveBounces > 1) {
                        const bonusFactor = Math.min(this.consecutiveBounces * 0.2, 1.0);
                        bounceForce *= (1 + bonusFactor);
                    }
                    
                    this.velocity.y = bounceForce;
                    this.isGrounded = false;
                    this.canBounce = false;
                    this.isBouncing = true;
                    this.collisionDebounce = 0; // Reset collision debounce on bounce
                    sounds.bounce.play();
                    
                    // Create bounce particles
                    for (let i = 0; i < 8; i++) {
                        particles.push(new Particle(
                            this.x + this.width / 2,
                            this.y + this.height,
                            Math.random() * 4 - 2,
                            -Math.random() * 2 - 1,
                            Math.random() * 5 + 3,
                            this.getColor()
                        ));
                    }

                    // Apply power-up effects on bounce
                    if (this.powerUp) {
                        switch (this.powerUp) {
                            case 'blue': // Zippy Zap Bubble - Higher jump
                                this.velocity.y *= 1.5;
                                break;
                            case 'red': // Explosive Bubble
                                for (let i = 0; i < 20; i++) {
                                    particles.push(new Particle(
                                        this.x + this.width / 2,
                                        this.y + this.height,
                                        Math.random() * 8 - 4,
                                        -Math.random() * 4 - 2,
                                        Math.random() * 8 + 5,
                                        '#ff4500'
                                    ));
                                }
                                // Damage nearby enemies
                                enemies.forEach(enemy => {
                                    const dx = enemy.x + enemy.width/2 - (this.x + this.width/2);
                                    const dy = enemy.y + enemy.height/2 - (this.y + this.height/2);
                                    const distance = Math.sqrt(dx*dx + dy*dy);
                                    if (distance < 150) {
                                        enemy.velocity.x += dx/distance * 10;
                                        enemy.velocity.y += dy/distance * 10;
                                    }
                                });
                                break;
                            case 'yellow': // Feather Float Bubble - Slow descent
                                this.velocity.x *= 1.5;
                                // Set a flag for slower descent
                                this.slowDescent = true;
                                setTimeout(() => this.slowDescent = false, 3000);
                                break;
                            case 'green': // Echo Bounce Bubble - Create platform
                                platforms.push(new Platform(
                                    this.x - 50 + Math.random() * 100,
                                    this.y + 100,
                                    100,
                                    PLATFORM_HEIGHT
                                ));
                                break;
                            case 'purple': // Magnet Bubble - Time slow effect
                                // Visual effect to show time slowing
                                for (let i = 0; i < 30; i++) {
                                    particles.push(new Particle(
                                        this.x + this.width/2,
                                        this.y + this.height/2,
                                        Math.random() * 8 - 4,
                                        Math.random() * 8 - 4,
                                        Math.random() * 5 + 2,
                                        '#9370db'
                                    ));
                                }
                                // Slow down enemies
                                enemies.forEach(enemy => {
                                    enemy.slowTimer = 3000; // Slow for 3 seconds
                                });
                                break;
                        }
                    }
                }
            }

            toggleBubbleState() {
                this.bubbleState = this.bubbleState === 'solid' ? 'airy' : 'solid';
                sounds.shift.play();
                
                // Create shift particles
                for (let i = 0; i < 12; i++) {
                    particles.push(new Particle(
                        this.x + this.width / 2,
                        this.y + this.height / 2,
                        Math.random() * 6 - 3,
                        Math.random() * 6 - 3,
                        Math.random() * 5 + 5,
                        this.bubbleState === 'airy' ? '#aff' : '#88f'
                    ));
                }
            }

            reset() {
                this.x = canvas.width / 2 - this.width / 2;
                this.y = canvas.height / 2;
                this.velocity.x = 0;
                this.velocity.y = 0;
                this.isInvulnerable = true;
                this.flickerTimer = 2000; // 2 seconds of invulnerability
                this.powerUp = null;
            }

            collectBubble(bubble) {
                gameState.score += bubble.isRainbow ? 50 : 10;
                scoreDisplay.textContent = `Score: ${gameState.score}`;
                sounds.collect.play();
                
                // Track bubbles collected for level progression
                gameState.bubblesCollected++;
                
                // Track rainbow bubbles for secret ending
                if (bubble.isRainbow) {
                    gameState.rainbowBubblesFound++;
                    // Special rainbow collection sound
                    const rainbowSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=magical%20chime%20special%20item%20collect&duration=1&ext=.mp3');
                    rainbowSound.volume = 0.7;
                    rainbowSound.play();
                }
                
                // Apply power-up
                if (bubble.type !== 'normal') {
                    this.powerUp = bubble.type;
                    this.powerUpTimer = 5000; // 5 seconds
                }
                
                // Create collection particles
                const particleCount = bubble.isRainbow ? 20 : 10;
                for (let i = 0; i < particleCount; i++) {
                    particles.push(new Particle(
                        bubble.x + bubble.radius,
                        bubble.y + bubble.radius,
                        Math.random() * 4 - 2,
                        Math.random() * 4 - 2,
                        Math.random() * 5 + 3,
                        bubble.color
                    ));
                }
                
                // Check if level is complete
                if (gameState.bubblesCollected >= gameState.bubblesNeeded && !gameState.showingBoss) {
                    showLevelComplete();
                }
            }

            hitEnemy() {
                if (!this.isInvulnerable) {
                    gameState.lives--;
                    livesDisplay.textContent = `Lives: ${gameState.lives}`;
                    sounds.hurt.play();
                    this.isInvulnerable = true;
                    this.flickerTimer = 2000; // 2 seconds of invulnerability
                    
                    if (gameState.lives <= 0) {
                        gameOver();
                    }
                }
            }
        }

        // Platform class
        class Platform {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = '#a67df8';
                this.velocity = {
                    x: 0,
                    y: 0
                };
                this.isMoving = Math.random() > 0.7;
                if (this.isMoving) {
                    this.velocity.x = Math.random() * 2 - 1;
                    this.originalX = x;
                    this.movementRange = Math.random() * 100 + 50;
                }
            }

            update() {
                if (this.isMoving) {
                    this.x += this.velocity.x;
                    
                    // Reverse direction at movement limits
                    if (this.x < this.originalX - this.movementRange || 
                        this.x > this.originalX + this.movementRange) {
                        this.velocity.x *= -1;
                    }
                }
            }

            draw() {
                // Platform shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(this.x + 5, this.y + 5, this.width, this.height);
                
                // Platform
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Platform top highlight
                ctx.fillStyle = '#c4a9ff';
                ctx.fillRect(this.x, this.y, this.width, 5);
            }
        }

        // Bubble class
        class Bubble {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 15 + 15;
                this.velocity = {
                    x: Math.random() * 2 - 1,
                    y: -Math.random() * 2 - 1
                };
                this.type = Math.random() > 0.7 ? BUBBLE_TYPES[Math.floor(Math.random() * BUBBLE_TYPES.length)] : 'normal';
                this.isRainbow = Math.random() > 0.95; // Very rare rainbow bubbles
                this.color = this.getBubbleColor();
                this.opacity = 0.8;
                this.collected = false;
                this.animationOffset = Math.random() * Math.PI * 2;
            }

            getBubbleColor() {
                if (this.isRainbow) {
                    // Rainbow effect for special bubbles
                    const hue = (Date.now() * 0.1) % 360;
                    return `hsl(${hue}, 100%, 70%)`;
                }
                
                switch (this.type) {
                    case 'blue': return '#1e90ff';
                    case 'red': return '#ff4500';
                    case 'yellow': return '#ffd700';
                    case 'green': return '#32cd32';
                    case 'purple': return '#9370db';
                    default: return '#64c5ff';
                }
            }

            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                
                // Bubble float effect
                this.y += Math.sin(Date.now() * 0.002 + this.animationOffset) * 0.5;
                
                // Boundary checks with bounce
                if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                    this.velocity.x *= -1;
                }
                
                if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) {
                    this.velocity.y *= -1;
                }
                
                // Slow down over time
                this.velocity.x *= 0.99;
                this.velocity.y *= 0.99;
            }

            draw() {
                ctx.globalAlpha = this.opacity;
                
                // Outer bubble
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // Bubble shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.radius * 0.8, this.radius * 0.5, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 1;
            }
        }

        // Enemy class
        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.velocity = {
                    x: Math.random() * 4 - 2,
                    y: Math.random() * 2 - 1
                };
                this.color = '#ff5252';
                this.frame = 0;
                this.frameCount = 0;
                this.type = this.getRandomType();
                this.slowTimer = 0; // For purple bubble effect
            }
            
            getRandomType() {
                const types = ['popper', 'goop', 'vacublow', 'mimic'];
                return types[Math.floor(Math.random() * types.length)];
            }

            update() {
                // Apply slow effect from purple bubble
                let speedModifier = 1;
                if (this.slowTimer > 0) {
                    this.slowTimer -= 16; // Assuming ~60fps
                    speedModifier = 0.3; // 30% normal speed when slowed
                }
                
                this.x += this.velocity.x * speedModifier;
                this.y += this.velocity.y * speedModifier;
                
                // Boundary checks with bounce
                if (this.x < 0 || this.x + this.width > canvas.width) {
                    this.velocity.x *= -1;
                }
                
                if (this.y < 0 || this.y + this.height > canvas.height) {
                    this.velocity.y *= -1;
                }
                
                // Type-specific behavior
                switch(this.type) {
                    case 'popper':
                        // Popper Patrol - seeks out bubbles to pop them
                        this.popperBehavior();
                        break;
                    case 'goop':
                        // Goop Gliders - occasionally drops slime
                        this.goopBehavior();
                        break;
                    case 'vacublow':
                        // Vacublow Fish - sucks and blows bubbles
                        this.vacublowBehavior();
                        break;
                    case 'mimic':
                        // Bubble Mimics - pretends to be power-ups
                        this.mimicBehavior();
                        break;
                }
                
                // Animation
                this.frameCount++;
                if (this.frameCount >= 10) {
                    this.frame = (this.frame + 1) % 4;
                    this.frameCount = 0;
                }
            }
            
            // Enemy-specific behaviors
            popperBehavior() {
                // Find the nearest bubble and move toward it
                let nearestBubble = null;
                let nearestDistance = Infinity;
                
                bubbles.forEach(bubble => {
                    const dx = bubble.x - (this.x + this.width/2);
                    const dy = bubble.y - (this.y + this.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestBubble = bubble;
                    }
                });
                
                // If a bubble is nearby, seek it
                if (nearestBubble && nearestDistance < 200) {
                    const dx = nearestBubble.x - (this.x + this.width/2);
                    const dy = nearestBubble.y - (this.y + this.height/2);
                    const angle = Math.atan2(dy, dx);
                    
                    this.velocity.x = Math.cos(angle) * 2;
                    this.velocity.y = Math.sin(angle) * 2;
                }
            }
            
            goopBehavior() {
                // Occasionally drop slime particles
                if (Math.random() < 0.02) {
                    particles.push(new Particle(
                        this.x + this.width/2,
                        this.y + this.height,
                        Math.random() * 2 - 1,
                        Math.random() * 2 + 1,
                        Math.random() * 5 + 5,
                        '#8A9A5B'
                    ));
                }
            }
            
            vacublowBehavior() {
                // Suck in and blow out - change direction more frequently
                if (Math.random() < 0.05) {
                    this.velocity.x = Math.random() * 6 - 3;
                    this.velocity.y = Math.random() * 6 - 3;
                }
            }
            
            mimicBehavior() {
                // Change color to look like power-ups
                this.color = BUBBLE_TYPES[Math.floor(Math.random() * BUBBLE_TYPES.length)];
                // Move more erratically
                if (Math.random() < 0.03) {
                    this.velocity.x = Math.random() * 4 - 2;
                    this.velocity.y = Math.random() * 4 - 2;
                }
            }

            draw() {
                // Enemy shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2 + 3, this.y + this.height / 2 + 3, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Enemy body - different appearance based on type
                ctx.fillStyle = this.slowTimer > 0 ? '#9370db' : this.color;
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Type-specific visual elements
                switch(this.type) {
                    case 'popper':
                        // Popper Patrol - many small spikes
                        const popperSpikes = 12;
                        for (let i = 0; i < popperSpikes; i++) {
                            const angle = (i / popperSpikes) * Math.PI * 2 + this.frame * 0.1;
                            const spikeLength = 8;
                            
                            ctx.strokeStyle = '#800000';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(
                                this.x + this.width / 2 + Math.cos(angle) * (this.width / 2),
                                this.y + this.height / 2 + Math.sin(angle) * (this.height / 2)
                            );
                            ctx.lineTo(
                                this.x + this.width / 2 + Math.cos(angle) * (this.width / 2 + spikeLength),
                                this.y + this.height / 2 + Math.sin(angle) * (this.height / 2 + spikeLength)
                            );
                            ctx.stroke();
                        }
                        break;
                        
                    case 'goop':
                        // Goop Gliders - dripping slime
                        ctx.fillStyle = '#8A9A5B';
                        for (let i = 0; i < 5; i++) {
                            const dropX = this.x + this.width/2 + Math.sin(this.frame * 0.2 + i) * 15;
                            const dropHeight = 5 + Math.sin(this.frame * 0.1 + i) * 3;
                            
                            ctx.beginPath();
                            ctx.ellipse(
                                dropX, 
                                this.y + this.height,
                                5, dropHeight,
                                0, 0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                        break;
                        
                    case 'vacublow':
                        // Vacublow Fish - suction-cup mouth
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(
                            this.x + this.width/2 + Math.cos(this.frame * 0.2) * 10,
                            this.y + this.height/2 + Math.sin(this.frame * 0.2) * 10,
                            10, 0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        // Concentric circles for suction effect
                        ctx.strokeStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(
                            this.x + this.width/2 + Math.cos(this.frame * 0.2) * 10,
                            this.y + this.height/2 + Math.sin(this.frame * 0.2) * 10,
                            6, 0, Math.PI * 2
                        );
                        ctx.stroke();
                        break;
                        
                    case 'mimic':
                        // Bubble Mimics - looks like a power-up
                        // Inner highlight to mimic bubbles
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.arc(this.x + this.width/2 - 5, this.y + this.height/2 - 5, 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Subtle tell - creepy smile
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(
                            this.x + this.width/2,
                            this.y + this.height/2 + 5,
                            10, 0, Math.PI
                        );
                        ctx.stroke();
                        break;
                        
                    default:
                        // Generic enemy - spikes
                        const spikes = 8;
                        for (let i = 0; i < spikes; i++) {
                            const angle = (i / spikes) * Math.PI * 2 + this.frame * 0.1;
                            const spikeLength = 10;
                            
                            ctx.strokeStyle = '#800000';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(
                                this.x + this.width / 2 + Math.cos(angle) * (this.width / 2),
                                this.y + this.height / 2 + Math.sin(angle) * (this.height / 2)
                            );
                            ctx.lineTo(
                                this.x + this.width / 2 + Math.cos(angle) * (this.width / 2 + spikeLength),
                                this.y + this.height / 2 + Math.sin(angle) * (this.height / 2 + spikeLength)
                            );
                            ctx.stroke();
                        }
                }
                
                // Enemy eyes (all types have eyes)
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2 - 8, this.y + this.height / 2 - 5, 5, 0, Math.PI * 2);
                ctx.arc(this.x + this.width / 2 + 8, this.y + this.height / 2 - 5, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2 - 8, this.y + this.height / 2 - 5, 2, 0, Math.PI * 2);
                ctx.arc(this.x + this.width / 2 + 8, this.y + this.height / 2 - 5, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Show slowed effect
                if (this.slowTimer > 0) {
                    ctx.strokeStyle = '#9370db';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2 + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, velocityX, velocityY, radius, color) {
                this.x = x;
                this.y = y;
                this.velocity = {
                    x: velocityX,
                    y: velocityY
                };
                this.radius = radius;
                this.color = color;
                this.opacity = 1;
                this.gravity = 0.1;
            }

            update() {
                this.velocity.y += this.gravity;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.opacity -= 0.02;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Boss class
        class Boss {
            constructor(bossData) {
                this.name = bossData.name;
                this.health = bossData.health;
                this.maxHealth = bossData.health;
                this.attackPattern = bossData.attackPattern;
                this.x = canvas.width / 2 - 60;
                this.y = 100;
                this.width = 120;
                this.height = 120;
                this.velocity = { x: 2, y: 0 };
                this.attackTimer = 0;
                this.attackCooldown = 3000; // ms between attacks
                this.vulnerable = false;
                this.vulnerableTimer = 0;
                this.sprite = new Image();
                this.sprite.src = bossData.sprite;
                this.frame = 0;
                this.frameCount = 0;
                this.attackProjectiles = [];
            }
            
            update(deltaTime) {
                // Basic movement
                this.x += this.velocity.x;
                if (this.x <= 0 || this.x + this.width >= canvas.width) {
                    this.velocity.x *= -1;
                }
                
                // Animation
                this.frameCount++;
                if (this.frameCount >= 10) {
                    this.frame = (this.frame + 1) % 4;
                    this.frameCount = 0;
                }
                
                // Attack logic
                this.attackTimer += deltaTime;
                if (this.attackTimer >= this.attackCooldown) {
                    this.attack();
                    this.attackTimer = 0;
                }
                
                // Vulnerability period
                if (this.vulnerable) {
                    this.vulnerableTimer -= deltaTime;
                    if (this.vulnerableTimer <= 0) {
                        this.vulnerable = false;
                    }
                }
                
                // Update attack projectiles
                this.attackProjectiles = this.attackProjectiles.filter(proj => {
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    
                    // Check collision with player
                    const dx = player.x + player.width/2 - proj.x;
                    const dy = player.y + player.height/2 - proj.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < player.width/2 + proj.radius) {
                        player.hitEnemy();
                        return false;
                    }
                    
                    // Remove if off-screen
                    return proj.x > 0 && proj.x < canvas.width && 
                           proj.y > 0 && proj.y < canvas.height;
                });
            }
            
            draw() {
                // Draw boss
                ctx.save();
                
                // Flash when vulnerable
                if (this.vulnerable && Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.globalAlpha = 0.7;
                }
                
                // Draw the boss sprite
                ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height);
                
                // Health bar
                const healthBarWidth = 100;
                const healthBarHeight = 10;
                const healthPercentage = this.health / this.maxHealth;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(this.x + this.width/2 - healthBarWidth/2, this.y - 20, healthBarWidth, healthBarHeight);
                
                ctx.fillStyle = this.vulnerable ? '#ffff00' : '#ff3333';
                ctx.fillRect(
                    this.x + this.width/2 - healthBarWidth/2, 
                    this.y - 20, 
                    healthBarWidth * healthPercentage, 
                    healthBarHeight
                );
                
                // Boss name
                ctx.font = '12px "Press Start 2P"';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, this.x + this.width/2, this.y - 30);
                
                ctx.restore();
                
                // Draw attack projectiles
                this.attackProjectiles.forEach(proj => {
                    ctx.fillStyle = proj.color;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            attack() {
                const attackSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=boss%20attack%20sound&duration=1&ext=.mp3');
                attackSound.volume = 0.6;
                attackSound.play();
                
                switch(this.attackPattern) {
                    case 'wind':
                        // Wind attack - pushes player
                        for (let i = 0; i < 5; i++) {
                            this.attackProjectiles.push({
                                x: this.x + this.width/2,
                                y: this.y + this.height/2,
                                vx: Math.cos(i * Math.PI/2.5) * 5,
                                vy: Math.sin(i * Math.PI/2.5) * 5,
                                radius: 15,
                                color: 'rgba(200, 230, 255, 0.7)'
                            });
                        }
                        break;
                        
                    case 'slime':
                        // Slime attack - creates sticky areas
                        for (let i = 0; i < 3; i++) {
                            this.attackProjectiles.push({
                                x: this.x + this.width/2,
                                y: this.y + this.height/2,
                                vx: (Math.random() - 0.5) * 8,
                                vy: Math.random() * 5 + 2,
                                radius: 20,
                                color: '#8A9A5B'
                            });
                        }
                        break;
                        
                    case 'inflate':
                        // Inflate attack - expands and contracts
                        this.width = 150;
                        this.height = 150;
                        setTimeout(() => {
                            this.width = 120;
                            this.height = 120;
                            
                            // Release projectiles in all directions
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                this.attackProjectiles.push({
                                    x: this.x + this.width/2,
                                    y: this.y + this.height/2,
                                    vx: Math.cos(angle) * 6,
                                    vy: Math.sin(angle) * 6,
                                    radius: 10,
                                    color: '#ff5252'
                                });
                            }
                        }, 1000);
                        break;
                        
                    case 'swallow':
                        // Swallow attack - tries to pull player in
                        const dx = player.x - (this.x + this.width/2);
                        const dy = player.y - (this.y + this.height/2);
                        const angle = Math.atan2(dy, dx);
                        
                        for (let i = 0; i < 3; i++) {
                            this.attackProjectiles.push({
                                x: this.x + this.width/2 + Math.cos(angle) * 50,
                                y: this.y + this.height/2 + Math.sin(angle) * 50,
                                vx: Math.cos(angle) * 7,
                                vy: Math.sin(angle) * 7,
                                radius: 25,
                                color: 'rgba(100, 100, 100, 0.7)'
                            });
                        }
                        break;
                        
                    case 'chaos':
                        // Chaos attack - mix of all previous attacks
                        const attackType = Math.floor(Math.random() * 4);
                        this.attackPattern = ['wind', 'slime', 'inflate', 'swallow'][attackType];
                        this.attack();
                        this.attackPattern = 'chaos';
                        break;
                }
                
                // Become vulnerable after attacking
                this.vulnerable = true;
                this.vulnerableTimer = 2000;
            }
            
            hit() {
                if (this.vulnerable) {
                    this.health--;
                    this.vulnerable = false;
                    
                    // Hit effect
                    for (let i = 0; i < 15; i++) {
                        particles.push(new Particle(
                            this.x + this.width/2,
                            this.y + this.height/2,
                            Math.random() * 8 - 4,
                            Math.random() * 8 - 4,
                            Math.random() * 5 + 5,
                            '#ffff00'
                        ));
                    }
                    
                    const hitSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=boss%20hurt%20sound&duration=0.5&ext=.mp3');
                    hitSound.play();
                    
                    if (this.health <= 0) {
                        this.defeat();
                    }
                }
            }
            
            defeat() {
                // Boss defeat explosion
                for (let i = 0; i < 50; i++) {
                    particles.push(new Particle(
                        this.x + this.width/2,
                        this.y + this.height/2,
                        Math.random() * 10 - 5,
                        Math.random() * 10 - 5,
                        Math.random() * 8 + 5,
                        '#ffff00'
                    ));
                }
                
                const defeatSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=boss%20defeat%20explosion&duration=2&ext=.mp3');
                defeatSound.play();
                
                // Advance to next world
                setTimeout(() => {
                    advanceWorld();
                }, 2000);
            }
        }
        
        // Special feature classes
        class WindTunnel {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.strength = 0.5;
                this.particleTimer = 0;
            }
            
            update(deltaTime) {
                // Check if player is in wind tunnel
                if (player.x + player.width > this.x && 
                    player.x < this.x + this.width && 
                    player.y + player.height > this.y && 
                    player.y < this.y + this.height) {
                    // Apply upward force
                    player.velocity.y -= this.strength;
                }
                
                // Create wind particles
                this.particleTimer += deltaTime;
                if (this.particleTimer > 100) {
                    particles.push(new Particle(
                        this.x + Math.random() * this.width,
                        this.y + this.height,
                        (Math.random() - 0.5) * 2,
                        -Math.random() * 3 - 2,
                        Math.random() * 3 + 2,
                        'rgba(255, 255, 255, 0.5)'
                    ));
                    this.particleTimer = 0;
                }
            }
            
            draw() {
                ctx.fillStyle = 'rgba(200, 230, 255, 0.3)';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Wind direction indicators
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
                
                for (let y = this.y + this.height - 10; y > this.y; y -= 20) {
                    ctx.beginPath();
                    ctx.moveTo(this.x + 10, y);
                    ctx.lineTo(this.x + this.width/2, y - 15);
                    ctx.lineTo(this.x + this.width - 10, y);
                    ctx.stroke();
                }
            }
        }
        
        class Geyser {
            constructor(x, width) {
                this.x = x;
                this.width = width;
                this.y = canvas.height - 30; // Bottom of the screen
                this.height = 0; // Starts hidden
                this.maxHeight = 200;
                this.active = false;
                this.timer = Math.random() * 5000; // Random start time
                this.burstStrength = 20;
            }
            
            update(deltaTime) {
                this.timer -= deltaTime;
                
                if (this.timer <= 0) {
                    if (!this.active) {
                        // Start eruption
                        this.active = true;
                        this.timer = 2000; // Eruption lasts 2 seconds
                        const warningSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=geyser%20rumble%20warning&duration=1&ext=.mp3');
                        warningSound.volume = 0.5;
                        warningSound.play();
                    } else {
                        // End eruption
                        this.active = false;
                        this.timer = Math.random() * 3000 + 2000; // Random cooldown
                    }
                }
                
                if (this.active) {
                    // Grow geyser
                    this.height = Math.min(this.height + 10, this.maxHeight);
                    
                    // Check player collision
                    if (player.x + player.width > this.x && 
                        player.x < this.x + this.width && 
                        player.y + player.height > canvas.height - 30 - this.height) {
                        // Launch player upward
                        player.velocity.y = -this.burstStrength;
                        
                        // Create burst particles
                        for (let i = 0; i < 10; i++) {
                            particles.push(new Particle(
                                player.x + player.width/2,
                                player.y + player.height,
                                Math.random() * 6 - 3,
                                -Math.random() * 4 - 2,
                                Math.random() * 5 + 3,
                                '#7de2ff'
                            ));
                        }
                    }
                    
                    // Create geyser particles
                    if (Math.random() > 0.7) {
                        particles.push(new Particle(
                            this.x + Math.random() * this.width,
                            canvas.height - 30 - Math.random() * this.height,
                            Math.random() * 4 - 2,
                            -Math.random() * 2 - 1,
                            Math.random() * 4 + 2,
                            '#7de2ff'
                        ));
                    }
                } else {
                    // Shrink geyser
                    this.height = Math.max(0, this.height - 15);
                }
            }
            
            draw() {
                if (this.height <= 0) return;
                
                // Draw geyser
                ctx.fillStyle = 'rgba(125, 226, 255, 0.7)';
                ctx.fillRect(this.x, canvas.height - 30 - this.height, this.width, this.height);
                
                // Draw geyser edges
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(this.x, canvas.height - 30 - this.height, 3, this.height);
                ctx.fillRect(this.x + this.width - 3, canvas.height - 30 - this.height, 3, this.height);
            }
        }
        
        class Lightning {
            constructor() {
                this.active = false;
                this.warningX = 0;
                this.warningY = 0;
                this.warningRadius = 0;
                this.timer = Math.random() * 5000 + 2000; // Random initial delay
                this.warningTime = 1000; // Warning duration
                this.strikeWidth = 100;
            }
            
            update(deltaTime) {
                this.timer -= deltaTime;
                
                if (this.timer <= 0) {
                    if (!this.active) {
                        // Start warning
                        this.active = true;
                        this.warningX = Math.random() * canvas.width;
                        this.warningY = Math.random() * (canvas.height - 100);
                        this.warningRadius = 0;
                        this.timer = this.warningTime;
                        
                        const warningSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=electricity%20charging%20warning&duration=1&ext=.mp3');
                        warningSound.volume = 0.5;
                        warningSound.play();
                    } else {
                        // Strike lightning
                        this.strike();
                        this.active = false;
                        this.timer = Math.random() * 5000 + 3000; // Random cooldown
                    }
                }
                
                if (this.active) {
                    // Grow warning indicator
                    this.warningRadius = (1 - (this.timer / this.warningTime)) * this.strikeWidth/2;
                }
            }
            
            strike() {
                // Lightning strike effect
                const strikeSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=lightning%20strike%20thunder&duration=1&ext=.mp3');
                strikeSound.volume = 0.7;
                strikeSound.play();
                
                // Create lightning particles
                for (let i = 0; i < 30; i++) {
                    particles.push(new Particle(
                        this.warningX + (Math.random() - 0.5) * this.strikeWidth,
                        this.warningY + (Math.random() - 0.5) * 20,
                        Math.random() * 6 - 3,
                        Math.random() * 10 + 5,
                        Math.random() * 5 + 3,
                        '#f8f8ff'
                    ));
                }
                
                // Check if player is hit
                const dx = player.x + player.width/2 - this.warningX;
                const dy = player.y + player.height/2 - this.warningY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < this.strikeWidth/2 + player.width/2) {
                    player.hitEnemy();
                }
            }
            
            draw() {
                if (!this.active) return;
                
                // Draw warning circle
                ctx.beginPath();
                ctx.arc(this.warningX, this.warningY, this.warningRadius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 0, ${0.3 + Math.sin(Date.now() * 0.01) * 0.2})`;
                ctx.fill();
                
                // Draw warning text
                ctx.font = '12px "Press Start 2P"';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.fillText('!', this.warningX, this.warningY + 5);
            }
        }
        
        class Fog {
            constructor() {
                this.fogPatches = [];
                this.visibility = 200; // Visible radius around player
                
                // Create initial fog patches
                for (let i = 0; i < 10; i++) {
                    this.fogPatches.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: Math.random() * 100 + 50,
                        opacity: Math.random() * 0.5 + 0.3
                    });
                }
            }
            
            update() {
                // Move fog patches slowly
                this.fogPatches.forEach(patch => {
                    patch.x += Math.sin(Date.now() * 0.001 + patch.y) * 0.5;
                    patch.y += Math.cos(Date.now() * 0.001 + patch.x) * 0.3;
                    
                    // Wrap around screen
                    if (patch.x < -patch.radius) patch.x = canvas.width + patch.radius;
                    if (patch.x > canvas.width + patch.radius) patch.x = -patch.radius;
                    if (patch.y < -patch.radius) patch.y = canvas.height + patch.radius;
                    if (patch.y > canvas.height + patch.radius) patch.y = -patch.radius;
                });
            }
            
            draw() {
                // Draw fog overlay
                ctx.fillStyle = 'rgba(200, 200, 210, 0.4)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw fog patches
                this.fogPatches.forEach(patch => {
                    ctx.fillStyle = `rgba(220, 220, 230, ${patch.opacity})`;
                    ctx.beginPath();
                    ctx.arc(patch.x, patch.y, patch.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Create visibility circle around player
                ctx.globalCompositeOperation = 'destination-out';
                const gradient = ctx.createRadialGradient(
                    player.x + player.width/2, player.y + player.height/2, 0,
                    player.x + player.width/2, player.y + player.height/2, this.visibility
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, player.y + player.height/2, this.visibility, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }
        }
        
        // Initialize game objects
        function initGame() {
            // Reset game state values
            gameState.bubblesCollected = 0;
            gameState.showingBoss = false;
            
            // Set world-specific difficulty
            gameState.bubblesNeeded = 15 + (gameState.worldIndex * 5);
            
            // Load world-specific background
            worldBackgroundImage.src = GAME_WORLDS[gameState.worldIndex].background;
            
            // Load world-specific music
            bgMusic.pause();
            bgMusic.src = GAME_WORLDS[gameState.worldIndex].music;
            bgMusic.play();
            
            // Create ground platform first to ensure it's available immediately
            platforms = [];
            platforms.push(new Platform(0, canvas.height - 30, canvas.width, 30));
            
            // Initialize player above the ground platform
            player = new Player(canvas.width / 2 - PLAYER_SIZE / 2, canvas.height - 100);
            
            bubbles = [];
            enemies = [];
            particles = [];
            specialFeatures = [];
            rainbowBubbles = [];
            currentBoss = null;
            
            // Create initial platforms with world-specific color
            const platformColor = GAME_WORLDS[gameState.worldIndex].platformColor;
            for (let i = 0; i < 8; i++) {
                const platform = new Platform(
                    Math.random() * (canvas.width - 150),
                    Math.random() * (canvas.height - 200) + 100, // Adjusted height range
                    Math.random() * 50 + 100,
                    PLATFORM_HEIGHT
                );
                platform.color = platformColor;
                platforms.push(platform);
            }
            
            // Create initial bubbles
            for (let i = 0; i < 15; i++) {
                bubbles.push(new Bubble(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                ));
            }
            
            // Create initial enemies - more enemies in higher worlds
            for (let i = 0; i < 2 + gameState.worldIndex; i++) {
                enemies.push(new Enemy(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (canvas.height - 200) + 50
                ));
            }
            
            // Add world-specific special features
            const feature = GAME_WORLDS[gameState.worldIndex].specialFeature;
            switch(feature) {
                case 'windTunnels':
                    for (let i = 0; i < 3; i++) {
                        specialFeatures.push(new WindTunnel(
                            Math.random() * (canvas.width - 200) + 100,
                            Math.random() * (canvas.height - 300) + 150,
                            100,
                            200
                        ));
                    }
                    break;
                    
                case 'geysers':
                    for (let i = 0; i < 3; i++) {
                        specialFeatures.push(new Geyser(
                            Math.random() * (canvas.width - 100) + 50,
                            80
                        ));
                    }
                    break;
                    
                case 'lightning':
                    specialFeatures.push(new Lightning());
                    break;
                    
                case 'fog':
                    specialFeatures.push(new Fog());
                    break;
                    
                case 'reverseGravity':
                    // Reverse gravity is handled in the player update function
                    GRAVITY = -0.5; // Reverse gravity
                    break;
            }
            
            // Add rainbow bubble (1 per level)
            const rainbowBubble = new Bubble(
                Math.random() * (canvas.width - 100) + 50,
                Math.random() * (canvas.height - 200) + 100
            );
            rainbowBubble.isRainbow = true;
            bubbles.push(rainbowBubble);
        }

        // Game loop
        // Show level complete UI
        function showLevelComplete() {
            gameState.gamePaused = true;
            
            // Create level complete overlay
            const levelComplete = document.createElement('div');
            levelComplete.style.position = 'absolute';
            levelComplete.style.top = '0';
            levelComplete.style.left = '0';
            levelComplete.style.width = '100%';
            levelComplete.style.height = '100%';
            levelComplete.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            levelComplete.style.display = 'flex';
            levelComplete.style.flexDirection = 'column';
            levelComplete.style.justifyContent = 'center';
            levelComplete.style.alignItems = 'center';
            levelComplete.style.zIndex = '20';
            
            // Add level complete text
            const completeText = document.createElement('h2');
            completeText.textContent = 'Level Complete!';
            completeText.style.color = '#f8d800';
            completeText.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            completeText.style.fontSize = '32px';
            completeText.style.marginBottom = '20px';
            levelComplete.appendChild(completeText);
            
            // Add score
            const scoreText = document.createElement('p');
            scoreText.textContent = `Score: ${gameState.score}`;
            scoreText.style.color = '#ffffff';
            scoreText.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            scoreText.style.fontSize = '18px';
            scoreText.style.marginBottom = '10px';
            levelComplete.appendChild(scoreText);
            
            // Add rainbow bubbles found
            if (gameState.rainbowBubblesFound > 0) {
                const rainbowText = document.createElement('p');
                rainbowText.textContent = `Rainbow Bubbles: ${gameState.rainbowBubblesFound}/${(gameState.worldIndex * 6) + gameState.levelIndex + 1}`;
                rainbowText.style.color = '#ff44ff';
                rainbowText.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
                rainbowText.style.fontSize = '14px';
                rainbowText.style.marginBottom = '20px';
                levelComplete.appendChild(rainbowText);
            }
            
            // Add boss battle button
            const bossButton = document.createElement('button');
            bossButton.textContent = 'Boss Battle!';
            bossButton.style.backgroundColor = '#ff4081';
            bossButton.style.color = 'white';
            bossButton.style.border = 'none';
            bossButton.style.padding = '15px 30px';
            bossButton.style.fontSize = '18px';
            bossButton.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            bossButton.style.borderRadius = '10px';
            bossButton.style.cursor = 'pointer';
            bossButton.style.transition = 'all 0.3s';
            bossButton.style.boxShadow = '0 4px 0 #c60055';
            bossButton.style.marginTop = '20px';
            
            bossButton.addEventListener('mouseover', () => {
                bossButton.style.transform = 'translateY(-5px)';
                bossButton.style.boxShadow = '0 9px 0 #c60055';
            });
            
            bossButton.addEventListener('mouseout', () => {
                bossButton.style.transform = 'translateY(0)';
                bossButton.style.boxShadow = '0 4px 0 #c60055';
            });
            
            bossButton.addEventListener('click', () => {
                document.getElementById('game-container').removeChild(levelComplete);
                startBossBattle();
            });
            
            levelComplete.appendChild(bossButton);
            
            // Add to container
            document.getElementById('game-container').appendChild(levelComplete);
            
            // Play completion sound
            const completionSound = new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=level%20complete%20fanfare&duration=2&ext=.mp3');
            completionSound.play();
        }
        
        // Start boss battle
        function startBossBattle() {
            gameState.showingBoss = true;
            gameState.gamePaused = false;
            
            // Clear most existing entities
            bubbles = [];
            enemies = [];
            
            // Create boss
            currentBoss = new Boss(GAME_WORLDS[gameState.worldIndex].boss);
            
            // Change music for boss battle
            bgMusic.pause();
            bgMusic.src = 'https://sounds.fuzzycode.dev/music?prompt=intense%20boss%20battle%20chiptune&duration=30&ext=.mp3';
            bgMusic.play();
            
            // Show boss introduction
            const bossIntro = document.createElement('div');
            bossIntro.style.position = 'absolute';
            bossIntro.style.top = '50%';
            bossIntro.style.left = '0';
            bossIntro.style.width = '100%';
            bossIntro.style.textAlign = 'center';
            bossIntro.style.color = '#ff4081';
            bossIntro.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            bossIntro.style.fontSize = '24px';
            bossIntro.style.textShadow = '2px 2px 0 #000';
            bossIntro.style.zIndex = '15';
            bossIntro.style.transform = 'translateY(-50%)';
            bossIntro.textContent = currentBoss.name;
            
            document.getElementById('game-container').appendChild(bossIntro);
            
            // Remove intro after 3 seconds
            setTimeout(() => {
                document.getElementById('game-container').removeChild(bossIntro);
            }, 3000);
        }
        
        // Advance to next world
        function advanceWorld() {
            // Check if game is complete
            if (gameState.worldIndex >= 4 && gameState.levelIndex >= 5) {
                gameComplete();
                return;
            }
            
            // Advance level or world
            gameState.levelIndex++;
            if (gameState.levelIndex > 5) {
                gameState.worldIndex++;
                gameState.levelIndex = 0;
            }
            
            // Initialize next level
            initGame();
            
            // Show world introduction
            const worldIntro = document.createElement('div');
            worldIntro.style.position = 'absolute';
            worldIntro.style.top = '0';
            worldIntro.style.left = '0';
            worldIntro.style.width = '100%';
            worldIntro.style.height = '100%';
            worldIntro.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            worldIntro.style.display = 'flex';
            worldIntro.style.flexDirection = 'column';
            worldIntro.style.justifyContent = 'center';
            worldIntro.style.alignItems = 'center';
            worldIntro.style.zIndex = '20';
            
            const worldTitle = document.createElement('h2');
            worldTitle.textContent = GAME_WORLDS[gameState.worldIndex].name;
            worldTitle.style.color = '#f8d800';
            worldTitle.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            worldTitle.style.fontSize = '32px';
            worldTitle.style.marginBottom = '20px';
            
            const levelText = document.createElement('p');
            levelText.textContent = `Level ${gameState.levelIndex + 1}`;
            levelText.style.color = '#ffffff';
            levelText.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            levelText.style.fontSize = '18px';
            levelText.style.marginBottom = '30px';
            
            const continueText = document.createElement('p');
            continueText.textContent = 'Press any key to continue';
            continueText.style.color = '#aaaaaa';
            continueText.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            continueText.style.fontSize = '14px';
            
            worldIntro.appendChild(worldTitle);
            worldIntro.appendChild(levelText);
            worldIntro.appendChild(continueText);
            
            document.getElementById('game-container').appendChild(worldIntro);
            
            // Pause game until key press
            gameState.gamePaused = true;
            
            // Listen for any key press
            const continueHandler = (e) => {
                document.getElementById('game-container').removeChild(worldIntro);
                gameState.gamePaused = false;
                document.removeEventListener('keydown', continueHandler);
            };
            
            document.addEventListener('keydown', continueHandler);
        }
        
        // Game completion
        function gameComplete() {
            cancelAnimationFrame(animationId);
            bgMusic.pause();
            
            // Check for secret ending
            const hasSecretEnding = gameState.rainbowBubblesFound >= 30; // 30 rainbow bubbles total
            
            // Create ending screen
            const endingScreen = document.createElement('div');
            endingScreen.style.position = 'absolute';
            endingScreen.style.top = '0';
            endingScreen.style.left = '0';
            endingScreen.style.width = '100%';
            endingScreen.style.height = '100%';
            endingScreen.style.backgroundColor = hasSecretEnding ? 'rgba(100, 0, 150, 0.9)' : 'rgba(0, 50, 100, 0.9)';
            endingScreen.style.display = 'flex';
            endingScreen.style.flexDirection = 'column';
            endingScreen.style.justifyContent = 'center';
            endingScreen.style.alignItems = 'center';
            endingScreen.style.zIndex = '30';
            
            const endingTitle = document.createElement('h1');
            endingTitle.textContent = hasSecretEnding ? 'Secret Ending Achieved!' : 'Congratulations!';
            endingTitle.style.color = '#f8d800';
            endingTitle.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            endingTitle.style.fontSize = '32px';
            endingTitle.style.marginBottom = '30px';
            endingTitle.style.textAlign = 'center';
            
            const endingText = document.createElement('p');
            endingText.innerHTML = hasSecretEnding ? 
                'You collected all the Rainbow Bubbles!<br>Pip has become the new Guardian of Aerispring!' : 
                'You defeated Mistweaver and saved Aerispring!<br>Magic flows freely once again!';
            endingText.style.color = '#ffffff';
            endingText.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            endingText.style.fontSize = '16px';
            endingText.style.marginBottom = '30px';
            endingText.style.textAlign = 'center';
            endingText.style.lineHeight = '1.5';
            
            const finalScore = document.createElement('p');
            finalScore.textContent = `Final Score: ${gameState.score}`;
            finalScore.style.color = '#aaffaa';
            finalScore.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            finalScore.style.fontSize = '24px';
            finalScore.style.marginBottom = '40px';
            
            const playAgainButton = document.createElement('button');
            playAgainButton.textContent = 'Play Again';
            playAgainButton.style.backgroundColor = '#6a4bc4';
            playAgainButton.style.color = 'white';
            playAgainButton.style.border = 'none';
            playAgainButton.style.padding = '15px 30px';
            playAgainButton.style.fontSize = '18px';
            playAgainButton.style.fontFamily = '"Press Start 2P", cursive, sans-serif';
            playAgainButton.style.borderRadius = '10px';
            playAgainButton.style.cursor = 'pointer';
            playAgainButton.style.transition = 'all 0.3s';
            
            playAgainButton.addEventListener('click', () => {
                document.getElementById('game-container').removeChild(endingScreen);
                gameState.worldIndex = 0;
                gameState.levelIndex = 0;
                gameState.rainbowBubblesFound = 0;
                gameState.score = 0;
                GRAVITY = 0.5; // Reset gravity
                startGame();
            });
            
            endingScreen.appendChild(endingTitle);
            endingScreen.appendChild(endingText);
            endingScreen.appendChild(finalScore);
            endingScreen.appendChild(playAgainButton);
            
            document.getElementById('game-container').appendChild(endingScreen);
            
            // Play ending music
            const endingMusic = new Audio(hasSecretEnding ? 
                'https://sounds.fuzzycode.dev/music?prompt=triumphant%20magical%20victory%20chiptune&duration=30&ext=.mp3' : 
                'https://sounds.fuzzycode.dev/music?prompt=happy%20ending%20chiptune&duration=30&ext=.mp3');
            endingMusic.play();
        }
        
        function gameLoop(timestamp) {
            if (gameState.gamePaused) {
                animationId = requestAnimationFrame(gameLoop);
                return;
            }
            
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background with parallax effect (layered backgrounds)
            // Main background
            ctx.drawImage(worldBackgroundImage, 0, 0, canvas.width, canvas.height);
            
            // Draw world name and level
            ctx.font = '16px "Press Start 2P"';
            ctx.fillStyle = '#f8d800';
            ctx.textAlign = 'right';
            
            const worldName = GAME_WORLDS[gameState.worldIndex].name;
            const levelText = gameState.showingBoss ? "BOSS" : `Level ${gameState.levelIndex + 1}`;
            
            ctx.fillText(`${worldName} - ${levelText}`, canvas.width - 20, 30);
            
            // Update and draw platforms
            platforms.forEach(platform => {
                platform.update();
                platform.draw();
                
                // Platform collision
                if (player.velocity.y > 0 && // Only check when moving downward
                    player.y + player.height <= platform.y + 10 && // Added tolerance
                    player.y + player.height + player.velocity.y >= platform.y &&
                    player.x + player.width / 2 > platform.x && 
                    player.x + player.width / 2 < platform.x + platform.width) {
                    
                    player.y = platform.y - player.height;
                    player.velocity.y = 0;
                    player.isGrounded = true;
                    player.canBounce = true;
                    player.collisionDebounce = 5; // Set debounce to prevent immediate fall-through
                    
                    // Apply platform movement to player
                    if (platform.isMoving) {
                        player.x += platform.velocity.x;
                    }
                }
            });
            
            // Update and draw bubbles
            bubbles.forEach((bubble, index) => {
                bubble.update();
                bubble.draw();
                
                // Bubble collection
                const dx = player.x + player.width / 2 - bubble.x;
                const dy = player.y + player.height / 2 - bubble.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.width / 2 + bubble.radius) {
                    player.collectBubble(bubble);
                    bubbles.splice(index, 1);
                    
                    // Spawn new bubble
                    if (Math.random() > 0.3) {
                        bubbles.push(new Bubble(
                            Math.random() * canvas.width,
                            Math.random() * 100
                        ));
                    }
                }
            });
            
            // Update and draw enemies
            enemies.forEach(enemy => {
                enemy.update();
                enemy.draw();
                
                // Enemy collision
                const dx = player.x + player.width / 2 - (enemy.x + enemy.width / 2);
                const dy = player.y + player.height / 2 - (enemy.y + enemy.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.width / 2 + enemy.width / 2) {
                    player.hitEnemy();
                }
            });
            
            // Update and draw particles
            particles = particles.filter(particle => {
                particle.update();
                particle.draw();
                return particle.opacity > 0;
            });
            
            // Update and draw player
            player.update(deltaTime);
            player.draw();
            
            // Check for bubble spawn
            if (Math.random() < 0.01 && bubbles.length < 20) {
                bubbles.push(new Bubble(
                    Math.random() * canvas.width,
                    0
                ));
            }
            
            // Check for enemy spawn
            if (Math.random() < 0.002 && enemies.length < 5) {
                enemies.push(new Enemy(
                    Math.random() * canvas.width,
                    0
                ));
            }
            
            // Display current power-up info if active
            if (player.powerUp) {
                ctx.font = '12px "Press Start 2P"';
                ctx.fillStyle = player.getPowerUpColor();
                ctx.textAlign = 'left';
                ctx.fillText(BUBBLE_DESCRIPTIONS[player.powerUp], 10, 70);
                
                // Show power-up timer
                const timerWidth = 100;
                const timerHeight = 10;
                const timerX = 10;
                const timerY = 80;
                const timerFill = (player.powerUpTimer / 5000) * timerWidth;
                
                // Timer background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(timerX, timerY, timerWidth, timerHeight);
                
                // Timer fill
                ctx.fillStyle = player.getPowerUpColor();
                ctx.fillRect(timerX, timerY, timerFill, timerHeight);
            }
            
            // Display consecutive bounce count for player feedback
            if (player.consecutiveBounces > 1) {
                ctx.font = '16px "Press Start 2P"';
                ctx.fillStyle = '#f8d800';
                ctx.textAlign = 'center';
                ctx.fillText(`Bounce x${player.consecutiveBounces}`, player.x + player.width/2, player.y - 20);
            }
            
            // Update and draw special features
            specialFeatures.forEach(feature => {
                feature.update(deltaTime);
                feature.draw();
            });
            
            // Update and draw boss if present
            if (currentBoss) {
                currentBoss.update(deltaTime);
                currentBoss.draw();
                
                // Check boss collision with player attack (red explosive bubble)
                if (player.powerUp === 'red' && player.isBouncing) {
                    const dx = currentBoss.x + currentBoss.width/2 - (player.x + player.width/2);
                    const dy = currentBoss.y + currentBoss.height/2 - (player.y + player.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < player.width/2 + currentBoss.width/2) {
                        currentBoss.hit();
                    }
                }
            }
            
            // Display progress to next level
            if (!gameState.showingBoss) {
                // Progress bar for bubbles collected
                const progressWidth = 150;
                const progressHeight = 10;
                const progressX = canvas.width - progressWidth - 20;
                const progressY = 40;
                const progressFill = (gameState.bubblesCollected / gameState.bubblesNeeded) * progressWidth;
                
                // Progress bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(progressX, progressY, progressWidth, progressHeight);
                
                // Progress bar fill
                ctx.fillStyle = '#64c5ff';
                ctx.fillRect(progressX, progressY, progressFill, progressHeight);
                
                // Progress text
                ctx.font = '12px "Press Start 2P"';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'right';
                ctx.fillText(`${gameState.bubblesCollected}/${gameState.bubblesNeeded}`, progressX + progressWidth, progressY + 25);
            }
            
            // Display rainbow bubbles found
            if (gameState.rainbowBubblesFound > 0) {
                ctx.font = '12px "Press Start 2P"';
                ctx.fillStyle = '#ff44ff';
                ctx.textAlign = 'left';
                ctx.fillText(`Rainbow: ${gameState.rainbowBubblesFound}`, 10, 110);
            }
            
            // Request next frame
            animationId = requestAnimationFrame(gameLoop);
        }

        // Event handlers
        function handleKeyDown(e) {
            switch (e.key) {
                case 'ArrowLeft':
                    gameState.keyState.left = true;
                    break;
                case 'ArrowRight':
                    gameState.keyState.right = true;
                    break;
                case 'ArrowUp':
                case ' ':
                    if (!gameState.keyState.space) {
                        gameState.keyState.space = true;
                        player.bounce();
                    }
                    break;
                case 'z':
                case 'Z':
                    player.toggleBubbleState();
                    break;
                case 'p':
                case 'P':
                    togglePause();
                    break;
            }
        }

        function handleKeyUp(e) {
            switch (e.key) {
                case 'ArrowLeft':
                    gameState.keyState.left = false;
                    break;
                case 'ArrowRight':
                    gameState.keyState.right = false;
                    break;
                case 'ArrowUp':
                case ' ':
                    gameState.keyState.space = false;
                    break;
            }
        }

        function togglePause() {
            gameState.gamePaused = !gameState.gamePaused;
            pauseButton.textContent = gameState.gamePaused ? '' : 'II';
        }

        function startGame() {
            titleScreen.style.display = 'none';
            hud.style.display = 'block';
            pauseButton.style.display = 'block';
            
            gameState.score = 0;
            gameState.lives = 3;
            gameState.gameActive = true;
            
            scoreDisplay.textContent = `Score: ${gameState.score}`;
            livesDisplay.textContent = `Lives: ${gameState.lives}`;
            
            initGame();
            lastTime = performance.now();
            
            // Start background music
            bgMusic.play();
            
            // Start game loop
            animationId = requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameState.gameActive = false;
            cancelAnimationFrame(animationId);
            bgMusic.pause();
            sounds.gameOver.play();
            
            finalScoreDisplay.textContent = `Final Score: ${gameState.score}`;
            gameOverScreen.style.display = 'flex';
        }

        function restartGame() {
            gameOverScreen.style.display = 'none';
            startGame();
        }

        // Create floating bubbles in the background of title screen
        function createTitleBubbles() {
            for (let i = 0; i < 20; i++) {
                const bubble = document.createElement('div');
                bubble.classList.add('bubble');
                bubble.style.width = `${Math.random() * 50 + 20}px`;
                bubble.style.height = bubble.style.width;
                bubble.style.left = `${Math.random() * 100}%`;
                bubble.style.top = `${Math.random() * 100}%`;
                bubble.style.animationDuration = `${Math.random() * 4 + 3}s`;
                bubble.style.animationDelay = `${Math.random() * 2}s`;
                document.getElementById('game-container').appendChild(bubble);
            }
        }

        // Event listeners
        startButton.addEventListener('click', startGame);
        pauseButton.addEventListener('click', togglePause);
        restartButton.addEventListener('click', restartGame);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        // Initialize title screen bubbles
        createTitleBubbles();
    </script>

    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.2/dist/nipplejs.js" crossorigin="anonymous"></script>
    <script>
(function (root, factory) {
    if (typeof module === "object" && module.exports) {
        module.exports = factory();
    } else {
        root.TouchpadControls = factory();
        root.touchpadControls = root.TouchpadControls;
    }
}(typeof self !== "undefined" ? self : this, function () {
    "use strict";

    const sections = {
        CENTER_LEFT: { top: "50%", left: "130px", transform: "translate(-50%, -50%)" },
        CENTER_TOP: { top: "130px", left: "50%", transform: "translate(-50%, -50%)" },
        CENTER_RIGHT: { top: "50%", left: "calc(100% - 130px)", transform: "translate(-50%, -50%)" },
        CENTER_BOTTOM: { top: "calc(100% - 130px)", left: "50%", transform: "translate(-50%, -50%)" }
    };

    const buttonPositions = {
        CENTER_LEFT: { top: "0", left: "-50px" },
        CENTER_TOP: { top: "-50px", left: "0" },
        CENTER_RIGHT: { top: "0", left: "50px" },
        CENTER_BOTTOM: { top: "50px", left: "0" }
    };

    const STYLE_ID = "touchpad-controls-style";
    const MIN_TOUCH_TARGET = 48;

    const injectTouchpadStyles = () => {
        if (typeof document === "undefined") return;
        if (document.getElementById(STYLE_ID)) return;

        const style = document.createElement("style");
        style.id = STYLE_ID;
        style.textContent = `
            :root {
                --touchpad-size: 72px;
                --touchpad-radius: 50%;
                --touchpad-bg: radial-gradient(135% 135% at 25% 20%, rgba(255,255,255,0.15), rgba(0,0,0,0.6));
                --touchpad-bg-image: none;
                --touchpad-bg-image-size: cover;
                --touchpad-bg-image-position: center;
                --touchpad-bg-blend: soft-light;
                --touchpad-border: 1px solid rgba(255,255,255,0.12);
                --touchpad-shadow: 0 12px 40px rgba(0,0,0,0.7), inset 0 1px 1px rgba(255,255,255,0.1);
                --touchpad-shadow-active: 0 4px 15px rgba(0,0,0,0.9), inset 0 1px 0 rgba(0,0,0,0.3);
                --touchpad-icon: none;
                --touchpad-icon-size: 52%;
                --touchpad-icon-opacity: 0.9;
                --touchpad-foreground-image: none;
                --touchpad-foreground-size: 60%;
                --touchpad-foreground-opacity: 0.8;
                --touchpad-foreground-blend: normal;
                --touchpad-label-color: #E2E8F0;
                --touchpad-label-size: 12px;
            }

            .touchpad {
                position: absolute;
                width: var(--touchpad-size);
                height: var(--touchpad-size);
                padding: 0;
                box-sizing: border-box;
                border-radius: var(--touchpad-radius);
                background-image: var(--touchpad-bg-image, none), var(--touchpad-bg);
                background-size: var(--touchpad-bg-image-size, cover), 100%;
                background-position: var(--touchpad-bg-image-position, center), center;
                background-repeat: no-repeat, no-repeat;
                background-blend-mode: var(--touchpad-bg-blend, soft-light), normal;
                border: var(--touchpad-border);
                box-shadow: var(--touchpad-shadow);
                display: flex;
                justify-content: center;
                align-items: center;
                touch-action: none;
                user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                font-size: 0;
                color: transparent;
                z-index: 9999;
                overflow: visible;
                backdrop-filter: blur(12px) saturate(180%);
                -webkit-backdrop-filter: blur(12px) saturate(180%);
                transition:
                    transform 120ms cubic-bezier(0.2, 0, 0, 1),
                    box-shadow 150ms ease,
                    background 200ms ease,
                    filter 150ms linear;
                background-position: center;
                background-repeat: no-repeat;
                background-size: 45%;
            }

            .touchpad::after {
                content: "";
                position: absolute;
                width: var(--touchpad-icon-size, 52%);
                height: var(--touchpad-icon-size, 52%);
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background-image: var(--touchpad-icon, none);
                background-repeat: no-repeat;
                background-position: center;
                background-size: contain;
                opacity: var(--touchpad-icon-opacity, 0.9);
                pointer-events: none;
                filter: drop-shadow(0 2px 6px rgba(0,0,0,0.6));
            }

            .touchpad::before {
                content: "";
                position: absolute;
                width: var(--touchpad-foreground-size, 60%);
                height: var(--touchpad-foreground-size, 60%);
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background-image: var(--touchpad-foreground-image, none);
                background-repeat: no-repeat;
                background-position: center;
                background-size: contain;
                opacity: var(--touchpad-foreground-opacity, 0.8);
                mix-blend-mode: var(--touchpad-foreground-blend, normal);
                pointer-events: none;
            }

            .touchpad--label {
                font-size: var(--touchpad-label-size, 12px);
                color: var(--touchpad-label-color, #E2E8F0);
            }

            .touchpad-label {
                position: absolute;
                left: 0;
                right: 0;
                bottom: 10%;
                text-align: center;
                font-weight: 600;
                pointer-events: none;
                text-shadow: 0 2px 8px rgba(0,0,0,0.7);
            }

            .touchpad.is-active {
                transform: scale(0.94) translate3d(0, 1px, 0);
                box-shadow: var(--touchpad-shadow-active);
            }

            .touchpad:hover {
                box-shadow: 0 12px 32px rgba(0,0,0,0.95);
            }

            .touchpad--button {
                font-size: 18px;
            }

            .touchpad--joystick {
                font-size: 14px;
            }

            .touchpad .nipple,
            .touchpad .nipple * {
                overflow: visible;
            }

            .touchpad .nipple .back {
                box-shadow:
                    0 0 0 1px rgba(15,23,42,0.85),
                    0 0 0 6px rgba(148,163,184,0.12),
                    0 10px 30px rgba(15,23,42,0.85);
            }

            .touchpad .nipple .front {
                box-shadow:
                    0 0 0 1px rgba(148,163,184,0.9),
                    0 8px 18px rgba(15,23,42,0.9);
            }
        `;
        document.head.appendChild(style);
    };

    const safeEntries = (obj) => {
        if (!obj || typeof obj !== "object") return [];
        return Object.entries(obj);
    };

    const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

    const formatCssValue = (value) => {
        if (typeof value === "number" && Number.isFinite(value)) {
            return `${value}px`;
        }
        return value;
    };

    const ICON_COLOR_DEFAULT = "#E2E8F0";
    const ICON_STROKE = 4;

    const svgToDataUri = (svg) => {
        const encoded = encodeURIComponent(svg)
            .replace(/%0A/g, "");
        return `url(\"data:image/svg+xml,${encoded}\")`;
    };

    const iconArrow = (direction, color) => {
        const stroke = color || ICON_COLOR_DEFAULT;
        if (direction === "left") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M40 16 L24 32 L40 48"/><path d="M26 32 H50"/></svg>`
            );
        }
        if (direction === "right") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M24 16 L40 32 L24 48"/><path d="M14 32 H38"/></svg>`
            );
        }
        if (direction === "up") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M16 30 L32 14 L48 30"/><path d="M32 16 V52"/></svg>`
            );
        }
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${stroke}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M16 34 L32 50 L48 34"/><path d="M32 12 V48"/></svg>`
        );
    };

    const iconHorizontal = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M18 22 L8 32 L18 42"/><path d="M46 22 L56 32 L46 42"/><path d="M14 32 H50"/></svg>`
    );

    const iconVertical = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M22 18 L32 8 L42 18"/><path d="M22 46 L32 56 L42 46"/><path d="M32 14 V50"/></svg>`
    );

    const iconDpad = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M32 16 V48"/><path d="M16 32 H48"/><path d="M24 22 L32 14 L40 22"/><path d="M24 42 L32 50 L40 42"/><path d="M22 24 L14 32 L22 40"/><path d="M42 24 L50 32 L42 40"/></svg>`
    );

    const iconCircle = (filled, color) => {
        const fillColor = color || ICON_COLOR_DEFAULT;
        if (filled) {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="14" fill="${fillColor}"/></svg>`
            );
        }
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="14" fill="none" stroke="${fillColor}" stroke-width="${ICON_STROKE}"/></svg>`
        );
    };

    const iconSquare = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="20" y="20" width="24" height="24" rx="4" fill="${color || ICON_COLOR_DEFAULT}"/></svg>`
    );

    const iconTriangle = (direction, color) => {
        const fillColor = color || ICON_COLOR_DEFAULT;
        if (direction === "left") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M22 32 L42 18 V46 Z" fill="${fillColor}"/></svg>`
            );
        }
        if (direction === "right") {
            return svgToDataUri(
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M42 32 L22 18 V46 Z" fill="${fillColor}"/></svg>`
            );
        }
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><path d="M32 18 L18 42 H46 Z" fill="${fillColor}"/></svg>`
        );
    };

    const iconChevron = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="none" stroke="${color || ICON_COLOR_DEFAULT}" stroke-width="${ICON_STROKE}" stroke-linecap="round" stroke-linejoin="round"><path d="M22 18 L34 32 L22 46"/><path d="M34 18 L46 32 L34 46"/></svg>`
    );

    const iconPause = (color) => svgToDataUri(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="20" y="18" width="8" height="28" rx="2" fill="${color || ICON_COLOR_DEFAULT}"/><rect x="36" y="18" width="8" height="28" rx="2" fill="${color || ICON_COLOR_DEFAULT}"/></svg>`
    );

    const keyLabel = (key) => {
        if (!key) return "";
        if (key.startsWith("Key") && key.length === 4) return key.slice(3);
        if (key.startsWith("Digit") && key.length === 6) return key.slice(5);
        if (key === "Space") return "SP";
        if (key === "Escape") return "ESC";
        if (key === "Enter") return "ENT";
        if (key === "Tab") return "TAB";
        if (key === "Backspace") return "BK";
        if (key === "ShiftLeft" || key === "ShiftRight") return "SH";
        if (key === "ControlLeft" || key === "ControlRight") return "CT";
        if (key === "AltLeft" || key === "AltRight") return "AL";
        if (key === "MetaLeft" || key === "MetaRight") return "MD";
        return key.slice(0, 3).toUpperCase();
    };

    const normalizeTheme = (theme) => {
        if (!theme || typeof theme !== "object") {
            return {
                iconColor: ICON_COLOR_DEFAULT,
                iconOpacity: 0.9,
                iconScale: 0.52,
                labelMode: "none",
                labelColor: ICON_COLOR_DEFAULT,
                labelSize: 12,
                background: null,
                backgroundImage: null,
                backgroundBlend: "soft-light",
                backgroundSize: "cover",
                backgroundPosition: "center",
                foregroundImage: null,
                foregroundOpacity: 0.8,
                foregroundSize: "60%",
                foregroundBlend: "normal"
            };
        }
        return {
            iconColor: theme.iconColor || ICON_COLOR_DEFAULT,
            iconOpacity: typeof theme.iconOpacity === "number" ? theme.iconOpacity : 0.9,
            iconScale: typeof theme.iconScale === "number" ? theme.iconScale : 0.52,
            labelMode: theme.labelMode || "none",
            labelColor: theme.labelColor || ICON_COLOR_DEFAULT,
            labelSize: typeof theme.labelSize === "number" ? theme.labelSize : 12,
            background: theme.background || null,
            backgroundImage: theme.backgroundImage || null,
            backgroundBlend: theme.backgroundBlend || "soft-light",
            backgroundSize: theme.backgroundSize || "cover",
            backgroundPosition: theme.backgroundPosition || "center",
            foregroundImage: theme.foregroundImage || null,
            foregroundOpacity: typeof theme.foregroundOpacity === "number" ? theme.foregroundOpacity : 0.8,
            foregroundSize: theme.foregroundSize || "60%",
            foregroundBlend: theme.foregroundBlend || "normal"
        };
    };

    const mergeTheme = (base, override) => {
        if (!override || typeof override !== "object") return base;
        return normalizeTheme(Object.assign({}, base, override));
    };

    const normalizeImageValue = (value) => {
        if (!value) return null;
        if (value.includes("url(")) return value;
        return `url(\"${value}\")`;
    };

    const applyThemeVars = (element, theme) => {
        if (!element || !theme) return;
        if (theme.background) {
            element.style.setProperty("--touchpad-bg", theme.background);
        }
        if (theme.backgroundImage) {
            element.style.setProperty("--touchpad-bg-image", normalizeImageValue(theme.backgroundImage));
            element.style.setProperty("--touchpad-bg-blend", theme.backgroundBlend || "soft-light");
            element.style.setProperty("--touchpad-bg-image-size", theme.backgroundSize || "cover");
            element.style.setProperty("--touchpad-bg-image-position", theme.backgroundPosition || "center");
        }
        if (theme.foregroundImage) {
            element.style.setProperty("--touchpad-foreground-image", normalizeImageValue(theme.foregroundImage));
            element.style.setProperty("--touchpad-foreground-opacity", String(theme.foregroundOpacity));
            element.style.setProperty("--touchpad-foreground-size", theme.foregroundSize || "60%");
            element.style.setProperty("--touchpad-foreground-blend", theme.foregroundBlend || "normal");
        }
        if (theme.iconOpacity != null) {
            element.style.setProperty("--touchpad-icon-opacity", String(theme.iconOpacity));
        }
        if (theme.iconScale != null) {
            element.style.setProperty("--touchpad-icon-size", `${Math.round(theme.iconScale * 100)}%`);
        }
        if (theme.labelColor) {
            element.style.setProperty("--touchpad-label-color", theme.labelColor);
        }
        if (theme.labelSize) {
            element.style.setProperty("--touchpad-label-size", `${theme.labelSize}px`);
        }
    };

    const resolveLabelText = (btn, labelMode) => {
        if (!btn) return "";
        if (labelMode === "none") return "";
        if (labelMode === "text") {
            if (btn.label) return String(btn.label);
            if (typeof btn.keys === "string") return keyLabel(btn.keys);
            return "";
        }
        if (labelMode === "key") {
            if (typeof btn.keys === "string") return keyLabel(btn.keys);
            return "";
        }
        if (labelMode === "both") {
            if (btn.label) return String(btn.label);
            if (typeof btn.keys === "string") return keyLabel(btn.keys);
            return "";
        }
        return "";
    };

    const iconKeycap = (label, color) => {
        const fillColor = color || ICON_COLOR_DEFAULT;
        const safe = String(label || "").replace(/[^A-Z0-9]/g, "");
        const text = safe || "";
        return svgToDataUri(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect x="12" y="14" width="40" height="36" rx="8" fill="none" stroke="${fillColor}" stroke-width="${ICON_STROKE}"/><text x="32" y="38" font-size="16" text-anchor="middle" fill="${fillColor}" font-family="monospace">${text}</text></svg>`
        );
    };

    const resolveDirectionForKey = (key, role) => {
        if (key === "ArrowLeft") return "left";
        if (key === "ArrowRight") return "right";
        if (key === "ArrowUp") return "up";
        if (key === "ArrowDown") return "down";
        if (role === "move" || role === "aim") {
            if (key === "KeyA") return "left";
            if (key === "KeyD") return "right";
            if (key === "KeyW") return "up";
            if (key === "KeyS") return "down";
        }
        return null;
    };

    const resolveIcon = (btn, theme) => {
        if (!btn) return null;
        if (btn.icon) return btn.icon;
        const iconColor = theme && theme.iconColor ? theme.iconColor : ICON_COLOR_DEFAULT;
        const meta = btn.meta || null;
        const keys = btn.keys;
        const role = btn.role;

        if (meta && meta.pair_position) {
            return iconTriangle(meta.pair_position === "right" ? "right" : "left", iconColor);
        }

        if (keys && typeof keys === "object" && !Array.isArray(keys)) {
            const hasLeft = !!keys.left;
            const hasRight = !!keys.right;
            const hasUp = !!keys.up;
            const hasDown = !!keys.down;
            if (hasLeft && hasRight && hasUp && hasDown) return iconDpad(iconColor);
            if (hasLeft && hasRight && !hasUp && !hasDown) return iconHorizontal(iconColor);
            if (hasUp && hasDown && !hasLeft && !hasRight) return iconVertical(iconColor);
            if (hasLeft && !hasRight && !hasUp && !hasDown) return iconArrow("left", iconColor);
            if (hasRight && !hasLeft && !hasUp && !hasDown) return iconArrow("right", iconColor);
            if (hasUp && !hasLeft && !hasRight && !hasDown) return iconArrow("up", iconColor);
            if (hasDown && !hasLeft && !hasRight && !hasUp) return iconArrow("down", iconColor);
        }

        if (typeof keys === "string") {
            const direction = resolveDirectionForKey(keys, role);
            if (direction) return iconArrow(direction, iconColor);
        }

        if (role === "jump") return iconArrow("up", iconColor);
        if (role === "pause") return iconPause(iconColor);
        if (role === "primary") return iconCircle(true, iconColor);
        if (role === "secondary") return iconCircle(false, iconColor);
        if (role === "tertiary") return iconSquare(iconColor);
        if (role === "modifier") return iconChevron(iconColor);
        if (role === "magnitude") return iconArrow("up", iconColor);

        if (typeof keys === "string") {
            return iconKeycap(keyLabel(keys), iconColor);
        }

        return null;
    };

    const KEY_ALIASES = {
        " ": "Space",
        "space": "Space",
        "Spacebar": "Space",
        "Esc": "Escape",
        "Return": "Enter",
        "Left": "ArrowLeft",
        "Right": "ArrowRight",
        "Up": "ArrowUp",
        "Down": "ArrowDown",
        "Del": "Delete",
        "Shift": "ShiftLeft",
        "Control": "ControlLeft",
        "Alt": "AltLeft",
        "Meta": "MetaLeft"
    };

    const KEY_DESCRIPTORS = {
        ArrowLeft: { key: "ArrowLeft", keyCode: 37 },
        ArrowRight: { key: "ArrowRight", keyCode: 39 },
        ArrowUp: { key: "ArrowUp", keyCode: 38 },
        ArrowDown: { key: "ArrowDown", keyCode: 40 },
        Space: { key: " ", keyCode: 32 },
        Enter: { key: "Enter", keyCode: 13 },
        Tab: { key: "Tab", keyCode: 9 },
        Escape: { key: "Escape", keyCode: 27 },
        Backspace: { key: "Backspace", keyCode: 8 },
        Delete: { key: "Delete", keyCode: 46 },
        Insert: { key: "Insert", keyCode: 45 },
        Home: { key: "Home", keyCode: 36 },
        End: { key: "End", keyCode: 35 },
        PageUp: { key: "PageUp", keyCode: 33 },
        PageDown: { key: "PageDown", keyCode: 34 },
        CapsLock: { key: "CapsLock", keyCode: 20 },
        NumLock: { key: "NumLock", keyCode: 144 },
        ScrollLock: { key: "ScrollLock", keyCode: 145 },
        Pause: { key: "Pause", keyCode: 19 },
        PrintScreen: { key: "PrintScreen", keyCode: 44 },
        ContextMenu: { key: "ContextMenu", keyCode: 93 },
        ShiftLeft: { key: "Shift", keyCode: 16, location: 1 },
        ShiftRight: { key: "Shift", keyCode: 16, location: 2 },
        ControlLeft: { key: "Control", keyCode: 17, location: 1 },
        ControlRight: { key: "Control", keyCode: 17, location: 2 },
        AltLeft: { key: "Alt", keyCode: 18, location: 1 },
        AltRight: { key: "Alt", keyCode: 18, location: 2 },
        MetaLeft: { key: "Meta", keyCode: 91, location: 1 },
        MetaRight: { key: "Meta", keyCode: 91, location: 2 },
        Minus: { key: "-", keyCode: 189 },
        Equal: { key: "=", keyCode: 187 },
        BracketLeft: { key: "[", keyCode: 219 },
        BracketRight: { key: "]", keyCode: 221 },
        Backslash: { key: "\\", keyCode: 220 },
        Semicolon: { key: ";", keyCode: 186 },
        Quote: { key: "'", keyCode: 222 },
        Backquote: { key: "`", keyCode: 192 },
        Comma: { key: ",", keyCode: 188 },
        Period: { key: ".", keyCode: 190 },
        Slash: { key: "/", keyCode: 191 }
    };

    const NUMPAD_DESCRIPTORS = {
        NumpadAdd: { key: "+", keyCode: 107, location: 3 },
        NumpadSubtract: { key: "-", keyCode: 109, location: 3 },
        NumpadMultiply: { key: "*", keyCode: 106, location: 3 },
        NumpadDivide: { key: "/", keyCode: 111, location: 3 },
        NumpadDecimal: { key: ".", keyCode: 110, location: 3 },
        NumpadEnter: { key: "Enter", keyCode: 13, location: 3 },
        NumpadEqual: { key: "=", keyCode: 187, location: 3 }
    };

    const resolveKeyDescriptor = (rawKey) => {
        const raw = String(rawKey);
        const key = KEY_ALIASES[raw] || raw;
        let keyCode;
        let code;
        let keyValue = key;
        let location;

        const preset = KEY_DESCRIPTORS[key];
        if (preset) {
            keyCode = preset.keyCode;
            code = key;
            keyValue = preset.key;
            location = preset.location;
        }

        if (keyCode == null) {
            if (/^Key[a-zA-Z]$/.test(key)) {
                const letter = key.charAt(3).toUpperCase();
                keyCode = letter.charCodeAt(0);
                code = key;
                keyValue = letter.toLowerCase();
            } else if (/^Digit[0-9]$/.test(key)) {
                const digit = key.charAt(5);
                keyCode = 48 + parseInt(digit, 10);
                code = key;
                keyValue = digit;
            } else if (/^F([1-9]|1[0-9]|2[0-4])$/.test(key)) {
                const number = parseInt(key.slice(1), 10);
                keyCode = 111 + number;
                code = key;
                keyValue = key;
            } else if (/^Numpad[0-9]$/.test(key)) {
                const digit = parseInt(key.slice(6), 10);
                keyCode = 96 + digit;
                code = key;
                keyValue = String(digit);
                location = 3;
            } else if (NUMPAD_DESCRIPTORS[key]) {
                const numpadPreset = NUMPAD_DESCRIPTORS[key];
                keyCode = numpadPreset.keyCode;
                code = key;
                keyValue = numpadPreset.key;
                location = numpadPreset.location;
            } else if (key.length === 1) {
                const upper = key.toUpperCase();
                keyCode = upper.charCodeAt(0);
                code = upper;
                keyValue = key;
            } else {
                keyCode = key.toUpperCase().charCodeAt(0);
                code = key;
                keyValue = key;
            }
        }

        return { key: keyValue, code, keyCode, location };
    };

    const simulateKeyEvent = (key, type) => {
        const { key: keyValue, code, keyCode, location } = resolveKeyDescriptor(key);

        if (typeof KeyboardEvent === "undefined") return;

        const eventOptions = {
            key: keyValue,
            code: code,
            keyCode: keyCode,
            which: keyCode,
            bubbles: true,
            cancelable: true
        };
        if (location != null) {
            eventOptions.location = location;
        }
        const event = new KeyboardEvent(type, eventOptions);

        const canvas = typeof document !== "undefined" ? document.querySelector("canvas") : null;
        if (canvas && typeof canvas.focus === "function") {
            canvas.focus();
            canvas.dispatchEvent(event);
        } else if (typeof document !== "undefined") {
            document.dispatchEvent(event);
        }
    };

    const sanitizeActionMeta = (actionMeta) => {
        if (!actionMeta || typeof actionMeta !== "object") return {};
        const allowedBehavior = new Set(["continuous", "discrete"]);
        const allowedInteraction = new Set(["tap", "hold", "repeat"]);
        const allowedControlSpace = new Set(["vector", "rate", "magnitude"]);
        const allowedActivation = new Set(["hold", "latch"]);
        const allowedDirectionMode = new Set(["vector", "cardinal"]);
        const allowedGranularity = new Set(["fine", "coarse"]);
        const allowedPairPosition = new Set(["left", "right"]);

        const sanitized = {};
        Object.entries(actionMeta).forEach(([action, meta]) => {
            if (!meta || typeof meta !== "object") return;
            const cleaned = {};
            Object.entries(meta).forEach(([key, value]) => {
                if (key === "behavior" && allowedBehavior.has(value)) cleaned[key] = value;
                else if (key === "interaction" && allowedInteraction.has(value)) cleaned[key] = value;
                else if (key === "simultaneous" && typeof value === "boolean") cleaned[key] = value;
                else if (key === "control_space" && allowedControlSpace.has(value)) cleaned[key] = value;
                else if (key === "activation" && allowedActivation.has(value)) cleaned[key] = value;
                else if (key === "direction_mode" && allowedDirectionMode.has(value)) cleaned[key] = value;
                else if (key === "granularity" && allowedGranularity.has(value)) cleaned[key] = value;
                else if (key === "pair_id" && typeof value === "string") cleaned[key] = value;
                else if (key === "pair_position" && allowedPairPosition.has(value)) cleaned[key] = value;
                else if (key === "kind" && typeof value === "string") cleaned[key] = value;
            });
            if (Object.keys(cleaned).length) {
                sanitized[action] = cleaned;
            }
        });
        return sanitized;
    };

    const extractMeta = (spec, kind) => {
        const meta = {};
        if (spec && typeof spec === "object") {
            ["behavior", "interaction", "simultaneous", "control_space", "activation", "direction_mode", "granularity", "pair_id", "pair_position"].forEach((field) => {
                if (field in spec) meta[field] = spec[field];
            });
        }
        if (kind) meta.kind = kind;
        return meta;
    };

    const extractActionKeys = (spec) => {
        if (spec && typeof spec === "object") {
            if ("keys" in spec) return spec.keys;
            if ("key" in spec) return spec.key;
        }
        return spec;
    };

    const selectSingleKey = (keys) => {
        if (!keys || typeof keys !== "object") return null;
        const order = ["up", "right", "down", "left"];
        for (let i = 0; i < order.length; i += 1) {
            const key = keys[order[i]];
            if (key) return key;
        }
        return null;
    };

    const axisPriority = (axis) => {
        const priority = axis.priority;
        const priorityScore = priority === "primary" ? 2 : priority === "secondary" ? 1 : 0;
        const controlSpace = axis.control_space;
        const controlScore = controlSpace === "vector" ? 2 : controlSpace === "rate" ? 1 : 0;
        return [priorityScore, controlScore];
    };

    const extractBindingsFromAxesActions = (data) => {
        if (!data || typeof data !== "object") return null;
        const axes = data.axes;
        const actions = data.actions;
        if (!Array.isArray(axes) && (typeof actions !== "object" || actions === null)) {
            return null;
        }

        const bindings = {};
        let actionMeta = {};

        if (actions && typeof actions === "object") {
            Object.entries(actions).forEach(([role, spec]) => {
                const keys = extractActionKeys(spec);
                if (!keys) return;
                bindings[role] = keys;
                const meta = extractMeta(spec, "button");
                if (Object.keys(meta).length) {
                    actionMeta[role] = meta;
                }
            });
        }

        const movementAxes = [];
        const aimAxes = [];

        if (Array.isArray(axes)) {
            axes.forEach((axis) => {
                if (!axis || typeof axis !== "object") return;
                const keys = axis.keys;
                if (!keys || typeof keys !== "object") return;
                const usage = axis.usage;
                const controlSpace = axis.control_space;
                if (usage !== "movement" && usage !== "aim") return;

                if (controlSpace === "magnitude") {
                    if (bindings.magnitude) return;
                    const magKey = selectSingleKey(keys);
                    if (!magKey) return;
                    bindings.magnitude = magKey;
                    const magMeta = extractMeta(axis, "button");
                    magMeta.control_space = "magnitude";
                    actionMeta.magnitude = magMeta;
                    return;
                }

                if (usage === "movement") movementAxes.push(axis);
                if (usage === "aim") aimAxes.push(axis);
            });
        }

        const buildAxisMapping = (axis) => {
            const keys = axis.keys;
            const meta = extractMeta(axis, "axis");
            if (axis.control_space) meta.control_space = axis.control_space;
            return { keys, meta };
        };

        const compareAxis = (a, b) => {
            const [ap, ac] = axisPriority(a);
            const [bp, bc] = axisPriority(b);
            if (ap !== bp) return bp - ap;
            return bc - ac;
        };

        if (movementAxes.length) {
            movementAxes.sort(compareAxis);
            const move = buildAxisMapping(movementAxes[0]);
            bindings.move = move.keys;
            if (Object.keys(move.meta).length) actionMeta.move = move.meta;

            if (aimAxes.length) {
                aimAxes.sort(compareAxis);
                const aim = buildAxisMapping(aimAxes[0]);
                bindings.aim = aim.keys;
                if (Object.keys(aim.meta).length) actionMeta.aim = aim.meta;
            }
        } else if (aimAxes.length) {
            aimAxes.sort(compareAxis);
            const move = buildAxisMapping(aimAxes[0]);
            bindings.move = move.keys;
            if (Object.keys(move.meta).length) actionMeta.move = move.meta;

            if (aimAxes.length > 1) {
                const aim = buildAxisMapping(aimAxes[1]);
                bindings.aim = aim.keys;
                if (Object.keys(aim.meta).length) actionMeta.aim = aim.meta;
            }
        }

        actionMeta = sanitizeActionMeta(actionMeta);
        return { bindings, actionMeta };
    };

    const resolveBindingsAndMeta = (config = {}) => {
        let bindings = config.bindings || {};
        let actionMeta = config.actionMeta || config.action_meta || {};

        let analysis = null;
        if (Array.isArray(config.axes) || (config.actions && typeof config.actions === "object")) {
            analysis = { axes: config.axes || [], actions: config.actions || {} };
        } else if (bindings && typeof bindings === "object" && (bindings.axes || bindings.actions)) {
            analysis = { axes: bindings.axes || [], actions: bindings.actions || {} };
        } else if (actionMeta && typeof actionMeta === "object" && (actionMeta.axes || actionMeta.actions)) {
            analysis = { axes: actionMeta.axes || [], actions: actionMeta.actions || {} };
        }

        if (analysis) {
            const extracted = extractBindingsFromAxesActions(analysis);
            if (extracted) {
                bindings = extracted.bindings || {};
                actionMeta = extracted.actionMeta || {};
            }
        }

        if (!bindings || typeof bindings !== "object") bindings = {};
        if (!actionMeta || typeof actionMeta !== "object") actionMeta = {};

        return { bindings, actionMeta };
    };

    const parseKeys = (keys) => {
        let keyMap = { left: null, right: null, up: null, down: null, key: null };

        if (Array.isArray(keys)) {
            if (keys.length === 2) {
                keyMap.left = keys[0] || null;
                keyMap.right = keys[1] || null;
            } else if (keys.length === 1) {
                keyMap.key = keys[0];
            } else {
                keyMap.left = keys[0] || null;
                keyMap.right = keys[1] || null;
                keyMap.up = keys[2] || null;
                keyMap.down = keys[3] || null;
            }
        } else if (keys && typeof keys === "object") {
            keyMap.left = keys.left || null;
            keyMap.right = keys.right || null;
            keyMap.up = keys.up || null;
            keyMap.down = keys.down || null;
            if (keys.key) keyMap.key = keys.key;
        } else if (typeof keys === "string") {
            keyMap.key = keys;
        }

        return keyMap;
    };

    const createNipple = (element, keys) => {
        if (typeof nipplejs === "undefined") {
            throw new Error(
                "[touchpad_controls] nipplejs is required to create joystick controls. " +
                "Include nipplejs before touchpad-controls.js."
            );
        }

        const options = {
            zone: element,
            mode: "static",
            position: { top: "50%", left: "50%" },
            color: "gray",
            size: 120,
            threshold: 0.25
        };

        const keyMap = parseKeys(keys);

        const hasLeft = keyMap.left != null;
        const hasRight = keyMap.right != null;
        const hasUp = keyMap.up != null;
        const hasDown = keyMap.down != null;
        const hasSingleKey = keyMap.key != null;

        if ((hasLeft || hasRight) && !(hasUp || hasDown)) {
            options.lockX = true;
        } else if ((hasUp || hasDown) && !(hasLeft || hasRight)) {
            options.lockY = true;
        } else if (hasSingleKey) {
            options.lockX = true;
            options.lockY = true;
        } else {
            options.lockX = false;
            options.lockY = false;
        }

        const manager = nipplejs.create(options);

        const activeKeys = {};
        const activeDirections = new Set();

        const getDirections = (direction) => {
            if (!direction) return [];
            const directions = [];
            if (direction.x === "left" || direction.x === "right") {
                directions.push(direction.x);
            }
            if (direction.y === "up" || direction.y === "down") {
                directions.push(direction.y);
            }
            return directions;
        };

        manager.on("start", () => {
            element.classList.add("is-active");
        });

        const syncDirections = (directionsSet) => {
            const toRelease = [];
            activeDirections.forEach((direction) => {
                if (!directionsSet.has(direction)) {
                    toRelease.push(direction);
                }
            });

            toRelease.forEach((direction) => {
                const key = keyMap[direction];
                if (key && activeKeys[key]) {
                    simulateKeyEvent(key, "keyup");
                    activeKeys[key] = false;
                }
                activeDirections.delete(direction);
            });

            directionsSet.forEach((direction) => {
                if (activeDirections.has(direction)) return;
                const key = keyMap[direction];
                if (!key) return;
                if (!activeKeys[key]) {
                    simulateKeyEvent(key, "keydown");
                    activeKeys[key] = true;
                }
                activeDirections.add(direction);
            });
        };

        manager.on("dir", (evt, data) => {
            const directions = getDirections(data && data.direction);
            if (!directions.length) return;
            syncDirections(new Set(directions));
        });

        const releaseAllKeys = () => {
            Object.keys(activeKeys).forEach((key) => {
                if (activeKeys[key]) {
                    simulateKeyEvent(key, "keyup");
                    activeKeys[key] = false;
                }
            });
            activeDirections.clear();
        };

        manager.on("move", (evt, data) => {
            if (!data || !data.direction) {
                releaseAllKeys();
                return;
            }

            const currentDirections = new Set();
            if (data.direction.x) currentDirections.add(data.direction.x);
            if (data.direction.y) currentDirections.add(data.direction.y);

            syncDirections(currentDirections);
        });

        manager.on("end", () => {
            releaseAllKeys();
            element.classList.remove("is-active");
        });

        return manager;
    };

    const createButton = (element, key) => {
        const keys = Array.isArray(key) ? key.filter((k) => k != null) : [key];
        if (!keys.length) return;

        let isActive = false;

        const press = (event) => {
            if (event && typeof event.preventDefault === "function") {
                event.preventDefault();
            }
            if (isActive) return;
            isActive = true;
            element.classList.add("is-active");
            keys.forEach((k) => simulateKeyEvent(k, "keydown"));
        };

        const release = (event) => {
            if (event && typeof event.preventDefault === "function") {
                event.preventDefault();
            }
            if (!isActive) return;
            isActive = false;
            element.classList.remove("is-active");
            keys.forEach((k) => simulateKeyEvent(k, "keyup"));
        };

        const handleMouseDown = (event) => {
            press(event);
            const handleMouseUp = (e) => {
                release(e);
                window.removeEventListener("mouseup", handleMouseUp);
            };
            window.addEventListener("mouseup", handleMouseUp);
        };

        const handleTouchStart = (event) => {
            press(event);
            const handleTouchEndOrCancel = (e) => {
                release(e);
                window.removeEventListener("touchend", handleTouchEndOrCancel);
                window.removeEventListener("touchcancel", handleTouchEndOrCancel);
            };
            window.addEventListener("touchend", handleTouchEndOrCancel);
            window.addEventListener("touchcancel", handleTouchEndOrCancel);
        };

        element.addEventListener("mousedown", handleMouseDown);
        element.addEventListener("touchstart", handleTouchStart, {
            passive: false
        });

        element.addEventListener("mouseup", release);
        element.addEventListener("mouseleave", release);
        element.addEventListener("touchend", release);
        element.addEventListener("touchcancel", release);
    };

    const createTouchpadControls = (config = {}) => {
        if (typeof document === "undefined") {
            throw new Error("[touchpad_controls] document is required to render controls.");
        }

        injectTouchpadStyles();

        const root = config.root || document.body || document.documentElement;
        const baseTheme = normalizeTheme(config.theme);
        const buttons = Array.isArray(config.buttons) ? config.buttons : [];

        const touchpads = [];
        const nippleManagers = [];

        buttons.forEach((btn) => {
            if (!btn) return;

            const theme = mergeTheme(baseTheme, btn.theme);
            const touchpad = document.createElement("div");
            touchpad.id = btn.id || "";
            touchpad.className = "touchpad";

            if (btn.className) {
                touchpad.className += " " + btn.className;
            }
            if (Array.isArray(btn.classList)) {
                btn.classList.forEach((cls) => {
                    if (cls) touchpad.classList.add(cls);
                });
            }

            let type = btn.type;
            if (!type) {
                if (
                    (Array.isArray(btn.keys) && btn.keys.length > 1) ||
                    (btn.keys && typeof btn.keys === "object" && !Array.isArray(btn.keys))
                ) {
                    type = "joystick";
                } else {
                    type = "button";
                }
            }

            const labelMode = btn.labelMode || theme.labelMode || "none";
            const labelText = type === "button" ? resolveLabelText(btn, labelMode) : "";
            if (labelText) {
                const labelEl = document.createElement("span");
                labelEl.className = "touchpad-label";
                labelEl.textContent = labelText;
                touchpad.classList.add("touchpad--label");
                touchpad.appendChild(labelEl);
            }

            const ariaLabel = btn.label != null
                ? String(btn.label)
                : (labelText || (typeof btn.keys === "string" ? keyLabel(btn.keys) : ""));
            if (ariaLabel) {
                touchpad.setAttribute("aria-label", ariaLabel);
            }

            const sectionName = btn.section;
            const section = sectionName && sections[sectionName] ? sections[sectionName] : null;

            safeEntries(section).forEach(([key, value]) => {
                touchpad.style[key] = value;
            });

            const posName = btn.position;
            const buttonPosition =
                posName && buttonPositions[posName]
                    ? buttonPositions[posName]
                    : null;

            if (section && buttonPosition) {
                safeEntries(buttonPosition).forEach(([key, value]) => {
                    const base = section[key] || "0px";
                    touchpad.style[key] = `calc(${base} + ${value})`;
                });
            }

            if (btn.top != null) {
                touchpad.style.top = formatCssValue(btn.top);
            }
            if (btn.left != null) {
                touchpad.style.left = formatCssValue(btn.left);
            }
            if (btn.x != null) {
                touchpad.style.left = formatCssValue(btn.x);
            }
            if (btn.y != null) {
                touchpad.style.top = formatCssValue(btn.y);
            }

            safeEntries(btn.style).forEach(([key, value]) => {
                if (value != null) {
                    touchpad.style[key] = formatCssValue(value);
                }
            });

            applyThemeVars(touchpad, theme);

            const showIcon = labelMode !== "text" && labelMode !== "key";
            if (showIcon) {
                const icon = resolveIcon(btn, theme);
                if (icon) {
                    touchpad.style.setProperty("--touchpad-icon", icon);
                }
            }

            root.appendChild(touchpad);

            touchpad.dataset.touchpadType = type;
            if (type === "joystick") {
                touchpad.classList.add("touchpad--joystick");
            } else {
                touchpad.classList.add("touchpad--button");
            }

            const tp = { element: touchpad, keys: btn.keys, type: type };
            touchpads.push(tp);
        });

        touchpads.forEach((tp) => {
            if (tp.type === "joystick") {
                const manager = createNipple(tp.element, tp.keys);
                if (manager) nippleManagers.push(manager);
            } else {
                createButton(tp.element, tp.keys);
            }
        });

        const destroy = () => {
            nippleManagers.forEach((manager) => {
                if (manager && typeof manager.destroy === "function") {
                    manager.destroy();
                }
            });

            touchpads.forEach((tp) => {
                const el = tp.element;
                if (el && el.parentNode) {
                    el.parentNode.removeChild(el);
                }
            });
        };

        return { touchpads, destroy };
    };

    const getSafeAreaInsets = (viewport) => {
        if (viewport && viewport.safeArea) {
            return {
                top: viewport.safeArea.top || 0,
                right: viewport.safeArea.right || 0,
                bottom: viewport.safeArea.bottom || 0,
                left: viewport.safeArea.left || 0
            };
        }

        if (typeof document === "undefined") {
            return { top: 0, right: 0, bottom: 0, left: 0 };
        }

        const measure = document.createElement("div");
        measure.style.cssText = [
            "position: fixed",
            "top: 0",
            "left: 0",
            "right: 0",
            "bottom: 0",
            "padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)",
            "pointer-events: none",
            "visibility: hidden"
        ].join(";");

        const root = document.body || document.documentElement;
        root.appendChild(measure);
        const style = window.getComputedStyle(measure);
        const insets = {
            top: parseFloat(style.paddingTop) || 0,
            right: parseFloat(style.paddingRight) || 0,
            bottom: parseFloat(style.paddingBottom) || 0,
            left: parseFloat(style.paddingLeft) || 0
        };
        root.removeChild(measure);
        return insets;
    };

    const normalizeBindings = (bindings = {}) => {
        const move = parseKeys(bindings.move || bindings.movement || null);
        const aim = parseKeys(bindings.aim || bindings.look || null);

        const jump = bindings.jump || null;
        const magnitude = bindings.magnitude || null;
        const primary = bindings.primary || bindings.shoot || bindings.fire || null;
        const secondary = bindings.secondary || bindings.attack || null;
        const tertiary = bindings.tertiary || (bindings.shoot && bindings.shoot !== primary ? bindings.shoot : null) || null;
        const modifier = bindings.modifier || bindings.run || null;

        return { move, aim, jump, magnitude, primary, secondary, tertiary, modifier };
    };

    const normalizeActionMeta = (actionMeta = {}) => {
        if (!actionMeta || typeof actionMeta !== "object") return {};
        return actionMeta;
    };

    const hasDirectionalKeys = (keyMap) => !!(keyMap && (keyMap.left || keyMap.right || keyMap.up || keyMap.down));

    const deriveAxisKeys = (keyMap, meta) => {
        if (!keyMap || !meta || typeof meta !== "object") return keyMap;
        const controlSpace = meta.control_space;
        if (controlSpace === "rate") {
            if (!keyMap.left && !keyMap.right) return keyMap;
            return {
                left: keyMap.left || null,
                right: keyMap.right || null,
                up: null,
                down: null
            };
        }
        if (controlSpace === "magnitude") {
            if (!keyMap.up && !keyMap.down) return keyMap;
            return {
                left: null,
                right: null,
                up: keyMap.up || null,
                down: keyMap.down || null
            };
        }
        return keyMap;
    };

    const chooseLayout = (bindings, preferredLayout, actionMeta = {}) => {
        if (preferredLayout && preferredLayout !== "auto") return preferredLayout;

        const moveMeta = actionMeta && actionMeta.move ? actionMeta.move : null;
        const moveKeys = deriveAxisKeys(bindings.move, moveMeta);
        const hasMove = hasDirectionalKeys(moveKeys);
        const hasAim = hasDirectionalKeys(bindings.aim);

        if (hasAim) return "dual-stick";
        if (hasMove) {
            const isCardinal = moveMeta && moveMeta.direction_mode === "cardinal";
            const isDiscrete = moveMeta && (
                moveMeta.behavior === "discrete" ||
                moveMeta.activation === "latch" ||
                moveMeta.granularity === "coarse"
            );
            const requiresChord = moveMeta && moveMeta.simultaneous === true;
            const hasVertical = !!(moveKeys.up || moveKeys.down);
            if (!requiresChord && (isDiscrete || (isCardinal && hasVertical))) {
                return "digital-dpad";
            }
            if (moveKeys.up || moveKeys.down) return "fast-platformer";
            return "safe-platformer";
        }
        return "runner";
    };

    const getLayoutMetrics = (viewport, options = {}) => {
        const width = viewport && Number.isFinite(viewport.width)
            ? viewport.width
            : (typeof window !== "undefined" ? window.innerWidth : 0);
        const height = viewport && Number.isFinite(viewport.height)
            ? viewport.height
            : (typeof window !== "undefined" ? window.innerHeight : 0);

        const safeArea = getSafeAreaInsets(viewport);
        const minDim = Math.max(1, Math.min(width, height));
        const orientation = width >= height ? "landscape" : "portrait";

        const baseSize = clamp(minDim * 0.17, 64, 112);
        const actionSize = clamp(minDim * 0.14, 56, 96);
        const smallActionSize = clamp(minDim * 0.12, MIN_TOUCH_TARGET, 80);
        const miniActionSize = clamp(minDim * 0.1, MIN_TOUCH_TARGET, 72);
        const spacing = clamp(minDim * 0.03, 10, 20);
        const edgePadding = clamp(minDim * 0.05, 16, 32);
        const verticalOffset = orientation === "portrait"
            ? clamp(minDim * 0.04, 8, 16)
            : clamp(minDim * 0.02, 6, 12);

        const bottomY = height - safeArea.bottom - edgePadding;

        return {
            width,
            height,
            orientation,
            safeArea,
            minDim,
            baseSize,
            actionSize,
            smallActionSize,
            miniActionSize,
            spacing,
            edgePadding,
            verticalOffset,
            bottomY
        };
    };

    const clampPosition = (pos, size, metrics) => {
        const minX = metrics.safeArea.left + metrics.edgePadding + size / 2;
        const maxX = metrics.width - metrics.safeArea.right - metrics.edgePadding - size / 2;
        const minY = metrics.safeArea.top + metrics.edgePadding + size / 2;
        const maxY = metrics.height - metrics.safeArea.bottom - metrics.edgePadding - size / 2;
        return {
            x: clamp(pos.x, minX, maxX),
            y: clamp(pos.y, minY, maxY)
        };
    };

    const makeButton = (spec) => {
        const baseStyle = {
            width: spec.size,
            height: spec.size,
            transform: "translate(-50%, -50%)"
        };

        return {
            id: spec.id,
            label: spec.label || "",
            keys: spec.keys,
            x: spec.x,
            y: spec.y,
            size: spec.size,
            role: spec.role,
            type: spec.type,
            meta: spec.meta || null,
            icon: spec.icon || null,
            classList: spec.classList || [],
            style: Object.assign(baseStyle, spec.style || {})
        };
    };

    const getActionSize = (sizes, role) => {
        if (!sizes) return 0;
        return sizes[role] || sizes.secondary || sizes.primary || 0;
    };

    const findPairedActions = (actions = []) => {
        const groups = new Map();
        actions.forEach((action) => {
            const meta = action && action.meta ? action.meta : null;
            const pairId = meta && meta.pair_id;
            if (!pairId) return;
            if (!groups.has(pairId)) groups.set(pairId, []);
            groups.get(pairId).push(action);
        });

        for (const [pairId, group] of groups.entries()) {
            if (group.length < 2) continue;
            let left = group.find((action) => action.meta && action.meta.pair_position === "left");
            let right = group.find((action) => action.meta && action.meta.pair_position === "right");
            if (!left || !right) {
                left = group[0];
                right = group[1];
            }
            if (left === right) continue;
            return { pairId, left, right };
        }
        return null;
    };

    const buildActionCluster = (anchor, actions, sizes, metrics) => {
        const buttons = [];
        if (!actions.length) return buttons;

        const pair = findPairedActions(actions);
        if (!pair) {
            const primary = actions[0];
            const primarySize = sizes.primary;
            const primaryPos = clampPosition(anchor, primarySize, metrics);
            buttons.push(makeButton({
                id: primary.role,
                keys: primary.keys,
                role: primary.role,
                x: primaryPos.x,
                y: primaryPos.y,
                size: primarySize,
                meta: primary.meta || null,
                classList: ["touchpad-role-" + primary.role]
            }));

            if (actions[1]) {
                const secondary = actions[1];
                const secondarySize = sizes.secondary;
                const secondaryPos = clampPosition({
                    x: anchor.x,
                    y: anchor.y - (primarySize / 2 + metrics.spacing + secondarySize / 2)
                }, secondarySize, metrics);
                buttons.push(makeButton({
                    id: secondary.role,
                    keys: secondary.keys,
                    role: secondary.role,
                    x: secondaryPos.x,
                    y: secondaryPos.y,
                    size: secondarySize,
                    meta: secondary.meta || null,
                    classList: ["touchpad-role-" + secondary.role]
                }));
            }

            if (actions[2]) {
                const tertiary = actions[2];
                const tertiarySize = sizes.tertiary;
                const tertiaryPos = clampPosition({
                    x: anchor.x - (primarySize / 2 + metrics.spacing + tertiarySize / 2),
                    y: anchor.y - primarySize * 0.2
                }, tertiarySize, metrics);
                buttons.push(makeButton({
                    id: tertiary.role,
                    keys: tertiary.keys,
                    role: tertiary.role,
                    x: tertiaryPos.x,
                    y: tertiaryPos.y,
                    size: tertiarySize,
                    meta: tertiary.meta || null,
                    classList: ["touchpad-role-" + tertiary.role]
                }));
            }

            if (actions[3]) {
                const modifier = actions[3];
                const modifierSize = sizes.modifier;
                const modifierPos = clampPosition({
                    x: anchor.x - (primarySize / 2 + metrics.spacing + modifierSize / 2),
                    y: anchor.y - (primarySize / 2 + metrics.spacing + modifierSize / 2)
                }, modifierSize, metrics);
                buttons.push(makeButton({
                    id: modifier.role,
                    keys: modifier.keys,
                    role: modifier.role,
                    x: modifierPos.x,
                    y: modifierPos.y,
                    size: modifierSize,
                    meta: modifier.meta || null,
                    classList: ["touchpad-role-" + modifier.role]
                }));
            }

            return buttons;
        }

        const used = new Set();
        const place = (action, pos, size) => {
            if (!action || used.has(action)) return;
            used.add(action);
            const clamped = clampPosition(pos, size, metrics);
            buttons.push(makeButton({
                id: action.role,
                keys: action.keys,
                role: action.role,
                x: clamped.x,
                y: clamped.y,
                size,
                meta: action.meta || null,
                classList: ["touchpad-role-" + action.role]
            }));
        };

        const primary = actions.find((action) => action.role === "primary" && action !== pair.left && action !== pair.right)
            || actions.find((action) => action !== pair.left && action !== pair.right);
        const primarySize = primary ? getActionSize(sizes, primary.role) : 0;

        const leftAction = pair.left;
        const rightAction = pair.right;
        const leftSize = getActionSize(sizes, leftAction.role);
        const rightSize = getActionSize(sizes, rightAction.role);
        const rowHeight = Math.max(leftSize, rightSize);
        const rowWidth = leftSize + rightSize + metrics.spacing;

        const minCenterX = metrics.safeArea.left + metrics.edgePadding + rowWidth / 2;
        const maxCenterX = metrics.width - metrics.safeArea.right - metrics.edgePadding - rowWidth / 2;
        const centerX = clamp(anchor.x, minCenterX, maxCenterX);

        let primaryPos = null;
        if (primary) {
            primaryPos = clampPosition({ x: centerX, y: anchor.y }, primarySize, metrics);
            place(primary, primaryPos, primarySize);
        }

        const baseY = primaryPos ? primaryPos.y : anchor.y;
        const rowY = primaryPos
            ? baseY - (primarySize / 2 + metrics.spacing + rowHeight / 2)
            : baseY;

        const leftX = centerX - rowWidth / 2 + leftSize / 2;
        const rightX = centerX + rowWidth / 2 - rightSize / 2;
        place(leftAction, { x: leftX, y: rowY }, leftSize);
        place(rightAction, { x: rightX, y: rowY }, rightSize);

        let stackY = rowY - rowHeight / 2 - metrics.spacing;
        actions.forEach((action) => {
            if (used.has(action)) return;
            const size = getActionSize(sizes, action.role);
            place(action, { x: centerX, y: stackY - size / 2 }, size);
            stackY = stackY - size - metrics.spacing;
        });

        return buttons;
    };

    const buildButtonsForLayout = (layout, bindings, metrics, actionMeta) => {
        const buttons = [];
        const actions = [];
        const roleOrder = ["magnitude", "jump", "primary", "secondary", "tertiary", "modifier"];
        const roleBaseScore = {
            magnitude: 5,
            jump: 4,
            primary: 3,
            secondary: 2,
            tertiary: 1,
            modifier: 1
        };

        const moveMeta = actionMeta && actionMeta.move ? actionMeta.move : null;
        const moveKeys = deriveAxisKeys(bindings.move, moveMeta);

        const usedKeys = new Set();
        const addAction = (role, keys) => {
            if (!keys) return;
            const signature = JSON.stringify(keys);
            if (usedKeys.has(signature)) return;
            usedKeys.add(signature);
            actions.push({
                role,
                keys,
                meta: actionMeta && actionMeta[role] ? actionMeta[role] : null
            });
        };

        roleOrder.forEach((role) => addAction(role, bindings[role]));

        actions.forEach((action, index) => {
            const meta = action.meta || {};
            let score = roleBaseScore[action.role] || 0;
            if (meta.behavior === "discrete") score += 1;
            if (meta.interaction === "tap") score += 1;
            if (meta.simultaneous === true) score += 1;
            if (meta.control_space === "magnitude") score += 2;
            if (meta.behavior === "continuous" && meta.interaction === "hold" && meta.simultaneous === false) {
                score -= 1;
            }
            action._score = score;
            action._index = index;
        });

        actions.sort((a, b) => {
            if (b._score !== a._score) return b._score - a._score;
            return a._index - b._index;
        });

        const leftAnchor = {
            x: metrics.safeArea.left + metrics.edgePadding + metrics.baseSize / 2,
            y: metrics.bottomY - metrics.baseSize / 2 - metrics.verticalOffset
        };
        const rightAnchor = {
            x: metrics.width - metrics.safeArea.right - metrics.edgePadding - metrics.baseSize / 2,
            y: metrics.bottomY - metrics.baseSize / 2 - metrics.verticalOffset
        };

        if (!actions.length && !hasDirectionalKeys(moveKeys) && !hasDirectionalKeys(bindings.aim)) {
            return buttons;
        }

        if (layout === "digital-dpad") {
            if (hasDirectionalKeys(moveKeys)) {
                const dpadSize = clamp(metrics.baseSize * 0.5, MIN_TOUCH_TARGET, metrics.baseSize * 0.75);
                const dpadGap = clamp(dpadSize * 0.2, 6, 14);
                const offset = dpadSize + dpadGap;
                const radius = offset + dpadSize / 2;
                const minCenterX = metrics.safeArea.left + metrics.edgePadding + radius;
                const maxCenterX = metrics.width - metrics.safeArea.right - metrics.edgePadding - radius;
                const minCenterY = metrics.safeArea.top + metrics.edgePadding + radius;
                const maxCenterY = metrics.height - metrics.safeArea.bottom - metrics.edgePadding - radius;
                const center = {
                    x: clamp(leftAnchor.x, minCenterX, maxCenterX),
                    y: clamp(leftAnchor.y, minCenterY, maxCenterY)
                };
                const directions = [
                    { name: "up", x: center.x, y: center.y - offset },
                    { name: "down", x: center.x, y: center.y + offset },
                    { name: "left", x: center.x - offset, y: center.y },
                    { name: "right", x: center.x + offset, y: center.y }
                ];

                directions.forEach((dir) => {
                    const key = moveKeys[dir.name];
                    if (!key) return;
                    buttons.push(makeButton({
                        id: `move-${dir.name}`,
                        keys: key,
                        role: "move",
                        x: dir.x,
                        y: dir.y,
                        size: dpadSize,
                        type: "button",
                        meta: actionMeta && actionMeta.move ? actionMeta.move : null,
                        classList: ["touchpad-role-move", "touchpad--dpad", `touchpad-move-${dir.name}`]
                    }));
                });
            }

            const clusterButtons = buildActionCluster(
                rightAnchor,
                actions,
                {
                    primary: metrics.actionSize,
                    secondary: metrics.smallActionSize,
                    tertiary: metrics.smallActionSize,
                    modifier: metrics.miniActionSize
                },
                metrics
            );
            buttons.push(...clusterButtons);
        } else if (layout === "safe-platformer" || layout === "fast-platformer") {
            if (hasDirectionalKeys(moveKeys)) {
                const moveSize = metrics.baseSize;
                const movePos = clampPosition(leftAnchor, moveSize, metrics);
                buttons.push(makeButton({
                    id: "move",
                    keys: moveKeys,
                    role: "move",
                    x: movePos.x,
                    y: movePos.y,
                    size: moveSize,
                    meta: actionMeta && actionMeta.move ? actionMeta.move : null,
                    classList: ["touchpad-role-move"]
                }));
            }

            const clusterButtons = buildActionCluster(
                rightAnchor,
                actions,
                {
                    primary: metrics.actionSize,
                    secondary: metrics.smallActionSize,
                    tertiary: metrics.smallActionSize,
                    modifier: metrics.miniActionSize
                },
                metrics
            );
            buttons.push(...clusterButtons);
        } else if (layout === "dual-stick") {
            const moveSize = clamp(metrics.baseSize * 1.05, 64, 120);
            const aimSize = clamp(metrics.baseSize * 0.95, 60, 112);

            if (hasDirectionalKeys(moveKeys)) {
                const leftPos = clampPosition({
                    x: metrics.safeArea.left + metrics.edgePadding + moveSize / 2,
                    y: metrics.bottomY - moveSize / 2 - metrics.verticalOffset
                }, moveSize, metrics);
                buttons.push(makeButton({
                    id: "move",
                    keys: moveKeys,
                    role: "move",
                    x: leftPos.x,
                    y: leftPos.y,
                    size: moveSize,
                    meta: actionMeta && actionMeta.move ? actionMeta.move : null,
                    classList: ["touchpad-role-move"]
                }));
            }

            if (hasDirectionalKeys(bindings.aim)) {
                const rightPos = clampPosition({
                    x: metrics.width - metrics.safeArea.right - metrics.edgePadding - aimSize / 2,
                    y: metrics.bottomY - aimSize / 2 - metrics.verticalOffset
                }, aimSize, metrics);
                buttons.push(makeButton({
                    id: "aim",
                    keys: bindings.aim,
                    role: "aim",
                    x: rightPos.x,
                    y: rightPos.y,
                    size: aimSize,
                    meta: actionMeta && actionMeta.aim ? actionMeta.aim : null,
                    classList: ["touchpad-role-aim"]
                }));

                if (actions[0]) {
                    const fireSize = metrics.actionSize;
                    const firePos = clampPosition({
                        x: rightPos.x,
                        y: rightPos.y - (aimSize / 2 + metrics.spacing + fireSize / 2)
                    }, fireSize, metrics);
                    buttons.push(makeButton({
                        id: actions[0].role,
                        keys: actions[0].keys,
                        role: actions[0].role,
                        x: firePos.x,
                        y: firePos.y,
                        size: fireSize,
                        meta: actions[0].meta || null,
                        classList: ["touchpad-role-" + actions[0].role]
                    }));
                }
            }
        } else if (layout === "runner") {
            const actionCount = Math.min(actions.length || 1, 4);
            const slots = actionCount === 1
                ? [0.5]
                : actionCount === 2
                    ? [0.35, 0.65]
                    : actionCount === 3
                        ? [0.2, 0.5, 0.8]
                        : [0.15, 0.4, 0.6, 0.85];

            const size = metrics.actionSize;
            const availableWidth = metrics.width - metrics.safeArea.left - metrics.safeArea.right - metrics.edgePadding * 2;
            const bandY = metrics.bottomY - size / 2 - metrics.verticalOffset;

            for (let i = 0; i < actionCount; i += 1) {
                const action = actions[i] || actions[0] || { role: "primary", keys: bindings.primary };
                const x = metrics.safeArea.left + metrics.edgePadding + availableWidth * slots[i];
                const pos = clampPosition({ x, y: bandY }, size, metrics);
                buttons.push(makeButton({
                    id: action.role,
                    keys: action.keys,
                    role: action.role,
                    x: pos.x,
                    y: pos.y,
                    size: size,
                    meta: action.meta || null,
                    classList: ["touchpad-role-" + action.role]
                }));
            }
        }

        return buttons;
    };

    const buildLayout = (config = {}) => {
        const resolved = resolveBindingsAndMeta(config);
        const normalized = normalizeBindings(resolved.bindings || {});
        const actionMeta = normalizeActionMeta(resolved.actionMeta || {});
        const layout = chooseLayout(normalized, config.layout, actionMeta);
        const metrics = getLayoutMetrics(config.viewport, config);
        const buttons = buildButtonsForLayout(layout, normalized, metrics, actionMeta);
        return { layout, buttons, metrics, bindings: normalized, actionMeta };
    };

    const roundLayoutValue = (value) => {
        if (typeof value !== "number" || !Number.isFinite(value)) return value;
        return Math.round(value * 10) / 10;
    };

    const summarizeLayout = (layoutConfig) => {
        if (!layoutConfig || typeof layoutConfig !== "object") return null;
        const buttons = Array.isArray(layoutConfig.buttons) ? layoutConfig.buttons : [];
        return {
            layout: layoutConfig.layout || null,
            buttons: buttons.map((btn) => ({
                id: btn.id || null,
                role: btn.role || null,
                type: btn.type || (btn.keys && typeof btn.keys === "object" ? "joystick" : "button"),
                keys: btn.keys || null,
                x: roundLayoutValue(btn.x),
                y: roundLayoutValue(btn.y),
                size: roundLayoutValue(btn.size)
            }))
        };
    };

    const createGesturePrevention = (options = {}) => {
        if (typeof document === "undefined") return () => {};

        const extraExclusions = Array.isArray(options.excludeSelectors) ? options.excludeSelectors : [];
        const handler = (event) => {
            if (!event || typeof event.preventDefault !== "function") return;
            const target = event.target;
            if (!target) {
                event.preventDefault();
                return;
            }

            const tagName = target.tagName;
            const blockedTags = ["SELECT", "OPTION", "BUTTON", "INPUT", "TEXTAREA", "A"];
            if (tagName && blockedTags.includes(tagName)) return;

            if (extraExclusions.some((selector) => target.closest && target.closest(selector))) return;

            event.preventDefault();
        };

        document.addEventListener("touchmove", handler, { passive: false });
        document.addEventListener("touchstart", handler, { passive: false });
        document.addEventListener("gesturestart", handler);
        document.addEventListener("gesturechange", handler);
        document.addEventListener("gestureend", handler);

        return () => {
            document.removeEventListener("touchmove", handler);
            document.removeEventListener("touchstart", handler);
            document.removeEventListener("gesturestart", handler);
            document.removeEventListener("gesturechange", handler);
            document.removeEventListener("gestureend", handler);
        };
    };

    const create = (config = {}) => {
        const layoutConfig = buildLayout(config);
        if (config.debug && typeof console !== "undefined" && typeof console.info === "function") {
            console.info("[touchpad_controls] layout", summarizeLayout(layoutConfig));
        }
        const hasCustomButtons = Array.isArray(config.buttons) && config.buttons.length > 0;
        const buttons = hasCustomButtons ? config.buttons : layoutConfig.buttons;
        const root = config.root;

        if (config.preventGestures !== false) {
            const excludeSelectors = config.excludeSelectors || [];
            var removeGesturePrevention = createGesturePrevention({ excludeSelectors });
        }

        let instance = createTouchpadControls({ root, buttons });
        let resizeTimer = null;

        const rebuild = () => {
            if (instance && typeof instance.destroy === "function") {
                instance.destroy();
            }
            const nextLayout = buildLayout(config);
            if (config.debug && typeof console !== "undefined" && typeof console.info === "function") {
                console.info("[touchpad_controls] layout", summarizeLayout(nextLayout));
            }
            const nextButtons = hasCustomButtons ? config.buttons : nextLayout.buttons;
            instance = createTouchpadControls({ root, buttons: nextButtons });
        };

        const handleResize = () => {
            if (resizeTimer) window.clearTimeout(resizeTimer);
            resizeTimer = window.setTimeout(rebuild, 120);
        };

        if (config.responsive !== false && typeof window !== "undefined") {
            window.addEventListener("resize", handleResize);
        }

        return {
            layout: layoutConfig.layout,
            buttons,
            diagnostics: config.debug ? summarizeLayout(layoutConfig) : null,
            destroy: () => {
                if (resizeTimer && typeof window !== "undefined") {
                    window.clearTimeout(resizeTimer);
                }
                if (config.responsive !== false && typeof window !== "undefined") {
                    window.removeEventListener("resize", handleResize);
                }
                if (instance && typeof instance.destroy === "function") {
                    instance.destroy();
                }
                if (typeof removeGesturePrevention === "function") {
                    removeGesturePrevention();
                }
            },
            rebuild
        };
    };

    return {
        createTouchpadControls,
        create,
        buildLayout,
        chooseLayout,
        getLayoutMetrics,
        parseKeys,
        simulateKeyEvent,
        resolveKeyDescriptor,
        _internal: {
            buildButtonsForLayout,
            normalizeBindings,
            clampPosition,
            summarizeLayout,
            extractBindingsFromAxesActions,
            resolveBindingsAndMeta
        }
    };
}));

</script>
    <script>
    const touchBindings = {
        "jump": "Space",
        "pause": "KeyP",
        "modifier": "KeyZ",
        "move": {
            "left": "ArrowLeft",
            "right": "ArrowRight"
        }
    };
    const touchActionMeta = {
        "jump": {
            "behavior": "discrete",
            "interaction": "tap",
            "simultaneous": true,
            "kind": "button"
        },
        "pause": {
            "behavior": "discrete",
            "interaction": "tap",
            "simultaneous": false,
            "kind": "button"
        },
        "modifier": {
            "behavior": "discrete",
            "interaction": "tap",
            "simultaneous": true,
            "kind": "button"
        },
        "move": {
            "behavior": "continuous",
            "interaction": "hold",
            "simultaneous": false,
            "control_space": "vector",
            "activation": "hold",
            "direction_mode": "cardinal",
            "granularity": "fine",
            "kind": "axis"
        }
    };

    TouchpadControls.create({
        layout: "auto",
        bindings: touchBindings,
        actionMeta: touchActionMeta,
        debug: true,
    });
</script>
</body>
</html>