<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON SHIFT: THE WEAVER</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Orbitron', sans-serif;
            color: #fff;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, #1a1a2e 0%, #050505 100%);
        }

        canvas {
            display: block;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            background-color: #000;
            image-rendering: pixelated;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00f2ff;
            padding: 10px 20px;
            margin-bottom: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.3);
        }

        .stat-label { font-size: 12px; color: #00f2ff; text-transform: uppercase; }
        .stat-value { font-size: 24px; font-weight: bold; }

        #screen-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border: 3px solid #ff00ff;
            border-radius: 15px;
            display: none;
            z-index: 100;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
        }

        #screen-msg h2 { margin-top: 0; font-size: 48px; color: #ff00ff; text-shadow: 0 0 10px #ff00ff; }
        #screen-msg p { font-size: 18px; margin-bottom: 20px; }
        
        .btn {
            background: transparent;
            border: 2px solid #00f2ff;
            color: #00f2ff;
            padding: 10px 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .btn:hover {
            background: #00f2ff;
            color: #000;
            box-shadow: 0 0 20px #00f2ff;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
        }

        .keyboard-key {
            display: inline-block;
            border: 1px solid #fff;
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 4px;
            background: rgba(255,255,255,0.1);
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 5px solid #00f2ff;
            border-top: 5px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<multi-asset-sheet id="game_sprites" assets="hero_idle,hero_run,portal,spike_blue,spike_pink,orb_collectible,tile_cyan,tile_magenta" style="vibrant neon cyberpunk glowing pixel art, high contrast black background, 2D platformer style" server_sheet_key="31a5fa40b29f22727ccb264bee030b68b8da427e5789139a71e166daab7f88b0" server_sheet_hash="4190f009e404ef2563347fe8042c59428d16846553c4691ca06a3889ea0ac38e" server_sheet_dt="2026-01-12T17:38:10.739526+00:00"></multi-asset-sheet>

<div id="loading-screen">
    <div class="loader"></div>
    <p style="margin-top: 20px;">INITIALIZING REALITY...</p>
</div>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-overlay">
        <div class="stat-box">
            <div class="stat-label">Reality Phase</div>
            <div id="phase-display" class="stat-value" style="color: #00f2ff;">CYAN</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Orbs</div>
            <div id="score-display" class="stat-value">0 / 0</div>
        </div>
    </div>

    <div id="screen-msg">
        <h2 id="msg-title">PHASE SYNCED</h2>
        <p id="msg-body">Level Complete! Ready for the next shift?</p>
        <button class="btn" id="msg-btn">CONTINUE</button>
    </div>

    <div id="instructions">
        <span class="keyboard-key">W A S D</span> or <span class="keyboard-key">ARROWS</span> to Move & Jump 
        | <span class="keyboard-key">SPACE</span> or <span class="keyboard-key">SHIFT</span> to SHIFT REALITY
    </div>
</div>

<script>
    /**
     * NEON SHIFT: THE WEAVER
     * A high-fidelity 2D platformer with a reality-shifting mechanic.
     */

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const phaseDisplay = document.getElementById('phase-display');
    const scoreDisplay = document.getElementById('score-display');
    const screenMsg = document.getElementById('screen-msg');
    const msgTitle = document.getElementById('msg-title');
    const msgBody = document.getElementById('msg-body');
    const msgBtn = document.getElementById('msg-btn');
    const loadingScreen = document.getElementById('loading-screen');

    // Constants
    const CANVAS_WIDTH = 1000;
    const CANVAS_HEIGHT = 600;
    const GRAVITY = 0.5;
    const FRICTION = 0.8;
    const JUMP_FORCE = -12;
    const SPEED = 0.8;
    const MAX_SPEED = 6;
    const TILE_SIZE = 40;

    // Assets
    const IMAGES = {
        hero: 'https://images.fuzzycode.dev/multi_ai?grab=hero_idle&resize=40x40&sheet_key=31a5fa40b29f22727ccb264bee030b68b8da427e5789139a71e166daab7f88b0',
        portal: 'https://images.fuzzycode.dev/multi_ai?grab=portal&resize=60x60&sheet_key=31a5fa40b29f22727ccb264bee030b68b8da427e5789139a71e166daab7f88b0',
        spikeCyan: 'https://images.fuzzycode.dev/multi_ai?grab=spike_blue&resize=40x40&sheet_key=31a5fa40b29f22727ccb264bee030b68b8da427e5789139a71e166daab7f88b0',
        spikeMagenta: 'https://images.fuzzycode.dev/multi_ai?grab=spike_pink&resize=40x40&sheet_key=31a5fa40b29f22727ccb264bee030b68b8da427e5789139a71e166daab7f88b0',
        orb: 'https://images.fuzzycode.dev/multi_ai?grab=orb_collectible&resize=30x30&sheet_key=31a5fa40b29f22727ccb264bee030b68b8da427e5789139a71e166daab7f88b0',
        tileCyan: 'https://images.fuzzycode.dev/multi_ai?grab=tile_cyan&resize=40x40&sheet_key=31a5fa40b29f22727ccb264bee030b68b8da427e5789139a71e166daab7f88b0',
        tileMagenta: 'https://images.fuzzycode.dev/multi_ai?grab=tile_magenta&resize=40x40&sheet_key=31a5fa40b29f22727ccb264bee030b68b8da427e5789139a71e166daab7f88b0',
        bg: 'https://images.fuzzycode.dev/fast_ai?search=cyberpunk%20city%20silhouette%20background%20abstract%20dark&resize=1000x600'
    };

    const SOUNDS = {
        jump: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=retro_video_game_jump_synth&duration=0.5&ext=.mp3'),
        shift: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=cyberpunk_glitch_switch_sound&duration=0.8&ext=.mp3'),
        death: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=electronic_disintegration_sound&duration=1&ext=.mp3'),
        collect: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=digital_sparkle_collect&duration=0.5&ext=.mp3'),
        win: new Audio('https://sounds.fuzzycode.dev/sound_effect?prompt=level_complete_victory_tune&duration=2&ext=.mp3'),
        music: new Audio('https://sounds.fuzzycode.dev/music?prompt=synthwave_ambient_cyberpunk_adventure_loop&duration=45&ext=.mp3')
    };
    SOUNDS.music.loop = true;
    SOUNDS.music.volume = 0.4;

    // Game State
    let gameState = 'playing';
    let currentLevel = 0;
    let currentPhase = 'CYAN'; // 'CYAN' or 'MAGENTA'
    let score = 0;
    let particles = [];
    let keys = {};
    let camera = { x: 0, y: 0 };

    const player = {
        x: 100,
        y: 100,
        width: 32,
        height: 38,
        velX: 0,
        velY: 0,
        grounded: false,
        lastDir: 1,
        color: '#00f2ff'
    };

    // Levels
    // 0: Empty, 1: Cyan Block, 2: Magenta Block, 3: Spike Cyan, 4: Spike Magenta, 5: Orb, 6: Portal, P: Player Start
    const levelData = [
        [
            "                        ",
            "                        ",
            "      5      5      6   ",
            "     111    222    111  ",
            "                        ",
            "   P                    ",
            "111111111111111111111111",
            "                        "
        ],
        [
            "                                     ",
            "                                     ",
            "               5                     ",
            "               1    5                ",
            "              111   22      6        ",
            "      5      22222  11     111       ",
            "     11     222222  22    11111      ",
            "    1111   2222222  11               ",
            "   P      11111111  22               ",
            "1111111111111111111111111111111111111",
            "                                     "
        ],
        [
            "                                            ",
            "                                            ",
            "                   333                      ",
            "                   111          5      6    ",
            "          2222                  111   111   ",
            "         222222        11111                ",
            "        22222222      1111111               ",
            "       2222222222    111111111              ",
            "   P  111111111111  22222222222             ",
            "11111111111111111111111111111111111111111111",
            "                                            "
        ],
        [
            "                                            ",
            "             5                              ",
            "            222          444           6    ",
            "           22222        22222         111   ",
            "          2222222                             ",
            "         222222222                            ",
            "   P    11111111111   11111111   22222222   ",
            "1111111111111111111   11111111   22222222   ",
            "                                            "
        ]
    ];

    let currentMap = [];
    let mapObjects = [];
    let totalOrbs = 0;

    // Initialization
    function initLevel(index) {
        if (index >= levelData.length) {
            winGame();
            return;
        }

        currentLevel = index;
        currentMap = levelData[index];
        mapObjects = [];
        score = 0;
        totalOrbs = 0;
        currentPhase = 'CYAN';
        updateUI();

        for (let y = 0; y < currentMap.length; y++) {
            for (let x = 0; x < currentMap[y].length; x++) {
                const char = currentMap[y][x];
                const objX = x * TILE_SIZE;
                const objY = y * TILE_SIZE;

                if (char === '1') mapObjects.push({ x: objX, y: objY, type: 'block', phase: 'CYAN' });
                else if (char === '2') mapObjects.push({ x: objX, y: objY, type: 'block', phase: 'MAGENTA' });
                else if (char === '3') mapObjects.push({ x: objX, y: objY, type: 'spike', phase: 'CYAN' });
                else if (char === '4') mapObjects.push({ x: objX, y: objY, type: 'spike', phase: 'MAGENTA' });
                else if (char === '5') {
                    mapObjects.push({ x: objX + 5, y: objY + 5, type: 'orb', collected: false });
                    totalOrbs++;
                }
                else if (char === '6') mapObjects.push({ x: objX, y: objY, type: 'portal' });
                else if (char === 'P') {
                    player.x = objX;
                    player.y = objY;
                    player.velX = 0;
                    player.velY = 0;
                }
            }
        }
        updateUI();
        gameState = 'playing';
        screenMsg.style.display = 'none';
        
        // Start music on first interaction
        if (index === 0) {
            document.addEventListener('keydown', () => SOUNDS.music.play(), { once: true });
        }
    }

    function updateUI() {
        phaseDisplay.textContent = currentPhase;
        phaseDisplay.style.color = currentPhase === 'CYAN' ? '#00f2ff' : '#ff00ff';
        scoreDisplay.textContent = `${score} / ${totalOrbs}`;
    }

    // Input Handling
    window.addEventListener('keydown', e => {
        keys[e.code] = true;
        if (e.code === 'Space' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
            shiftReality();
        }
    });
    window.addEventListener('keyup', e => keys[e.code] = false);

    function shiftReality() {
        if (gameState !== 'playing') return;
        currentPhase = currentPhase === 'CYAN' ? 'MAGENTA' : 'CYAN';
        SOUNDS.shift.currentTime = 0;
        SOUNDS.shift.play();
        updateUI();
        spawnParticles(player.x + player.width/2, player.y + player.height/2, currentPhase === 'CYAN' ? '#00f2ff' : '#ff00ff', 20);
    }

    // Particle System
    function spawnParticles(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color
            });
        }
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    // Physics & Logic
    function update() {
        if (gameState !== 'playing') return;

        // Player Movement
        if (keys['ArrowLeft'] || keys['KeyA']) {
            if (player.velX > -MAX_SPEED) player.velX -= SPEED;
            player.lastDir = -1;
        } else if (keys['ArrowRight'] || keys['KeyD']) {
            if (player.velX < MAX_SPEED) player.velX += SPEED;
            player.lastDir = 1;
        } else {
            player.velX *= FRICTION;
        }

        if ((keys['ArrowUp'] || keys['KeyW']) && player.grounded) {
            player.velY = JUMP_FORCE;
            player.grounded = false;
            SOUNDS.jump.currentTime = 0;
            SOUNDS.jump.play();
        }

        player.velY += GRAVITY;
        player.x += player.velX;
        player.y += player.velY;

        // Collisions
        player.grounded = false;
        
        for (const obj of mapObjects) {
            if (obj.type === 'block') {
                // Only collide with blocks of the current phase
                if (obj.phase !== currentPhase) continue;

                const col = checkCollision(player, obj);
                if (col) {
                    if (col === 'b') {
                        player.grounded = true;
                        player.velY = 0;
                        player.y = obj.y - player.height;
                    } else if (col === 't') {
                        player.velY = 0;
                        player.y = obj.y + TILE_SIZE;
                    } else if (col === 'l') {
                        player.velX = 0;
                        player.x = obj.x + TILE_SIZE;
                    } else if (col === 'r') {
                        player.velX = 0;
                        player.x = obj.x - player.width;
                    }
                }
            } else if (obj.type === 'spike') {
                if (obj.phase === currentPhase && checkSimpleCollision(player, obj)) {
                    die();
                }
            } else if (obj.type === 'orb' && !obj.collected) {
                if (checkSimpleCollision(player, obj)) {
                    obj.collected = true;
                    score++;
                    updateUI();
                    SOUNDS.collect.currentTime = 0;
                    SOUNDS.collect.play();
                    spawnParticles(obj.x, obj.y, '#fff', 10);
                }
            } else if (obj.type === 'portal') {
                if (checkSimpleCollision(player, obj)) {
                    if (score >= totalOrbs) {
                        levelComplete();
                    }
                }
            }
        }

        // World Bounds
        if (player.y > CANVAS_HEIGHT + 200) die();

        // Camera
        camera.x += (player.x - camera.x - CANVAS_WIDTH / 2) * 0.1;
        
        updateParticles();
    }

    function checkCollision(p, b) {
        const vX = (p.x + (p.width / 2)) - (b.x + (TILE_SIZE / 2));
        const vY = (p.y + (p.height / 2)) - (b.y + (TILE_SIZE / 2));
        const hWidths = (p.width / 2) + (TILE_SIZE / 2);
        const hHeights = (p.height / 2) + (TILE_SIZE / 2);
        let colDir = null;

        if (Math.abs(vX) < hWidths && Math.abs(vY) < hHeights) {
            const oX = hWidths - Math.abs(vX);
            const oY = hHeights - Math.abs(vY);
            if (oX >= oY) {
                if (vY > 0) {
                    colDir = 't';
                } else {
                    colDir = 'b';
                }
            } else {
                if (vX > 0) {
                    colDir = 'l';
                } else {
                    colDir = 'r';
                }
            }
        }
        return colDir;
    }

    function checkSimpleCollision(p, b) {
        const padding = 5;
        return p.x < b.x + TILE_SIZE - padding &&
               p.x + p.width > b.x + padding &&
               p.y < b.y + TILE_SIZE - padding &&
               p.y + p.height > b.y + padding;
    }

    function die() {
        SOUNDS.death.play();
        spawnParticles(player.x, player.y, '#ff0000', 30);
        gameState = 'dead';
        setTimeout(() => initLevel(currentLevel), 1000);
    }

    function levelComplete() {
        gameState = 'complete';
        SOUNDS.win.play();
        msgTitle.textContent = "PHASE SYNCED";
        msgBody.textContent = `Level ${currentLevel + 1} Stabilized. All orbs acquired.`;
        msgBtn.textContent = "NEXT LEVEL";
        screenMsg.style.display = 'block';
    }

    function winGame() {
        gameState = 'won';
        msgTitle.textContent = "SYSTEM RESTORED";
        msgBody.textContent = "You have woven reality back together. The city is safe.";
        msgBtn.textContent = "RESTART";
        screenMsg.style.display = 'block';
    }

    msgBtn.onclick = () => {
        if (gameState === 'won') initLevel(0);
        else initLevel(currentLevel + 1);
    };

    // Rendering
    const assetCache = {};
    function getImg(url) {
        if (!assetCache[url]) {
            const img = new Image();
            img.src = url;
            assetCache[url] = img;
        }
        return assetCache[url];
    }

    function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Background (Parallax-ish)
        const bgImg = getImg(IMAGES.bg);
        ctx.globalAlpha = 0.3;
        ctx.drawImage(bgImg, -camera.x * 0.2, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.drawImage(bgImg, -camera.x * 0.2 + CANVAS_WIDTH, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.globalAlpha = 1.0;

        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Draw Map Objects
        for (const obj of mapObjects) {
            if (obj.type === 'block') {
                const img = obj.phase === 'CYAN' ? getImg(IMAGES.tileCyan) : getImg(IMAGES.tileMagenta);
                ctx.globalAlpha = (obj.phase === currentPhase) ? 1.0 : 0.15;
                ctx.shadowBlur = (obj.phase === currentPhase) ? 10 : 0;
                ctx.shadowColor = obj.phase === 'CYAN' ? '#00f2ff' : '#ff00ff';
                ctx.drawImage(img, obj.x, obj.y, TILE_SIZE, TILE_SIZE);
            } else if (obj.type === 'spike') {
                const img = obj.phase === 'CYAN' ? getImg(IMAGES.spikeCyan) : getImg(IMAGES.spikeMagenta);
                ctx.globalAlpha = (obj.phase === currentPhase) ? 1.0 : 0.1;
                ctx.drawImage(img, obj.x, obj.y, TILE_SIZE, TILE_SIZE);
            } else if (obj.type === 'orb' && !obj.collected) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#fff';
                ctx.drawImage(getImg(IMAGES.orb), obj.x, obj.y + Math.sin(Date.now() / 200) * 5, 30, 30);
            } else if (obj.type === 'portal') {
                ctx.shadowBlur = 20;
                ctx.shadowColor = score >= totalOrbs ? '#00ff00' : '#444';
                ctx.globalAlpha = score >= totalOrbs ? 1.0 : 0.5;
                ctx.drawImage(getImg(IMAGES.portal), obj.x - 10, obj.y - 20, 60, 60);
            }
            ctx.globalAlpha = 1.0;
            ctx.shadowBlur = 0;
        }

        // Draw Player
        if (gameState !== 'dead') {
            ctx.save();
            if (player.lastDir === -1) {
                // Flip horizontally around the player's center
                ctx.translate(player.x + player.width / 2, 0);
                ctx.scale(-1, 1);
                ctx.translate(-(player.x + player.width / 2), 0);
            }
            ctx.shadowBlur = 15;
            ctx.shadowColor = currentPhase === 'CYAN' ? '#00f2ff' : '#ff00ff';
            ctx.drawImage(getImg(IMAGES.hero), player.x, player.y, player.width, player.height);
            ctx.restore();
        }

        // Particles
        for (const p of particles) {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, 4, 4);
        }
        ctx.globalAlpha = 1.0;

        ctx.restore();

        // Scanline effect
        ctx.fillStyle = 'rgba(18, 16, 16, 0.1)';
        for (let i = 0; i < CANVAS_HEIGHT; i += 4) {
            ctx.fillRect(0, i, CANVAS_WIDTH, 1);
        }

        requestAnimationFrame(gameLoop);
    }

    function gameLoop() {
        update();
        draw();
    }

    // Resize handling
    function resize() {
        const ratio = CANVAS_WIDTH / CANVAS_HEIGHT;
        let w = window.innerWidth;
        let h = window.innerHeight;
        if (w / h > ratio) w = h * ratio;
        else h = w / ratio;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
    }

    window.onresize = resize;
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;
    resize();

    // Start
    window.onload = () => {
        // Give a moment for sprites to "load" (though the server handles replacement)
        setTimeout(() => {
            loadingScreen.style.display = 'none';
            initLevel(0);
            gameLoop(); // Start the game logic and rendering loop
        }, 1500);
    };

</script>
</body>
</html>